{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the SAFE documentation site! This site contains all the documentation you'll need to quickly starting creating SAFE apps in F#.</p> <p>If you've not heard of SAFE before, please feel free to start with the introduction. Alternatively, you can immediately try out the quickstart guide and tutorial, or simply browse through the documentation.</p> <p>If there's anything missing from here, please feel free to add the documentation directly (or supply an issue) to the GitHub repository.</p> <p>We hope you enjoy using SAFE as much as we do!</p> <p>The SAFE team :)</p> <p></p>"},{"location":"awesome-safe-components/","title":"SAFE-Compatible UI Components","text":"<p>A set of SAFE-ready wrappers around existing React and JS UI Components. </p>"},{"location":"awesome-safe-components/#how-can-i-contribute-my-library-to-this-list","title":"How can I contribute my library to this list?","text":""},{"location":"awesome-safe-components/#required","title":"Required","text":"<ul> <li>Adding a README with installation instructions</li> <li>Adding femto metadata to the projects</li> </ul>"},{"location":"awesome-safe-components/#nice-to-have","title":"Nice to have","text":"<ul> <li>Adding documentation with sample code on the various use cases </li> <li>Adding live documentation website with sample code</li> </ul>"},{"location":"awesome-safe-components/#react-bindings","title":"React bindings","text":""},{"location":"awesome-safe-components/#feliz-recommended","title":"Feliz (Recommended)","text":"<p>A fresh retake of the React API in Fable and a collection of high-quality components to build React applications in F#, optimized for happiness. Get it!</p>"},{"location":"awesome-safe-components/#fablereact","title":"Fable.React","text":"<p>Fable bindings and helpers for React and React Native. Get it!</p>"},{"location":"awesome-safe-components/#ui-frameworks","title":"UI Frameworks","text":""},{"location":"awesome-safe-components/#felizbulma","title":"Feliz.Bulma","text":"<p>Bulma UI wrapper for amazing Feliz DSL. Get it!</p>"},{"location":"awesome-safe-components/#fulma","title":"Fulma","text":"<p>Fulma provides a wrapper around Bulma 0.9.0, an open source CSS framework, for fable-react. Get it!</p>"},{"location":"awesome-safe-components/#felizmaterialui","title":"Feliz.MaterialUI","text":"<p>Feliz-style Fable bindings for Material-UI. Get it!</p>"},{"location":"awesome-safe-components/#fablereactstrap","title":"Fable.Reactstrap","text":"<p>Fable binding for reactstrap. Get it!</p>"},{"location":"awesome-safe-components/#fablematerialui","title":"Fable.MaterialUI","text":"<p>Fable bindings for Material-UI. Get it!</p>"},{"location":"awesome-safe-components/#fableantd","title":"Fable.AntD","text":"<p>Fable bindings for Ant Design React components. Get it!</p>"},{"location":"awesome-safe-components/#fablefontawesomefree","title":"Fable.FontAwesome.Free","text":"<p>Bindings for the Free icons of Font Awesome, should be used with Fable.FontAwesome. Get it!</p>"},{"location":"awesome-safe-components/#fablefluentui","title":"Fable.FluentUI","text":"<p>FluentUI (React) to Fable bindings. Get it! </p>"},{"location":"awesome-safe-components/#fablereactgridsystem","title":"Fable.ReactGridSystem","text":"<p>React Grid System to Fable bindings. Get it! </p>"},{"location":"awesome-safe-components/#ui-controls","title":"UI Controls","text":""},{"location":"awesome-safe-components/#felizpopover","title":"Feliz.Popover","text":"<p>Feliz-style Fable bindings for react-popover. Get it! </p>"},{"location":"awesome-safe-components/#felizselectsearch","title":"Feliz.SelectSearch","text":"<p>A binding for react-select-search that implements a searchable and customizable dropdown for Feliz applications. Get it!</p>"},{"location":"awesome-safe-components/#felizkawaii","title":"Feliz.Kawaii","text":"<p>Feliz-style Fable bindings for react-kawaii which contains lovely SVG components. Get it!</p>"},{"location":"awesome-safe-components/#felizsweetalert","title":"Feliz.SweetAlert","text":"<p>Feliz-style Fable bindings for sweetalert2 and sweetalert2-react-content with Feliz style api for use within React applications. Implemented as both normal functions and Elmish commands, for maximum flexibility. Get it!</p>"},{"location":"awesome-safe-components/#elmishsweetalert","title":"Elmish.SweetAlert","text":"<p>SweetAlert integration for Fable, made with love to work in Elmish apps. Get it!</p>"},{"location":"awesome-safe-components/#elmishtoastr","title":"Elmish.Toastr","text":"<p>Toastr integration with Fable, implemented as Elmish commands. Get it!</p>"},{"location":"awesome-safe-components/#elmishanimatedtree","title":"Elmish.AnimatedTree","text":"<p>A fork and binding of react-animated-tree, adapted to properly work within Elmish applications. Get it!</p>"},{"location":"awesome-safe-components/#felizreacthamburger","title":"Feliz.ReactHamburger","text":"<p>Feliz-style Fable bindings for hamburger-react. Get it!</p>"},{"location":"awesome-safe-components/#felizreactawesomeslider","title":"Feliz.ReactAwesomeSlider","text":"<p>Feliz-style Fable bindings for react-awesome-slider. Get it!</p>"},{"location":"awesome-safe-components/#felizreactselect","title":"Feliz.ReactSelect","text":"<p>Feliz-style Fable bindings for react-select. Get it!</p>"},{"location":"awesome-safe-components/#fablereactflatpickr","title":"Fable.React.Flatpickr","text":"<p>Fable binding for react-flatpickr that is ready to use within Elmish applications. Get it!</p>"},{"location":"awesome-safe-components/#feliztippy","title":"Feliz.Tippy","text":"<p>Feliz-style Fable bindings for tippyjs-react. Get it!</p>"},{"location":"awesome-safe-components/#felizreactspeedometer","title":"Feliz.ReactSpeedometer","text":"<p>Feliz-style Fable bindings for react-d3-speedometer. Get it!</p>"},{"location":"awesome-safe-components/#fablereactkanban","title":"Fable.ReactKanban","text":"<p>React Kanban bindings for Fable React. Get it!</p>"},{"location":"awesome-safe-components/#fablereactdrawingcanvas","title":"Fable.React.DrawingCanvas","text":"<p>This is a Fable React wrapper for canvas that allows you to declare a drawing. Get it!</p>"},{"location":"awesome-safe-components/#fablegroupingpanel","title":"Fable.GroupingPanel","text":"<p>An F# computation expression that groups Fable UI data into one or more collapsable panels. Get it!</p>"},{"location":"awesome-safe-components/#data-visualisation","title":"Data Visualisation","text":""},{"location":"awesome-safe-components/#felizaggrid","title":"Feliz.AgGrid","text":"<p>Feliz-style Fable bindings for ag-grid. Get it!</p>"},{"location":"awesome-safe-components/#fablereactaggrid","title":"Fable.ReactAgGrid","text":"<p>Fable bindings for ag-grid. Get it!</p>"},{"location":"awesome-safe-components/#felizreactflow","title":"Feliz.Reactflow","text":"<p>Feliz-style Fable bindings for react flow. Get it!</p>"},{"location":"awesome-safe-components/#maps","title":"Maps","text":""},{"location":"awesome-safe-components/#fablereactgooglemaps","title":"Fable.ReactGoogleMaps","text":"<p>Feliz-style Fable bindings for react-google-maps. Get it!</p>"},{"location":"awesome-safe-components/#felizpigeonmaps","title":"Feliz.PigeonMaps","text":"<p>Feliz-style bindings for pigeon-maps, React maps without external dependencies. This binding includes it's own custom PigeonMaps.marker component to build map markers manually. Get it! </p>"},{"location":"awesome-safe-components/#charting","title":"Charting","text":""},{"location":"awesome-safe-components/#felizagchart","title":"Feliz.AgChart","text":"<p>Feliz-style bindings for ag-charts. Get it!</p>"},{"location":"awesome-safe-components/#felizplotly","title":"Feliz.Plotly","text":"<p>Fable bindings for plotly.js and react-plotly.js with Feliz style api for use within React applications. Lets you build visualizations in an easy, discoverable, and safe fashion. Get it!</p>"},{"location":"awesome-safe-components/#felizrecharts","title":"Feliz.Recharts","text":"<p>Feliz-style bindings for recharts, a composable charting library built on React components. The binding translates the original API of recharts in a one-to-one fashion but makes it type-safe and easily discoverable. Get it! </p>"},{"location":"awesome-safe-components/#felizroughviz","title":"Feliz.RoughViz","text":"<p>Feliz-style Fable bindings for roughViz visualisation library. It is a fun project when your data visualisations don't need to be formal. This binding is actually made to work with original rough-viz library than renders to the DOM rather than an existing third-party React library which makes it a nice example to learn from. Get it! </p>"},{"location":"awesome-safe-components/#state-management","title":"State management","text":""},{"location":"awesome-safe-components/#felizrecoil","title":"Feliz.Recoil","text":"<p>Fable bindings in Feliz style for Facebook's experimental state management library recoil. Get it!</p>"},{"location":"awesome-safe-components/#testing","title":"Testing","text":""},{"location":"awesome-safe-components/#fablejester","title":"Fable.Jester","text":"<p>Fable bindings for jest and friends for delightful Fable testing. Get it!</p>"},{"location":"awesome-safe-components/#fablemocha","title":"Fable.Mocha","text":"<p>Fable library for testing. Inspired by the popular Expecto library for F# and adopts the testList, testCase and testCaseAsync primitives for defining tests. Get it!</p>"},{"location":"awesome-safe-components/#fablereacttestinglibrary","title":"Fable.ReactTestingLibrary","text":"<p>Fable bindings for react-testing-library and user-event. Get it!</p>"},{"location":"awesome-safe-components/#animation","title":"Animation","text":""},{"location":"awesome-safe-components/#funreactspring","title":"Fun.ReactSpring","text":"<p>Fable bindings for react spring. Get it!</p>"},{"location":"intro/","title":"Introduction","text":""},{"location":"intro/#what-is-safe","title":"What is SAFE?","text":"<p>The SAFE stack is the best way to write functional-first web applications.</p> <p>The SAFE stack allows you to develop web applications almost entirely in F#, without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications. SAFE Stack is:</p> <ul> <li>Open-source</li> <li>Free</li> <li>Type-safe</li> <li>Flexible</li> <li>Cloud-ready</li> </ul> <p>The SAFE stack is made up of four components:</p> <ul> <li>A web server running on .NET for hosting back-end services in F#</li> <li>A hosting platform that provides simple, scalable deployment models plus associated platform services for application developers</li> <li>A mechanism to run F# in the web browser for client-side delivery of F#</li> <li>An F# programming model for client-side user interfaces</li> </ul>"},{"location":"intro/#why-safe","title":"Why SAFE?","text":"<p>SAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\".</p> <ul> <li>Create client / server applications entirely in F#</li> <li>Re-use development skills on client and server</li> <li>Rapidly create rich client-side web applications with no JavaScript knowledge</li> <li>Runs on the latest .NET (and tested daily by Microsoft)</li> <li>Rapid development cycle with support for hot module replacement</li> <li>Interact with native JavaScript libraries whenever needed</li> <li>Create client-side applications purely in F#, with full type checking for safety</li> <li>Seamlessly share code between client and server</li> </ul>"},{"location":"knownIssues/","title":"Known Issues","text":"<p>This page contains a (hopefully short) list of higher impact bugs that affect the SAFE template. It is not our intention to make an exhaustive list here; for all issues, check GitHub.</p>"},{"location":"knownIssues/#server-not-starting-error-dotnet-paket-restore-exited-with-code-532462766","title":"Server not starting: error: \"dotnet paket restore\" exited with code -532462766","text":"<p>.NET SDK 8.0.300 introduced a bug that caused the Server startup to fail with a paket error (<code>\"dotnet paket restore\" exited with code -532462766</code>). This has been resolved in SDK version 8.0.303.</p> <p>If for some reason you can not use a newer SDK version, pin the SDK version using<code>global.json</code>:</p> <pre><code>{\n    \"sdk\": {\n    \"version\": \"8.0.206\"\n    }\n}\n</code></pre>"},{"location":"learning/","title":"Learning","text":"<p>This section contains useful repositories that allow you to learn more about the SAFE stack, at your own pace.</p>"},{"location":"learning/#tutorials","title":"Tutorials","text":""},{"location":"learning/#safe-dojo","title":"SAFE Dojo","text":"<p>This dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations.</p> <p>The dojo takes around 90 minutes to complete if you have never worked with the stack before.</p>"},{"location":"learning/#safe-samples","title":"SAFE Samples","text":"<p>The following example repositories (and more!) can be found in the official SAFE Stack organisational GitHub page.</p>"},{"location":"learning/#safe-todo-list","title":"SAFE Todo List","text":"<p>The simplest Todo app: a client-server application written entirely in F# using Elmish on the client. Remoting for type-safe communication between the two.</p>"},{"location":"learning/#tabula-rasa","title":"tabula-rasa","text":"<p>A minimalistic real-worldish blog engine written entirely in F#. Specifically made as a learning resource when building apps with the SAFE stack. This application features many concerns of large apps such as logging, database access, secured remoting, web sockets and much more. </p>"},{"location":"learning/#safe-bookstore","title":"SAFE Bookstore","text":"<p>This sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store.</p>"},{"location":"learning/#safe-confplanner","title":"SAFE ConfPlanner","text":"<p>This sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture.</p>"},{"location":"learning/#safe-search","title":"SAFE Search","text":"<p>This repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways.</p>"},{"location":"learning/#safe-chat","title":"SAFE Chat","text":"<p>This application is a real-time chat application built on SAFE that uses the AKKA framework to manage actors that represent chat users, including Akka Streams and the Akkling F# library.</p>"},{"location":"learning/#safe-nightwatch","title":"SAFE Nightwatch","text":"<p>This application is a sample mobile application using the React Native library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you.</p>"},{"location":"learning/#videos","title":"Videos","text":"<ul> <li>SAFE apps with F# web stack at Lambda Days 2018 (Tomasz Heimowski)</li> <li>Modern app development with Fable and React Native at NDC Oslo 2017 (Steffen Forkmann)</li> <li>Reinventing MVC pattern for F# web development at NDC Oslo 2018 (Krzysztof Cieslak)</li> </ul>"},{"location":"learning/#other-resources","title":"Other Resources","text":"<ul> <li>The Hanselminutes podcast: F# and the functional SAFE Stack with Krzysztof Cieslak</li> <li>Introducing Fable.Remoting: Automated Type-Safe Client-Server Communication for Fable Apps</li> <li>Learning about the F# SAFE stack  High level introduction to the SAFE stack by Scott Hanselman</li> </ul>"},{"location":"news/","title":"News and Announcements","text":""},{"location":"news/#2022","title":"2022","text":""},{"location":"news/#23th-june-safe-v4-now-with-net-60","title":"23th June - SAFE v4 now with .NET 6.0","text":"<p>Enjoy the latest version of .NET runtime with newest SAFE Stack template!</p>"},{"location":"news/#2021","title":"2021","text":""},{"location":"news/#28th-june-safe-v3-is-live","title":"28th June - SAFE v3 is Live!","text":"<p>After a long beta test period, we're excited to launch SAFE 3! The new template upgrades SAFE to .NET 5 compatibility, Fable 3 and the latest versions of Giraffe and Saturn. We've also introduced the use of the popular Feliz domain-specific language (DSL), upgraded all documentation and made the build process even easier to use.</p> <p>We're super excited about this update as well as hearing about your suggestions and ideas to make it even better in the future.</p>"},{"location":"news/#2020","title":"2020","text":""},{"location":"news/#22nd-august-safe-v2-launches","title":"22nd August - SAFE v2 Launches!","text":"<p>It's taken a while, but we're delighted to announce the launch of SAFE v2. The new template has been drastically slimmed down and provides a highly streamlined approach, whilst we've incorporated requested features such as testing support out of the box.</p> <p>We're looking forward to building on the new template with improved documentation, a set of easy-to-follow recipes for common tasks as well as new demos, exercises and a set of new wrappers around popular JS and React libraries.</p>"},{"location":"news/#2018","title":"2018","text":""},{"location":"news/#5th-august","title":"5th August","text":"<p>We're pleased to see that the Suave team has clarified their license and explicitly removed the dependency on the Logary package. However, our decision to remove Suave from the SAFE stack remains: Suave no longer forms a part of the strategic goals of the SAFE project, and our server-side focus remains on improving the experience for both Giraffe and Saturn.</p> <p>We nonetheless wish the Suave project, team and contributors the best of luck for the future.</p>"},{"location":"news/#18th-june","title":"18th June","text":"<p>Due to the unclear future regarding the licensing of Suave and its dependencies, the SAFE team has today made the unamimous decision to remove Suave as a recommended option on the SAFE stack. We will no longer provide guidance on integrating Suave with the SAFE stack, nor will we maintain existing capabilities for it in SAFE tooling.</p> <p>Our default recommendation for SAFE stack applications is to use Saturn or Giraffe directly, running on top of Kestel on ASP.NET.</p> <p>SAFE will continue to promote all libraries, frameworks and toolchains that provide clear and consistent licensing, do not aim to discriminate against specific libraries on a commercial basis and promote open discussion.</p>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#safe-stack-components","title":"SAFE Stack components","text":"<p>The SAFE acronym is made up of four separate components:</p> <ul> <li>Saturn for back-end services in F#</li> <li>Azure as a hosting platform plus associated platform services</li> <li>Fable for running F# in the web browser</li> <li>Elmish for client-side user interfaces</li> </ul> flowchart TB     subgraph Azure App Service Host         Saturn(Saturn)         Elmish(Elmish) &lt;--&gt; Fable(Fable)         Saturn &lt;-- HTTP --&gt; Fable     end"},{"location":"overview/#saturn","title":"Saturn","text":"<p>The Saturn library builds on top of the solid foundation of both the F#-friendly Giraffe and the high performance, rock-solid ASP.NET Core web server to provide a set of optional abstractions which make configuring web applications and constructing complex routes extremely easy to achieve.</p> <p>Saturn can host RESTful API endpoints, drive static websites or server-generated content, all inside an easy-to-learn functional programming model.</p>"},{"location":"overview/#microsoft-azure","title":"Microsoft Azure","text":"<p>Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.</p>"},{"location":"overview/#fable","title":"Fable","text":"<p>Fable is an F# to JavaScript compiler, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native JavaScript as needed.</p>"},{"location":"overview/#elmish","title":"Elmish","text":"<p>The Elmish model allows you to construct user interfaces running in the browser using a functional programming approach. Based upon on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the React framework.</p>"},{"location":"overview/#further-reading","title":"Further reading","text":"<p>Please also feel free to read this blog series on the Compositional IT website for more details on the history of SAFE.</p>"},{"location":"overview/#are-there-alternative-components-in-the-safe-stack","title":"Are there alternative components in the SAFE stack?","text":"<p>Yes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some alternative technologies which are also recommended by the SAFE team if the basic stack does not fit your needs:</p> <ul> <li>Giraffe is a programming model designed for F# that runs on ASP.NET Core. As Saturn runs on top of Giraffe, you automatically get full access to it, but nonetheless it is entirely possible to write applications solely in Giraffe.</li> <li>Freya is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP.NET Core.</li> <li>AWS is Amazon's cloud compute offering, providing a large number of services available globally.</li> <li>WebSharper is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models.</li> <li>Falco is a toolkit for building functional-first, fast and fault-tolerant web applications using F#. Built upon the high-performance primitives of ASP.NET Core and optimized for building HTTP applications quickly.</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This page provides some basic guidance on getting up and running with your first SAFE application.</p>"},{"location":"quickstart/#install-pre-requisites","title":"Install pre-requisites","text":"<p>You'll need to install the following pre-requisites in order to build SAFE applications</p> <ul> <li>The .NET 8 SDK</li> <li>node.js (v18.x or v20.x)</li> <li>npm (v9.x or v10.x)</li> <li>Azure CLI (optional - required for Azure deployments)</li> </ul>"},{"location":"quickstart/#install-an-f-code-editor","title":"Install an F# code editor","text":"<p>You'll also want an IDE to create F# applications. We recommend one of the following great IDEs:</p> <ul> <li>VS Code + Ionide extension</li> <li>Visual Studio</li> <li>JetBrains Rider</li> </ul>"},{"location":"quickstart/#create-your-first-safe-app","title":"Create your first SAFE app","text":"<ol> <li>Open a command prompt</li> <li>Create a new directory on your machine and navigate into it</li> <li>Enter <code>dotnet new install SAFE.Template</code> to install the SAFE project template (only required once )</li> <li>Enter <code>dotnet new SAFE</code> to create a new SAFE project</li> <li>Enter <code>dotnet tool restore</code> to install local tools like Fable.</li> <li>Enter <code>dotnet run</code> to build and run the app</li> <li>Open a web browser and navigate to http://localhost:8080.</li> </ol> <p>Congratulations - after a short delay, you'll be presented with a basic SAFE application running in your browser! The application will by default run in \"development mode\", which means it automatically watches your project for changes; whenever you save a file in the client project it will refresh the browser automatically; if you save a file in the server project it will also restart the server in the background.</p> <p>The standard template creates an opinionated SAFE Stack app that contains everything you'll need to start developing, testing and deploying applications into Azure. Alternatively there is a \"bare-bones\" SAFE Stack app with minimal value-add features. Take a look at the template options to see a side by side comparison of features available between the standard and minimal template.</p>"},{"location":"quickstart/#troubleshooting","title":"Troubleshooting","text":"<p>Still have issues getting started? Check out the troubleshooting page.</p>"},{"location":"safe-from-scratch/","title":"Creating a SAFE Stack App from Scratch","text":"<p>This article shows the steps required in order to create a SAFE Stack 5-style app from scratch. This repository should be used as a guide to follow whilst reading this tutorial; each section links to a specific commit from the history of the repository.</p>"},{"location":"safe-from-scratch/#1-folders-and-tools","title":"1. Folders and tools","text":"<p>This first section creates some basic folders and tools that will simply coding going forwards and represents some best practices.</p>"},{"location":"safe-from-scratch/#11-create-a-basic-source-controlled-repository","title":"1.1 Create a basic source-controlled repository","text":"<ul> <li>Create a new folder.</li> <li>Put the folder under source controlled: <pre><code>git init\n</code></pre></li> <li>We recommend also creating a <code>.gitignore</code> file to ensure that you do not accidentally commit unnecessary files into your repository. This example file has been generated through VS Code and fine-tuned with extra files / folders required for SAFE Stack applications.</li> </ul>"},{"location":"safe-from-scratch/#12-set-up-basic-tooling-support","title":"1.2 Set up basic tooling support","text":"<ul> <li>Create standard dotnet tooling support with `dotnet new tool-manifest`.</li> <li>Install the Fantomas tool for F# formatting. <pre><code>dotnet tool install fantomas\n</code></pre></li> <li>We also recommend creating an <code>.editorconfig</code> file which configures Fantomas as required for optimal F# formatting.</li> <li>You should also create a basic <code>global.json</code> file to pin the repository to a specific version of .NET. <pre><code>dotnet new global.json\n</code></pre></li> </ul>"},{"location":"safe-from-scratch/#2-creating-client-server","title":"2. Creating client &amp; server","text":"<p>Now that we have basic core tools installed, we can go about creating a basic F# server and client and get them communicating with one another.</p>"},{"location":"safe-from-scratch/#21-create-a-basic-server-application","title":"2.1 Create a basic server application","text":"<ul> <li>Create a folder e.g. <code>server</code>.</li> <li>Create a plain F# console application <pre><code>dotnet new console -lang F#\n</code></pre></li> <li>Reference the Giraffe NuGet package (if you wish to use Paket, feel free to install that tool at this point).</li> <li>Create a basic Giraffe application to e.g. simply return the text \"Hello world!\" for every request.</li> <li>Run the application and confirm that it returns the expected text. <pre><code>dotnet run\n</code></pre></li> </ul>"},{"location":"safe-from-scratch/#22-create-a-basic-client-application","title":"2.2 Create a basic client application","text":"<ul> <li>Create a folder e.g. <code>client</code>.</li> <li>Create another plain F# console application in it.</li> <li>Add the Fable dotnet tool. <pre><code>dotnet tool install fable\n</code></pre></li> <li>To prove that Fable is installed, you should now be able to transpile the stock \"Hello from F#\" console app into JavaScript. <pre><code>dotnet fable\n</code></pre></li> </ul>"},{"location":"safe-from-scratch/#23-create-a-basic-web-application","title":"2.3 Create a basic web application","text":"<p>Now that we have a running HTTP server and the ability to create JS from F#, we can now install the required browser libraries and tools required to host a full app in the browser.</p> <ul> <li>Create an <code>index.html</code> file that will be used as the launch point for the web application; it will also load the JS that is generated by Fable.</li> <li>Install Vite with npm (install NPM and Node if you haven't already!). <pre><code>npm install vite\n</code></pre> <p>Vite is a multi-purpose tool used to aid development and packaging of JavaScript applications.</p> </li> <li> <p>You can now launch the application. <pre><code>dotnet fable watch -o output -s --run npx vite\n</code></pre>     This command tells Fable to compile all F# into the <code>output</code> folder and then launches Vite, which acts as a local development web server.</p> </li> <li> <p>You should see output in your terminal similar to this:</p> </li> </ul> <p></p> <ul> <li>Browse to the Local URI displayed e.g. <code>http://localhost:5173</code> in your browser and view the console output using the dev console (normally <code>F12</code>). You should see the console output from your client's <code>Program.fs</code> e.g.</li> </ul> <p></p>"},{"location":"safe-from-scratch/#24-set-up-basic-client-server-communication","title":"2.4 Set up basic Client / Server communication","text":"<p>Now that we have running client and server F# applications, let's have them communicate with each other over HTTP. We'll use a basic library for this called SimpleHttp.</p> <ul> <li>Start by adding a configuration file for Vite, <code>vite.config.mts</code> which will tell it to redirect traffic destined for the server (which we assume always starts with <code>/api/</code>) to port 5000 (which is the port the server runs on). <p>See here for more information about this redirection process.</p> </li> <li>Add a simple button to the HTML which we will be using handle the \"on click\" event to communicate with the server.</li> <li>Add the Fable.SimpleHttp package to the Client project.</li> <li>Change your Client <code>Program.fs</code> to handle the on-click event of the button so that when it is clicked, it makes a request to e.g. <code>/api/data</code> and puts the response in the console and a browser alert.</li> <li>Start both client and server applications.</li> <li>Confirm that when you click the button in the browser, you get the response \"Hello world\" (sent from the server). </li> </ul> <p>Congratulations! At this stage, you have a working F# client / server application that can communicate over HTTP.</p>"},{"location":"safe-from-scratch/#3-adding-react","title":"3. Adding React","text":"<p>We now spend the next few steps getting React working within the app and with F# support.</p>"},{"location":"safe-from-scratch/#31-add-basic-react-support","title":"3.1 Add basic React support","text":"<p>Now that we have a (very) basic F# client/server app, we'll now add support for React - a front-end framework that will enable us to create responsive and rich UIs.</p> <ul> <li>Add the react and react-dom packages to your NPM dependencies.</li> <li>Add the @vitejs/plugin-react and remotedev packages to your NPM dev dependencies.</li> <li>Add react to the list of plugins in your vite config.</li> </ul>"},{"location":"safe-from-scratch/#32-add-f-react-support","title":"3.2 Add F# React support","text":"<p>Now that we have React added to our application, we can add the appropriate F# libraries such as Feliz to start to use React in a typesafe, F#-friendly manner.</p> <ul> <li>Add the Feliz NuGet package to the Client project.</li> <li>Remove the <code>&lt;button&gt;</code> element from the <code>index.html</code> - we'll be creating it dynamically with React from now on.</li> <li>Add an empty <code>&lt;div&gt;</code> with an named <code>id</code> to the body of the <code>index.html</code>. This will be the \"root\" element that React will attach to from which to make HTML elements.</li> <li>Using the Feliz React wrapper types, replace the contents of your <code>Program.fs</code> in the Client project so that it creates a React button that can behave as the original static HTML button.</li> </ul>"},{"location":"safe-from-scratch/#33-add-jsx-support-optional","title":"3.3 Add JSX support (optional)","text":"<p>This next step adds Feliz's JSX support, which allows you to embed standard React JSX code directly in your F# applications.</p> <ul> <li>Add the Fable.Core and Feliz.Jsx.React NuGet packages to the Client project.</li> <li>Instead of using the Feliz F# dialect for React components (such as the <code>button []</code> element), use standard JSX code with string interpolation.</li> <li>Reference <code>Program.jsx</code> instead of <code>Program.js</code> in your <code>index.html</code> file.</li> <li>Run the client application using the extra flag that instructs Fable to emit <code>.jsx</code> instead of <code>.js</code> files:</li> </ul> <pre><code>dotnet fable watch -o output -s -e .jsx --run npx vite\n</code></pre>"},{"location":"safe-from-scratch/#4-taking-advantage-of-f","title":"4. Taking advantage of F#","text":"<p>This next section takes advantage of F#'s typing for both client and server.</p>"},{"location":"safe-from-scratch/#41-add-type-safe-client-server-communication","title":"4.1 Add type-safe Client / Server communication","text":"<ul> <li>On the Server:<ul> <li>Add the Fable.Remoting.Giraffe package.</li> <li>Create a new folder, <code>shared</code>, and a <code>Contracts.fs</code> file  inside it.</li> <li>Reference this file from both Client and Server projects.</li> <li>Inside this file create an API type and a Route builder to be used by Fable Remoting (so that client and server can route traffic).</li> <li>On the Server, create an implementation of the Api you just defined, convert it to an Http Handler and replace the <code>text  \"Hello world\"</code> call with it.</li> </ul> </li> <li>On the Client:<ul> <li>Add the Fable.Remoting.Client package.</li> <li>Instead of using SimpleHttp to make client / server calls, create a Fable Remoting API proxy and use that.</li> </ul> </li> </ul>"},{"location":"safe-from-scratch/#42-add-elmish-support","title":"4.2 Add Elmish support","text":"<p>Elmish is an F# library modelled closely on the Elm language model for writing browser-based applications, which has popularised the \"model-view-update\" paradigm.</p> <ul> <li>Add the Fable.Elmish.Debugger, Fable.Elmish.HMR and Fable.Elmish.React packages.</li> <li>Create a set of standard model, view and update types functions.</li> <li>Update your basic application root to use Elmish instead of a \"raw\" ReactDOM root.</li> <li>Ensure you add the required polyfill for remotedev in <code>index.html</code>.</li> </ul>"},{"location":"safe-from-scratch/#5-more-ui-capabilities","title":"5. More UI capabilities","text":"<p>This last section adds more UX capabilities.</p>"},{"location":"safe-from-scratch/#51-add-tailwind-support","title":"5.1 Add Tailwind support","text":"<p>Follow the Tailwind guide to add Tailwind to your project.</p>"},{"location":"safe-from-scratch/#52-revert-to-standard-f-feliz-optional","title":"5.2 Revert to \"standard\" F# Feliz (optional)","text":"<p>If you do not want to use the JSX support:</p> <ul> <li>Remove references to Feliz.JSX</li> <li>Do not use <code>JSX.jsx</code> to create components but rather standard <code>[ReactComponent]</code>.</li> <li>Use the standard Feliz types for creating standard React elements such as <code>div</code> and <code>button</code> etc.</li> </ul>"},{"location":"support/","title":"Support","text":"<p>The following companies provide commercial training, support, consultancy and development services for SAFE Stack applications.</p>"},{"location":"support/#compositional-it","title":"Compositional IT","text":"<p>Compositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions.</p>"},{"location":"support/#lambda-factory","title":"Lambda Factory","text":"<p>Lambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow.</p>"},{"location":"support/#fuzzy-cloud","title":"Fuzzy Cloud","text":"<p>Fuzzy Cloud is a fast-growing team of highly skilled and passionate IT professionals who can deliver services that help you speed up innovation and maximize efficiency. Our services are dynamic, scalable, resilient and responsive enabling rapid growth and high value for our clients. We take a highly collaborative approach to align our services with your business goals. We provide consulting in area like Cloud, Cross Platform mobile development, Machine Learning etc using Languages like F#, Python, Dart and few others.</p>"},{"location":"support/#the-f-community","title":"The F# Community","text":"<p>The SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out.</p>"},{"location":"support/#social","title":"Social","text":"<p>You can also reach out to the SAFE team on @safe_stack or on the regular F# channels on Slack: either the official F# Foundation Slack (an F# Foundation membership is required) or on the Functional Programming Slack. We'll be expanding this over time.</p>"},{"location":"template-overview/","title":"Overview","text":"<p>The SAFE Template is a dotnet CLI template for SAFE Stack projects, designed to get you up and running as quickly as possible, with flexible options to suit your application. The template gets you up and running with the most common elements of the stack with minimal configuration options.</p> <p>All template options come with a fully working end-to-end SAFE application with known-good dependencies on client (NPM) and server (NuGet), as well as a preconfigured Vite configuration file.</p>"},{"location":"template-overview/#using-the-template","title":"Using the template","text":"<p>Refer to the Quickstart guide to see basic guidance on how to install and use the template.</p>"},{"location":"template-overview/#template-options","title":"Template options","text":"<p>The template provides two simple modes: the standard and minimal template.</p>"},{"location":"template-overview/#standard-template","title":"Standard Template","text":"<p>The standard template creates an opinionated SAFE Stack app that contains everything you'll need to start developing, testing and deploying applications into Azure.</p> <pre><code>dotnet new SAFE\n</code></pre> <p>Use this configuration if..</p> <ul> <li>.. you are brand new to SAFE Stack, or F#, or software development in general, and want a \"recommended\" experience</li> <li>.. you want to get up and running as quickly as possible</li> <li>.. you are an F# developer and want an experience that uses tools that you are familiar with</li> </ul>"},{"location":"template-overview/#minimal-template","title":"Minimal Template","text":"<p>The minimal template is a \"bare-bones\" SAFE Stack app with minimal value-add features.</p> <pre><code>dotnet new SAFE -m\n</code></pre> <p>Use this configuration if..</p> <ul> <li>.. you are a SAFE Stack expert and want to hand-craft your own SAFE Stack application from a minimal starting point</li> <li>.. you are coming from a web development background and know your way around tools like NPM and Vite</li> <li>.. you are comfortable creating your own build and packaging pipeline</li> <li>.. you want to see \"behind the magic\" and get a feel for what is happening behind the scenes</li> </ul>"},{"location":"template-overview/#at-a-glance-comparison","title":"At-a-glance Comparison","text":"Feature Standard Minimal Styling Tailwind None Starter App Todo List None Communication Fable Remoting Raw HTTP .NET Package Manager Paket NuGet Build Tooling FAKE None Azure Integration Farmer None Testing Support Client and Server None Tooling VS Code Extensions, Fantomas None"},{"location":"template-safe-commands/","title":"Commands","text":"<p>The SAFE Stack now runs FAKE using a console app rather than a script.</p>"},{"location":"template-safe-commands/#run","title":"\"Run\"","text":"<pre><code>dotnet run\n</code></pre> <p>Used for development purposes, and provides a great live-reload experience. It pulls down any dependencies required for both the client and server, before running both the client and server in a \"watch\" mode, so any changes you make on either side will be automatically applied without you needing to restart the application.</p> <p>Navigating to <code>http://localhost:8080/</code> will load the application.</p>"},{"location":"template-safe-commands/#bundle-target","title":"\"Bundle\" target","text":"<pre><code>dotnet run Bundle\n</code></pre> <p>Used to both build and package up your application in a production fashion, ready for deployment. It will restore all dependencies and build both the client and server in a production and release mode respectively, and correctly copy the outputs into the <code>deploy</code> folder in the root of the application. Once your build has completed, you can launch the entire application locally to test it as follows:</p> <pre><code>cd deploy\nServer\n</code></pre> <p>Navigating to <code>http://localhost:5000/</code> will load the application.</p>"},{"location":"template-safe-commands/#azure-target","title":"\"Azure\" target","text":"<pre><code>dotnet run Azure\n</code></pre> <p>This target will deploy your application to Azure with a fully configured Application Insights instance. You do not need to pre-create any resources in Azure - the template will create everything needed, using free SKUs so you can test without any costs.</p> <p>You must already have an Azure account and will be prompted to log into it during the deployment process.</p> <p>This build step uses both the Azure CLI and Farmer projects to create all resources in just a few lines of code.</p> <p>The name of resources will be generated based on the folder in which you created the application. These may be incompatible with Azure naming rules, or may already be in use (Azure web applications must be globally unique) so you may have to modify the name of the webapp to pick one that is acceptable.</p>"},{"location":"template-safe-commands/#runtests-target","title":"\"RunTests\" target","text":"<pre><code>dotnet run RunTests\n</code></pre> <p>This target behaves similarly to the standard Run target, except that it launches the unit tests for both client and server.</p> <ul> <li>The server tests will run immediately in the console, using watch mode to allow you to rapidly iterate on your tests.</li> <li>The client tests run in the browser. Again, they use a watch mode so you can make changes to your client code and see the results in the browser.</li> </ul> <p>Launch the client tests on <code>http://localhost:8081/</code></p>"},{"location":"template-safe-commands/#format-target","title":"\"Format\" target","text":"<pre><code>dotnet run Format\n</code></pre> <p>This target will format all the F# files in the <code>src</code> folder using Fantomas. Out of the box, Fantomas tries to reformat the code according to the F# style guide by Microsoft. For more info, check out the documentation.</p>"},{"location":"testimonials/","title":"Testimonials","text":"<p>Please feel free to submit a PR to add testimonials to this page!</p>"},{"location":"testimonials/#msu-solutions-gmbh","title":"msu solutions GmbH","text":"<p>SAFE gives us a fast development cycle for our web and mobile platforms</p> <p>We at msu solutions GmbH are big fans of SAFE stack. For the last couple of years we were already using F# open source technologies for web and mobile projects. Tools like the Fable compiler and elmish are rock solid and a pleasure to work with.</p> <p>Since the release of SAFE, we see that all these important technologies are now bundled and tested under one big umbrella.  Especially the commercial support for SAFE is very important for us and our customers.</p>"},{"location":"testimonials/#goswin-rothenthal","title":"Goswin Rothenthal","text":"<p>It just works!</p> <p>The docs are very detailed and helpful. I got the template up and running on a public URL on Azure within one hour. Without any issues. Even though I am new to dotnet core and Azure.</p>"},{"location":"testimonials/#demetrix","title":"Demetrix","text":"<p>SAFE was the perfect place to start our biological design and data management platform</p> <p>Demetrix uses F# for DNA design and data management in our research pipeline.   Our data systems are built on top of SAFE and it was a great experience for both veteran F# developers and people new to the environment.  I would start with SAFE again in a heartbeat for a new project.  We shared some of our experiences at Open F# 2018.</p>"},{"location":"testimonials/#microdesk","title":"Microdesk","text":"<p>Spoil your customers with F# and the SAFE stack!</p> <p>Porting a production web app from TypeScript/React to use the SAFE stack turned out to be a huge win.  Sharing F# models on the front and back-end allows you to leverage the excellent F# compiler and type system when designing and refactoring your codebase.  Using a type provider (in our case, SQLProvider) extends this coverage to your database as well.  This means that changes to any part of your application will be picked up by the compiler which will essentially guide you to every relevant place in the source code that needs to be updated.  This is so effective that once you experience it, you will never want to be without it.  </p> <p>On the front end, the Elmish pattern, which may look intimidating at first glance, is actually quite fun and intuitive to write.  More importantly, it guides you into the \"pit of success\" by making you write highly testable \"pure functions\" that outline your UI state transitions (in your <code>update</code> function).  Putting all state transitions in one place becomes a breath of fresh air because it eliminates the spaghetti code that can happen in MVVM view models of even modest complexity.  Do you have a complex \"sort\" that needs to be handled in your <code>update</code>?  You can easily write a unit test in F# that passes in the relevant command input for that.  No mocking is required because it will be a pure function! If you still feel leery of the Elmish pattern, you are free to use React Hooks API or any other pattern you prefer.  There are also many excellent external libraries - i.e. Feliz - that allow you to optionally use the Elmish pattern on only certain pages, among other things.  </p> <p>Worried about getting stuck?  Don't worry because the F# community will practially crawl all over themselves to be the first to answer you question. There are also options for professional consultation as well.  The community support is amazing! The SAFE stack is designed to be as turn-key as possible, but there are also plenty of opportunities to customize the stack as you see fit.  </p> <p>Overall, the SAFE stack has allowed me to completely spoil a very demanding customer with timely, bug-free deliverables. </p>"},{"location":"testimonials/#jake-witcher","title":"Jake Witcher","text":"<p>I really appreciate the effort that went in to this!</p> <p>The F# SAFE stack documentation is incredibly well done. One of the best features is the learning resources page that includes GitHub repos of example projects.</p>"},{"location":"testimonials/#casper-bollen","title":"Casper Bollen","text":"<p>Never did Computer Science</p> <p>The SAFE stack enables me to create full backend to frontend web apps in a matter of weeks!!</p>"},{"location":"testimonials/#leko-thomas","title":"Leko Thomas","text":"<p>Recipes are concise solve only one problem and are composable</p> <p>I find SAFE stack recipes have so much value. Thank you! Please keep on doing it.</p>"},{"location":"testimonials/#james-randall","title":"James Randall","text":"<p>After a year I still feel like F# with the SAFE stack is like high octane rocket fuel for developers.</p> <p>The F# community have created, and made very accessible, a fantastic set of tools that allow you to write F# end to end on the web and in a way that embraces the existing world.</p>"},{"location":"components/component-azure/","title":"Azure in SAFE","text":""},{"location":"components/component-azure/#what-is-azure","title":"What is Azure?","text":"<p>Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.</p>"},{"location":"components/component-azure/#how-does-azure-integrate-with-safe","title":"How does Azure integrate with SAFE?","text":"<p>Azure provides a number of flexible services for SAFE applications, including (but not only):</p>"},{"location":"components/component-azure/#hosting-services","title":"Hosting Services","text":"<p>Azure comes with several ready-made hosting services, including App Service, which enables seamless hosting of web applications, including ASP.NET Core applications (which Saturn is built on top of). In addition, Azure supports a number of managed hosting services for Docker and Kubernetes, which work fantastically well with SAFE.</p>"},{"location":"components/component-azure/#platform-services","title":"Platform Services","text":"<p>Azure comes with a large number of ready-made platform services that can dramatically lower the cost of developing bespoke systems, including:</p> <ul> <li>Compute services such as Azure Functions, for hosting F# code that can dynamically scale based on load, as well as Service Fabric or Virtual Machines.</li> <li>Storage services such as Azure Storage and Data Lake, for storing virtually limitless volumes of data in unstructured or structure form.</li> <li>Database services, including managed SQL Server, MySQL and Postgres, as well as CosmosDB for document and graph stores, Redis and more.</li> <li>Messaging services including Queues, Service Bus and Event Hub.</li> <li>Analytical services such as Stream Analytics, Databricks, Machine Learning and Analysis Services.</li> <li>Security services such as Key Vault and Active Directory.</li> </ul> <p>Many of the above services have ready-made SDKs that can be run on .NET and therefore from F#.</p>"},{"location":"components/component-elmish/","title":"Elmish in SAFE","text":""},{"location":"components/component-elmish/#what-is-elmish","title":"What is Elmish?","text":"<p>Elmish is a library for building single page applications in F#, following the model-view-update architecture made famous by Elm.</p> <p>The following diagram is a simplified, high-level view of the MVU pattern. <code>Model</code> in this case refers to your application's state, with <code>Update</code> and <code>View</code> the two functions that handle the flow of messaging. If you wish to read more, we also recommend reading the excellent Elmish Book.</p> stateDiagram-v2     [*] --&gt; Update : Current model and Command     Update --&gt; View : Updated model     View --&gt; [*] : HTML rendered on page"},{"location":"components/component-elmish/#how-does-elmish-integrate-with-safe","title":"How does Elmish integrate with SAFE?","text":"<p>Elmish is the library used to build the front-end application in SAFE and that application is compiled to JavaScript by Fable to run in the browser. The SAFE Stack template comes pre-bundled with the Elmish React module, which (as the name suggests) uses the React library to handle the heavy lifting of modifyng the DOM in an efficient way. This allow us to use the pure functional style of the MVU pattern whilst still retaining the ability to have a highly performant user interface.</p> <p>Because Elmish works alongside React, it is possible to use the vast number of available React components from the JavaScript ecosystem within our Elmish applications.</p> <p>This conceptual diagram illustrates how the different pieces of Elmish, React and Fable fit together to make the front-end part of your SAFE application which runs in the browser.</p> flowchart RL subgraph Browser React(React - Handles DOM updates) Fable(Fable - Translates F# to JS) ER(Elmish React - Elmish to React bridge) Elmish(Elmish - Provides MVU abstractions) You(Your F# domain logic) You --- Elmish --- ER --- Fable --- React end"},{"location":"components/component-elmish/#learn-elmish","title":"Learn Elmish","text":"<ul> <li>The official Elmish docs</li> <li>The Elmish Book</li> </ul>"},{"location":"components/component-fable/","title":"Fable in SAFE","text":""},{"location":"components/component-fable/#what-is-fable","title":"What is Fable?","text":"<p>Fable is an F#-to-JavaScript (JS) compiler, designed to produce readable and standard JS code. Fable brings all the power of F# to the JS ecosystem, with support for most of the F# core library as well as the most commonly used .NET APIs.</p> <p>It also provides rich integration with the JS ecosystem which means that you can use JS libraries from F# (and vice versa) as well as make use of standard JS tools.</p>"},{"location":"components/component-fable/#how-does-fable-integrate-with-safe","title":"How does Fable integrate with SAFE?","text":"<p>Fable is a tool that generates JavaScript files from F# code. This allows us to write full front end applications using F#. Being able to write both the Server and Client in the same language offers huge benefits especially when you can share code between the two, without the need for duplication. More information on code sharing can be found here.</p>"},{"location":"components/component-fable/#fable-and-vite","title":"Fable and Vite","text":"<p>As Fable allows us to integrate into the JS Ecosystem, we can make use of tools such as Vite with features including Hot Module replacement and Source Maps.</p> <p>The SAFE Template already has Vite configured to get you up and running immediately.</p> <p>Learn more about Fable here.</p>"},{"location":"components/component-saturn/","title":"Saturn in SAFE","text":"<p>Saturn is a web development library written in F# which allows you to easily create both server-side MVC applications as well as web APIs. It runs on top of two other components:</p> <ul> <li>Giraffe, an F#-specific library for writing functional-first web applications.</li> <li>Microsoft's ASP.NET Core.</li> </ul> <p>Saturn, via Giraffe, provides very good integration with other ASP.NET Core components such as authentication.</p> <p>Many of Saturn's components and concepts will seem familiar to those of us with experience of other web frameworks such as Ruby on Rails, Python\u2019s Django or especially Elixir's Phoenix.</p>"},{"location":"components/component-saturn/#how-does-saturn-integrate-with-safe","title":"How does Saturn integrate with SAFE?","text":"<p>Saturn provides the ability to drive your SAFE applications from the server. It enables:</p> <ul> <li>Routing and hosting of your server-side APIs through a set of simple-to-use abstractions.</li> <li>Hosting of your client-side assets, such as HTML, CSS and any JavaScript files generated by Fable.</li> <li>Other cross cutting concerns e.g. authentication etc.</li> </ul> <p>It also integrates with SAFE to allow seamless sharing of types and functions, since Fable will convert most F# into JavaScript. In addition, you can seamless transport data between client and server using either the Fable.JSON or Fable.Remoting libraries, both of which have support for Saturn. You can read more about this here.</p> flowchart TB     outputs&gt;JSON, HTML etc.]     subgraph host[.NET Core Host]     saturn[Saturn - Routers, Controllers etc.]     giraffe[Giraffe - Core F# abstractions]     aspnet[ASP.NET Core - HTTP Context etc.]     kestrel[Kestrel - Web Server]     saturn --- giraffe --- aspnet --- kestrel     end     data[(Transactional Data e.g. SQL)]     content&gt;Static Content e.g. HTML, CSS, JavaScript]     outputs -- serves --- host     kestrel -- reads --- data     kestrel -- reads --- content <p>Learn more about Saturn here.</p>"},{"location":"faq/faq-build/","title":"Moving from dev to prod","text":"<p>This page explains the key differences that you should be aware of between running SAFE applications in development and production.</p>"},{"location":"faq/faq-build/#developing-safe-applications","title":"Developing SAFE applications","text":"<p>The SAFE template is geared towards a streamlined development process. It builds and runs both the client and server on your machine.</p> <p>During development, in parallel to your .NET web server, Vite dev Server is used to enable hot module replacement. This means that you can continually make changes to your client application code and can rapidly see the results reflected in your browser, without the need to fully reload the application.</p> <p>The build of the .NET server also makes use of dotnet watch to have the server automatically restart with the latest changes. Since your backend applications will typically be stateless, this permits a rapid development workflow.</p> <p>It's important to note that the Vite dev server is configured to automatically route traffic intended for api/* routes to the backend web server. This simulates how a SAFE application might work in a production environment, with both client and server assets served from a single web server. This also allows you to not worry about ports and hosts for your backend server in your client code, or CORS issues.</p> flowchart LR subgraph c[localhost:8080] js&gt;Fable-compiled JS] vite(Vite dev server) js -- hot module replacement --- vite end subgraph s[localhost:5000] dotnet(dotnet watch run) saturn(Saturn on Kestrel) saturn --- dotnet end c -- /api redirect --&gt; s"},{"location":"faq/faq-build/#running-safe-applications-in-production","title":"Running SAFE applications in production","text":"<p>In a production environment, you won't need the Vite dev server. Instead, Vite is used as a one-off compiler step to create your bundled JavaScript from your Fable app (plus dependencies), and then deploy this along with your backend web server which also hosts that content directly. For example, you can use Saturn to host the static content required by the application e.g. HTML, JS and CSS files etc. as well as your backend APIs. This fits very well with standard CI / CD processes, as a build step in your Build.fs or Azure DevOps / AppVeyor / Travis step etc.</p> flowchart BT subgraph dest[Web server e.g. https://contoso.com] saturn(Saturn myapp.dll) db[(transactional data)] assets&gt;static assets] saturn -- api/customers --- db saturn -- bundle.js --- assets end  subgraph src[CI/CD Server] exec&gt;deployment script] vite(Vite) dotnet(dotnet publish) source(F# source code) exec -- bundle.js --- vite exec -- myapp.dll --- dotnet vite --- source dotnet --- source end  src -- file copy --&gt; dest"},{"location":"faq/faq-build/#client-asset-hosting-alternatives","title":"Client asset hosting alternatives","text":"<p>Rather than hosting your client-side content and application inside your web server, you can opt to host your static content from some other service that supports hosting of HTTP content, such as Azure Blobs, or a content hosting service. In such a case, you'll need to consider how to route traffic to your back-end API from your client application (as they are hosted on different domains), as well as handle any potential CORS issues.</p>"},{"location":"faq/faq-troubleshooting/","title":"Troubleshooting","text":""},{"location":"faq/faq-troubleshooting/#run-error-due-to-nodenpm-version","title":"Run error due to node/npm version","text":"<p>You may receive an error when trying to run the app, e.g. the current version might require <code>{\"node\":\"~18 || ~20\",\"npm\":\"~9 || ~10\"}</code> but your locally installed versions are different. Ideally we'd like to install different versions side-by-side, which we can do using Node Version Manager.</p> <p>Once NVM is installed, identify the version of Node that you'd like to install by checking this matrix. For our example here we can identify version <code>20.10.0</code> as satifying both the Node and npm version requirements. To install this version for the current project run:</p> <pre><code>nvm install 20.10.0\nnvm use 20.10.0\n</code></pre> <p>The output from these commands will also tell you which version of npm is linked to the Node version, but if you do not currently have that version of npm installed you need to install it manually with the command:</p> <pre><code>npm install -g npm@10.2.4\n</code></pre> <p>The version numbers may vary depending on the SAFE Stack version you are using.</p> <p>You should now be able to run the app successfully.</p>"},{"location":"faq/faq-troubleshooting/#socketprotocolerror-in-debug-console","title":"SocketProtocolError in Debug Console","text":"<p>You may see the following <code>SocketProtocolError</code> message in the Debug Console once you have started your SAFE application.</p> <p><code>WebSocket connection to 'ws://localhost:8000/socketcluster/' failed: Error during WebSocket handshake: Unexpected response code: 404</code></p> <p></p> <p>Whilst these messages can be safely ignored, you can eliminate them by installing Redux Dev Tools in the launched Chrome instance as described in the debugging prerequisites section.</p>"},{"location":"faq/faq-troubleshooting/#node-process-does-not-stop-after-stopping-the-vs-code-debugger","title":"Node Process does not stop after stopping the VS Code debugger","text":"<p>VS Code does not kill the Fable process when you stop the debugger, leaving it running as a \"zombie\". In such a case, you will have to explicitly kill the process otherwise it will hold onto port 8080 and prevent you starting new instances. This should be easily doable by sending Ctrl+C in the Terminal window in VS Code for <code>Watch Client</code> task. Tracked here.</p> <p></p>"},{"location":"faq/faq-troubleshooting/#chrome-opens-to-a-blank-window-when-debugging-in-vs-code","title":"Chrome opens to a blank window when debugging in VS Code","text":"<ul> <li>Occasionally, VS Code will open Chrome before the Client has started. In this case, you will be presented with a blank screen until the client starts.</li> <li>Depending on the order in which compilation occurs, VS Code may launch the web browser before the server has started. If this occurs, you may need to refresh the browser once the server is fully initialised.</li> </ul>"},{"location":"faq/faq-troubleshooting/#javascript-bundle-size","title":"JavaScript bundle size","text":"<p>A project created from SAFE template might issue the following warning from Webpack upon building the JavaScript bundle:</p> <pre><code>WARNING in entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance.\n</code></pre> <p>We're striving to optimise the bundle size, however with a number of different options and dependencies it's not that easy to stay below the Webpack recommended limit.</p> <p>To minimize the bundle size in your project you can try restricting browser compatibility by modifying the Babel Preset targets for Browserslist and thus using less polyfills.</p> <p>For more info, see this issue.</p>"},{"location":"faq/faq-troubleshooting/#server-port-change","title":"Server port change","text":"<p>The port that the server runs on changed from 8085 to 5000 (the ASP.NET Core default) in v4 of the SAFE Template. This was to make it compatible with deployment to Azure App Service on Linux.</p>"},{"location":"faq/faq-troubleshooting/#cannot-connect-to-the-client-app-when-running-in-a-vs-code-dev-container","title":"Cannot connect to the Client app when running in a VS Code Dev Container","text":"<p>There is an open issue for VS Code not forwarding ports for services using IPv6 inside a Dev Container. Node uses IPv6 if it's available, so out of the box we cannot connect to the client.</p> <p>Until Microsoft resolve that issue there are 2 ways to work around it:</p> <ol> <li>Disable IPv6 in the Dev Container by adding a runArgs setting in <code>.devcontainer/devcontainer.json</code>:</li> </ol> <pre><code>    \"image\": \"mcr.microsoft.com/devcontainers/dotnet:1-8.0-bookworm\",\n+   \"runArgs\": [ \"--sysctl\", \"net.ipv6.conf.all.disable_ipv6=1\"],\n</code></pre> <ol> <li>Alternatively, force the Client app to use IPv4 only by specifying hostname in the Vite config <code>src/Client/vite.config.mts</code>:</li> </ol> <pre><code>    server: {\n        port: 8080,\n+       host: \"127.0.0.1\",\n</code></pre>"},{"location":"features/feature-azurefunctions/","title":"Working with Azure functions","text":""},{"location":"features/feature-azurefunctions/#going-serverless-with-safe","title":"Going serverless with SAFE","text":"<p>With SAFE-Stack you can easily take advantage of serverless computing via Azure Functions.</p> <p>With Functions-As-A-Service (FAAS) you can focus on building your business logic and don't need to worry about provisioning and maintaining servers (hence \"serverless\"). Azure Functions provide a managed compute platform with high reliability. If you use a \"consumption plan\" it scales on demand and you only get billed for the actual runtime of your code.</p>"},{"location":"features/feature-azurefunctions/#potential-use-cases","title":"Potential use cases","text":"<p>For SAFE apps we see various use cases for FAAS:</p> <ul> <li>Running recurring jobs to create statistics or maintenance actions via timer triggers</li> <li>Running jobs that can be processed async like creating accountings or sending email </li> <li>Command processing in CQRS apps via message queues or HTTP triggers</li> </ul>"},{"location":"features/feature-azurefunctions/#editing-functions-in-the-azure-portal","title":"Editing Functions in the Azure Portal","text":"<p>The Azure Portal allows you to create and edit Functions and their source code via an online editor. </p> <p>For a short test go to the portal, click the \"New\" button and search for \"Function App\". Click through the wizard to create a new Function App. Open the app when it's created and add a new function. Pick \"Timer\" as scenario and F# as language.</p> <p>Replace the contents of function.json with:</p> <pre><code>{\n\"bindings\": [\n    {\n    \"name\": \"myTimer\",\n    \"type\": \"timerTrigger\",\n    \"direction\": \"in\",\n    \"schedule\": \"0 * * * * *\"\n    }\n],\n\"disabled\": false\n}\n</code></pre> <p>and replace the run.fsx with the following F# code:</p> <pre><code>open System\n\nlet minutesSince (d: DateTime) =\n(DateTime.Now - d).TotalMinutes\n\nlet run(myTimer: TimerInfo, log: TraceWriter) =\nlet meetupStart = new DateTime(2017, 11, 8, 19, 0, 0)\n\nminutesSince meetupStart\n|&gt; int\n|&gt; sprintf \"Our meetup has been running for %d minutes\"\n|&gt; log.Info\n</code></pre> <p>Now observe the logs to see that the function runs every minute and outputs the message about the meetup duration.</p> <p>While it seems very convenient, the online editor should only be used for testing and prototyping. In SAFE-Stack you usually benefit from reusing your domain model at various places see Client/Server - so we recommend to use \"precompiled Azure Functions\" as described below.</p>"},{"location":"features/feature-azurefunctions/#deployment","title":"Deployment","text":"<p>In SAFE-Stack scenarios we recommend all deployments should be automated. Here, we discuss two options for deploying your functions apps into Azure.</p>"},{"location":"features/feature-azurefunctions/#azure-functions-core-tools","title":"Azure Functions Core Tools","text":"<p>In the case of Function Apps the excellent Azure Functions Core Tools can be used. If you use core tools version 2 then the following should be added to your build/deploy script:</p> <pre><code>dotnet publish -c Release\nfunc azure functionapp publish [FunctionApp Name]\n</code></pre> <p>This will compile your Function App in release mode and push it to the Azure portal.</p> <p>In the case of a CI server etc., you will need to install the Functions Core Tools on the server and once per functions app log into the CI machine and explicitly authenticate it manually (see the Functions Core Tools docs).</p>"},{"location":"features/feature-azurefunctions/#https-upload","title":"HTTPS Upload","text":"<p>Since Azure Functions sits on top of Azure App Service, the same mechanisms for deployment there also exist here. In this case, you can use the exact same HTTPS upload capabilities of the App Service to upload a zip of your functions app into your Functions app. The standard SAFE Template can generate this for you for the core SAFE application as part of the FAKE script; the exact same mechanism can be utilised for your functions app.</p> <p>As per the standard App Service, HTTPS upload uses a user/pass supplied in the header of the zip which is PUT into the functions app. This user / pass can be taken from the App Service in the Azure Portal directly, or extracted during deployment of your ARM template (as per the FAKE script does for the App Service).</p>"},{"location":"features/feature-clientserver-basics/","title":"Sharing Types and Code","text":""},{"location":"features/feature-clientserver-basics/#sharing-types","title":"Sharing Types","text":"<p>Sharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into JavaScript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a project in your repository called e.g <code>Shared.fsproj</code>. This project will contain any assets that should be shared across the client and server e.g. types and functions.</p> <p>Then, create files with your types in the project as needed e.g</p> <pre><code>type Customer = { Id : int; Name : string }\n</code></pre> <p>Reference this project from your server project. You can now reference those types on the server.</p> <pre><code>&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;\n    ...\n    &lt;ItemGroup&gt;\n        &lt;ProjectReference Include=\"..\\Shared\\Shared.fsproj\" /&gt;\n    &lt;/ItemGroup&gt;\n    ...\n&lt;/Project&gt;\n</code></pre> <p>Finally, reference this project in your client project (as above). You can now reference those types on the client; Fable will automatically convert your F# types into JavaScript in the background.</p>"},{"location":"features/feature-clientserver-basics/#sharing-behaviour","title":"Sharing Behaviour","text":"<p>You can also share behaviour using the same mechanism at that for sharing types. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server.</p> <p>Fable will translate your functions into native JavaScript, and will even translate many calls to the .NET base class library into corresponding JavaScript! This allows you to compile your domain model and domain logic to many many different targets including:</p> <ul> <li>ASP.NET Core (via Saturn)</li> <li>Azure Functions</li> <li>JavaScript that runs in the browser</li> <li>JavaScript that runs on mobile devices with React Native.</li> <li>Raspberry Pi (via .NET Core)</li> </ul> <p>You can read more about this on the Fable website.</p>"},{"location":"features/feature-clientserver-basics/#conditional-sharing","title":"Conditional sharing","text":"<p>When sharing assets between client and server, you may wish to have different implementations for the \"client\" and \"server\" sides. For example, if the client-side version of a function should call an NPM package but the server-side version should use a NuGet package. This is a more advanced scenario where you may require different implementations for the JS and .NET version of code. In such situations, you can use <code>#IF</code> directives to conditionally compile code for either platform - see the Fable website for more information.</p>"},{"location":"features/feature-clientserver-bridge/","title":"Stateful Messaging through Bridge","text":"<p>Using F# on both client and server is at the core of the SAFE stack, as it simplifies the way we think about building web applications by using the same language, idioms and in many cases sharing our code and domain models.</p> <p>However, building a client and a server app requires a fundamentally different way of thinking. On the server side we build stateless APIs in Saturn that map HTTP requests to internal functionality, whereas on the frontend we use the Elmish model, implementing the model-view-update pattern: a stateful pattern that lets us think about the application state as it evolves while the application is running.</p> <p>Even though we use the same language across platforms, applying these two different programming models forces us to switch our way of thinking back and forth when writing code for the client and for the server. This is where the Elmish.Bridge library comes into play: it brings the Elmish programming model to the server and unifies the way we write the application as a whole.</p>"},{"location":"features/feature-clientserver-bridge/#how-does-elmish-work-on-the-server","title":"How does Elmish work on the server?","text":"<p>Think of Elmish on the server as the model-view-update pattern but without the view part. Instead, you only need to implement <code>init</code> and <code>update</code> functions to manage the server state as it evolves while the server is running.</p> <ul> <li>Server state can contain data that is relevant to a single or all clients</li> <li>The dispatch loop running on the server is connected to the dispatch loop on the client via a persistent stateful websocket connection</li> <li>The <code>update</code> functions on client and server can exchange data via message passing.</li> </ul>"},{"location":"features/feature-clientserver-bridge/#a-simple-example","title":"A simple example","text":"<p>Let's see a simple example of how this might work in practice:</p> <pre><code>// Client-side\nlet update msg state =\n    match msg with\n    | LoadUsers -&gt;\n        // send the message to the server\n        state, Cmd.bridgeSend ServerMsg.LoadUsers\n    | UsersLoaded users -&gt;\n        // receive message from the server\n        let nextState = { state with Users = users }\n        nextState, Cmd.none\n\n// Server-side\nlet update clientDispatch msg state =\n    match msg with\n    | ServerMsg.LoadUsers -&gt;\n        let loadUsersCmd =\n            Cmd.ofAsync\n                getUsersFromDb    // unit -&gt; Async&lt;User list&gt;\n                ()                // input arg = unit\n                UsersLoadedFromDb // User list -&gt; ServerMsg\n                DoNothing         // ServerMsg\n        state, loadUsersCmd\n\n    | ServerMsg.UsersLoadedFromDbSuccess users -&gt;\n        // answer the current connected client with data\n        clientDispatch (ClientMsg.UsersLoaded users)\n        state, Cmd.none\n\n    | ServerMsg.DoNothing -&gt;\n        state, Cmd.none\n</code></pre> <p>The above example mimics what would have been a <code>GET</code> request to the server to get user data from database. However, now the client sends a fire-and-forget message to the server to load users, and at some point the server messages the current client back with the results. Notice that the server could have decided to do other things than just messaging the client back: for example, it could have broadcasted the same message to other clients updating their local state of the users.</p>"},{"location":"features/feature-clientserver-bridge/#when-to-use-elmishbridge","title":"When to use Elmish.Bridge","text":"<p>There are many scenarios where it makes sense to use Elmish.Bridge:</p> <ul> <li>Chat-like applications with many connected users through many channels</li> <li>Syncing price data in real-time while viewing ticket prices</li> <li>Multiplayer games that need real-time update of game states</li> <li>Other applications of web sockets through an Elmish model</li> </ul>"},{"location":"features/feature-clientserver-bridge/#things-to-consider","title":"Things to consider","text":"<p>The biggest distinction between using this and \"raw\" Saturn is that your web server becomes a stateful service. This introduces several differences for application design.</p> <ol> <li> <p>The server state has a lifespan equal to the that of the process under which the server instance is running. This means if the server application restarts then the server state will be reset.</p> </li> <li> <p>The server state is local to the server instance. This means that if you run multiple web servers, they won't be sharing the same server state by default.</p> </li> </ol> <p>As of now there is no built-in persistence for the state, but you can implement this yourself using any number of persistance layers such as Redis Cache, Azure Tables or Blobs etc.</p> <p>In addition Elmish.Bridge does not use standard HTTP verbs for communication, but rather websockets. Therefore, it is not a suitable technology for an open web server that can serve requests from other sources than Elmish.Bridge clients.</p>"},{"location":"features/feature-clientserver-bridge/#learn-more-about-elmishbridge","title":"Learn more about Elmish.Bridge","text":"<p>Head over to Elmish.Bridge to learn more.</p>"},{"location":"features/feature-clientserver-http/","title":"Client Server communication over HTTP","text":"<p>Communicating over raw HTTP using Saturn has three main steps.</p>"},{"location":"features/feature-clientserver-http/#1-load-your-data","title":"1. Load your data","text":"<p>Start by creating a function on your server that returns some data:</p> <p><pre><code>let loadCustomersFromDb() =\n    [ { Id = 1; Name = \"Joe Bloggs\" } ]\n</code></pre> Next, create a method which returns the data as JSON within Giraffe's HTTP context.</p> <pre><code>/// Returns the results of loadCustomersFromDb as JSON.\nlet getCustomers next ctx =\n    json (loadCustomersFromDb()) next ctx\n</code></pre> <p>You can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints.</p> <p>Also note the <code>next</code> and <code>ctx</code> arguments. These are used by Giraffe as part of its HTTP pipeline and are required by the <code>json</code> function (Note you can also use <code>Successful.Ok</code> instead of <code>json</code>, which will offer XML serialization as well).</p>"},{"location":"features/feature-clientserver-http/#2-expose-data-through-saturn","title":"2. Expose data through Saturn","text":"<p>Now expose the api method using Saturn's <code>router</code> construct and add it to your overall application scope: <pre><code>let myApis = router {\n    get \"/api/customers/\" getCustomers\n}\n</code></pre></p> <p>For simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the <code>next</code> and <code>ctx</code> arguments): <pre><code>let myApis = router {\n    get \"/api/customers/\" (json (loadCustomersFromDb()))\n}\n</code></pre></p>"},{"location":"features/feature-clientserver-http/#3-consume-the-endpoint-from-the-client","title":"3. Consume the endpoint from the client","text":"<p>Finally, call the endpoint from your client application. <pre><code>promise {    \n    let! customers = Fetch.fetchAs&lt;Customer list&gt; \"api/customers\" (Decode.Auto.generateDecoder()) []\n    // do more with customers here...\n}\n</code></pre></p> <p>Note the use of the <code>promise { }</code> computation expression. This behaves similarly to <code>async { }</code> blocks that you might already know, whilst the <code>fetchAs</code> function retrieves data from the HTTP endpoint specified. The JSON is deserialized as a <code>Customer</code> array using an automatically-generated \"decoder\" (see the section on serialization for more information).</p>"},{"location":"features/feature-clientserver-remoting/","title":"Data sharing with Fable.Remoting","text":"<p>Alongside raw HTTP, you can also use Fable.Remoting, which provides an RPC-style mechanism for calling server endpoints. With Remoting, you don't need to worry about the details of serialization or of how to consume the endpoint - instead, remoting lets you define you client-server interactions as a shared type that is commonly referred to as a protocol or contract.</p>"},{"location":"features/feature-clientserver-remoting/#1-define-a-protocol","title":"1. Define a protocol","text":"<p>Each field of the record is either of type <code>Async&lt;T&gt;</code> or a function that returns <code>Async&lt;T&gt;</code>, for example: <pre><code>type ICustomerApi = {\n    getCustomers : unit -&gt; Async&lt;Customer list&gt;\n    findCustomerByName : string -&gt; Async&lt;Customer option&gt;\n}\n</code></pre> The supported types used within the protocol can be any F# type: primitive values (int, string, DateTime, etc.), records, options, discriminated unions or collections etc.</p>"},{"location":"features/feature-clientserver-remoting/#2-implement-the-protocol-on-the-server","title":"2. Implement the protocol on the server","text":"<p>On the server you would implement the protocol as follows: <pre><code>let getCustomers() =\n    async {\n        return [\n            { Id = 1; Name = \"John Doe\" }\n            { Id = 2; Name = \"Jane Smith\" } ]\n    }\n\nlet findCustomerByName (name: string) = \n    async {\n        let! allCustomers = getCustomers()\n        return allCustomers |&gt; List.tryFind (fun c -&gt; c.Name = name)\n    }\n\n\nlet customerApi : ICustomerApi = {\n    getCustomers = getCustomers\n    findCustomerByName = findCustomerByName\n}\n</code></pre></p>"},{"location":"features/feature-clientserver-remoting/#3-consume-the-protocol-on-the-client","title":"3. Consume the protocol on the client","text":"<p>After exposing an HttpHandler from <code>customerApi</code> you can start calling the API from the client. </p> <pre><code>let api = Remoting.createApi() |&gt; Remoting.buildProxy&lt;ICustomerApi&gt;\n\nasync {\n    let! customers = api.getCustomers()\n    for customer in customers do\n        printfn \"#%d =&gt; %s\" customer.Id customer.Name\n}\n</code></pre> <p>Notice here, there is no need to configure routes or JSON serialization, worry about HTTP verbs, or even involve yourself with the Giraffe pipeline. If you open your browser network tab, you can easily inspect what remoting is doing behind the scenes. </p>"},{"location":"features/feature-clientserver-serialization/","title":"Serialization in SAFE","text":""},{"location":"features/feature-clientserver-serialization/#serialization-basics-with-thoth","title":"Serialization basics with Thoth","text":"<p>If you are using the standard SAFE Template (V3 +), you do not need to worry about serialization, as this is taken care of for you by Fable Remoting. However, if you are \"rolling your own\" communication channel or want to create an \"open\" API for multiple consumers, this article may be relevant for you.</p> <p>When using basic HTTP communication between the client and server, you'll need to consider how to deserialize data from JSON to F# types.</p> <p>In order to guarantee that the serialization / deserialization routines between client and server are compatible, you should replace the JSON converter in Giraffe / Saturn with the Thoth library's serializer. This is the same library as that used in Fable for deserialization, and so will work seamlessly together.</p> <pre><code>let configureSerialization (services:IServiceCollection) =\n    services.AddSingleton&lt;Giraffe.Serialization.Json.IJsonSerializer&gt;(Thoth.Json.Giraffe.ThothSerializer())\n</code></pre>"},{"location":"features/feature-clientserver-serialization/#approaches-to-deserialization","title":"Approaches to deserialization","text":"<p>The Thoth library makes use of decoders to convert JSON into F# values. There are generally two main approaches to take when doing this: automatic and manual decoders.</p> <p>Assume the following Customer record for the remaining examples.</p> <pre><code>type Customer =\n    { Id : int\n      Name : string }\n</code></pre>"},{"location":"features/feature-clientserver-serialization/#automatic-decoders","title":"Automatic Decoders","text":"<p>Automatic decoders are the quickest and easier way to deserialize data. It works by Thoth trying to decode JSON automatically from a raw string to an F# type using automatic mapping rules. In the sample below, we fetch data from the <code>/api/customers</code> endpoint and have Thoth create a strongly-typed Decoder for a <code>Customer</code> array.</p> <pre><code>fetchAs&lt;Customer []&gt; \"/api/customers\" (Decode.Auto.generateDecoder()) []\n</code></pre> <p>If the serialization fails, Thoth will create an <code>Error</code> (rather than <code>Ok</code>) value for this.</p> <p>Be aware that automatic decoders are designed to work with primitives, collections, F# records, tuples and discriminated unions but cannot deserialize classes.</p>"},{"location":"features/feature-clientserver-serialization/#improving-efficiency-with-cached-decoders","title":"Improving efficiency with cached decoders","text":"<p>You can reuse decoders when you know you'll be calling them often:</p> <pre><code>// let-bound value that exists outside of the update function\nlet customerDecoder = Decode.Auto.generateDecoder&lt;Customer&gt;()\n\n// inside the update function\nFetch.fetchAs (sprintf \"api/customers\") (Decode.array customerDecoder [])\n</code></pre> <p>Notice how the decoder is bound to a single Customer, and not an array. This way, we can also reuse the decoder on other routes, for example <code>api/customers/1</code> which would return a single Customer object rather than a collection.</p>"},{"location":"features/feature-clientserver-serialization/#manual-decoders","title":"Manual Decoders","text":"<p>Manual decoders give you total control over how you rehydrate an object from JSON. Use them when:</p> <ul> <li>The JSON does not directly map 1:1 with your F# types</li> <li>You want flexibility to evolve JSON and F# types independently</li> <li>You are calling an external service and need fine-grained control over the deserialization process</li> <li>You are using F# on the client and another language on the server</li> </ul> <p>You create a manual decoder as follows:</p> <pre><code>let customerDecoder : Decoder&lt;Customer&gt; =\n    Decode.object\n        (fun get -&gt;\n            { Id = get.Required.Field \"id\" Decode.int\n              Name = get.Optional.Field \"customerName\" Decode.string |&gt; Option.defaultValue \"\" })\n</code></pre> <p>You can now replace the automatically generated decoder from earlier. You can also \"manually\" decode JSON to Customers as follows:</p> <pre><code>Decode.fromString customerDecoder \"\"\"{ \"id\": 67, \"customerName\": \"Joe Bloggs\" }\"\"\"\n</code></pre> <p>If decoding fails on any field, an error case will be returned.</p>"},{"location":"features/feature-clientserver/","title":"Sharing Overview","text":"<p>One of the most powerful features of SAFE is the ability to seamlessly share code across client and server.</p>"},{"location":"features/feature-clientserver/#sharing-basics","title":"Sharing Basics","text":"<p>The basics of code sharing across client and server include:</p> <ul> <li>Sharing types. Useful for contracts between client and server, as well as to share a common domain.</li> <li>Sharing behaviour. In other words, functions that perform e.g. shared validation or similar.</li> </ul> <p>These two core areas are explained in more detail here.</p>"},{"location":"features/feature-clientserver/#sending-messages-between-client-and-server","title":"Sending messages between client and server","text":"<p>In addition to types and messages, there are several technologies available in SAFE that allow you to send messages from client to server (and from server to client). Each has their own strengths and weaknesses:</p> <ul> <li>Contracts / protocols via Fable Remoting.</li> <li>Raw HTTP using Saturn's routing capabilities.</li> <li>Stateful servers through Elmish Bridge.</li> </ul>"},{"location":"features/feature-clientserver/#which-technology-should-i-use","title":"Which technology should I use?","text":"<p>Fable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts and have guaranteed type-safety between both client and server. Consider using remoting for rapid prototyping, since JSON serialization and HTTP routing is handled by the library, you only think of your client-server code in terms of types and stateless functions. Fable remoting is our recommended option for SAFE Stack apps where you \"own\" the client and server. However, if you need full control over the HTTP channel for returning specific status codes, using custom HTTP verbs or working with headers, then remoting might not for be you.</p> <p>The raw HTTP model provided by Saturn with <code>router { }</code> requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify the same type on both sides yourself). However, using the raw HTTP model gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should use this approach.</p> <p>Lastly, Elmish.Bridge provides an alternative way of modelling client/server communication. Unlike the other two mechanisms, Elmish Bridge provides the same Elmish model on the server as well as the client, as well as the ability to send notifications from the server back to connected clients via websockets. However, the Bridge model is inherently stateful, which means that a server restart could impact all connected clients.</p> Fable.Remoting Raw HTTP Elmish.Bridge Client / Server support Very easy Easy Very Easy State model Stateless Stateless Stateful \"Open\" API? Yes, with limitations Yes No HTTP Verbs? POST, GET Fully Configurable None Push messages? No With Channels Yes Pipeline Control? Limited Full Limited <p>Consider using a combination of multiple endpoints supporting combinations of the above to suit your needs!</p>"},{"location":"features/feature-hmr/","title":"Hot Module Replacement","text":"<p>Hot Module Replacement (HMR) allows to update the UI of an application while it is running, without a full reload. In SAFE stack apps, this can dramatically speed up the development for web and mobile GUIs, since there is no need to \"stop\" and \"reload\" an application. Instead, you can make changes to your views and have them immediately update in the browser, without the need to restart the application.</p>"},{"location":"features/feature-hmr/#how-does-it-work","title":"How does it work?","text":"<p>In case of web development, the Vite development server will automatically refresh the changed parts of your elmish views whenever you save a file. Alternatively, in the case of mobile app development, this is achieved through React Native's own bundler.</p>"},{"location":"features/feature-hmr/#why-does-it-work-so-well-with-safe","title":"Why does it work so well with SAFE?","text":"<p>Since SAFE uses the Model-View-Update architecture with immutable models, the application state only changes when a message is processed; this fits the HMR model very nicely. Here's an example of HMR in action to change the input of a textbox to automatically convert the input to upper case.</p> <p></p>"},{"location":"features/feature-hmr/#further-reading","title":"Further reading","text":"<ul> <li>Hot Module Replacement via Vite</li> <li>Introducing Hot Reloading in React Native</li> </ul>"},{"location":"features/feature-ssr/","title":"Server Side Rendering","text":"<p>Server-Side Rendering (SSR) means that some parts of your application code can run on both the server and the client. For React this means that you can render your components directly to HTML on the server side (e.g. via a node.js server), which allows for better search engine optimization (SEO) and gives a faster initial response, especially on mobile devices.</p> <p>The browser typically receives a static HTML site and starts updating the UI immediately; React's bundle code will be downloaded asynchronously and when it completes, the client-side JavaScript will take over via React's hydrate functionality. In the JavaScript ecosystem this is also known as an \"isomorphic\" or \"universal\" app.</p>"},{"location":"features/feature-ssr/#why-use-ssr","title":"Why use SSR?","text":""},{"location":"features/feature-ssr/#pros","title":"Pros","text":"<ul> <li>Better SEO support, as web crawlers will directly see the fully rendered HTML page.</li> <li>Faster time-to-content, especially on slow internet connections or devices.</li> </ul>"},{"location":"features/feature-ssr/#cons","title":"Cons","text":"<ul> <li>Some development constraints. Browser-specific code requires some compiler directives to be ignored when running on the server.</li> <li>Increased complexity of build and deployment processes.</li> <li>Increased server-side load.</li> </ul>"},{"location":"features/feature-ssr/#ssr-on-safe","title":"SSR on SAFE","text":"<p>In SAFE, SSR can be done using fable-react. Its approach is a little different from those you might have seen in the JavaScript ecosystem, as it takes a purely F# approach: you render your Elmish views directly on .NET Core, with all the benefits of the .NET Core runtime.</p>"},{"location":"features/feature-ssr/#further-reading","title":"Further reading","text":"<ul> <li>More details can be found in the SSR tutorial.</li> <li>The SAFE-BookStore sample project uses SSR.</li> </ul>"},{"location":"recipes/template/","title":"How do I create a SAFE recipe?","text":"<p>Follow the following pattern and headings and the guide below.</p>"},{"location":"recipes/template/#best-practices","title":"Best practices","text":"<ol> <li>DO focus on integration between different components in the SAFE Stack e.g. how to connect Fable apps to Saturn backend etc.</li> <li>DO focus on getting results quickly.</li> <li>DO consider both template versions e.g. make the recipe suitable for both \"minimal\" and \"full\" template options</li> <li>Do NOT reproduce reference documentation from \"source\" technologies e.g. do NOT replicate documentation from Saturn or Fable sites.</li> <li>DO link to reference documentation from source technologies.</li> <li>Do NOT create reference documentation in a recipe.</li> <li>DO use simple code snippets where appropriate.</li> </ol>"},{"location":"recipes/template/#how-do-i-insert-task-here","title":"How Do I &lt; insert task here &gt;?","text":"<p>Start by writing a short introduction of a few sentences. Explain what the recipe is about, and problems it solves. Which technologies does it utilise, and what are the alternatives etc.?</p> <p>Remember to link the first instance of any technology to the appropriate docs elsewhere within this site, or to the homepage of the technology (or both!).</p>"},{"location":"recipes/template/#step-by-step-guide","title":"Step-by-step Guide","text":"<p>Write clear instructions on how to get to the desired outcome. The step-by-step instructions should be clear, short, easy to understand with possibly a use case and an example at the end if suitable.</p> <p>If you have a step in this section that is relevant to some other recipe we have here in the docs, such as adding a package to a SAFE app, link it to that relevant page.</p>"},{"location":"recipes/build/add-build-script/","title":"How do I add build automation to the project?","text":""},{"location":"recipes/build/add-build-script/#fake","title":"FAKE","text":"<p>Fake is a DSL for build tasks that is modular, extensible and easy to start with. Fake allows you to easily build, bundle, deploy your app and more by executing a single command.</p> <p>The standard template comes with a FAKE project by default, so this recipe only applies to the minimal template.</p>"},{"location":"recipes/build/add-build-script/#1-create-a-build-project","title":"1. Create a build project","text":"<p>Create a new console app called 'Build' at the root of your solution</p> <pre><code>dotnet new console -lang f# -n Build -o .\n</code></pre> <p>We are creating the project directly at the root of the solution in order to allow us to execute the build without needing to navigate into a subfolder.</p>"},{"location":"recipes/build/add-build-script/#2-create-a-build-script","title":"2. Create a build script","text":"<p>Open the project you just created in your IDE and rename the module it contains from <code>Program.fs</code> to <code>Build.fs</code>.</p> <p>This renaming isn't explicitly necessary, however it keeps your solution consistent with other SAFE apps and is a better name for the file really.</p> <p>If you just rename the file directly rather than in your IDE, then the Build project won't be able to find it unless you edit the Build.fsproj file as well</p> <p>Open <code>Build.fs</code> and paste in the following code.</p> <pre><code>open Fake.Core\nopen Fake.IO\nopen System\n\nlet redirect createProcess =\n    createProcess\n    |&gt; CreateProcess.redirectOutputIfNotRedirected\n    |&gt; CreateProcess.withOutputEvents Console.WriteLine Console.WriteLine\n\nlet createProcess exe arg dir =\n    CreateProcess.fromRawCommandLine exe arg\n    |&gt; CreateProcess.withWorkingDirectory dir\n    |&gt; CreateProcess.ensureExitCode\n\nlet dotnet = createProcess \"dotnet\"\n\nlet npm =\n    let npmPath =\n        match ProcessUtils.tryFindFileOnPath \"npm\" with\n        | Some path -&gt; path\n        | None -&gt; failwith \"npm was not found in path.\"\n    createProcess npmPath\n\nlet run proc arg dir =\n    proc arg dir\n    |&gt; Proc.run\n    |&gt; ignore\n\nlet execContext = Context.FakeExecutionContext.Create false \"build.fsx\" [ ]\nContext.setExecutionContext (Context.RuntimeContext.Fake execContext)\n\nTarget.create \"Clean\" (fun _ -&gt; Shell.cleanDir (Path.getFullName \"deploy\"))\n\nTarget.create \"InstallClient\" (fun _ -&gt; run npm \"install\" \".\")\n\nTarget.create \"Run\" (fun _ -&gt;\n    run dotnet \"build\" (Path.getFullName \"src/Shared\")\n    [ dotnet \"watch run\" (Path.getFullName \"src/Server\")\n      dotnet \"fable watch --run npx vite\" (Path.getFullName \"src/Client\") ]\n    |&gt; Seq.toArray\n    |&gt; Array.map redirect\n    |&gt; Array.Parallel.map Proc.run\n    |&gt; ignore\n)\n\nopen Fake.Core.TargetOperators\n\nlet dependencies = [\n    \"Clean\"\n        ==&gt; \"InstallClient\"\n        ==&gt; \"Run\"\n]\n\n[&lt;EntryPoint&gt;]\nlet main args =\n  try\n      match args with\n      | [| target |] -&gt; Target.runOrDefault target\n      | _ -&gt; Target.runOrDefault \"Run\"\n      0\n  with e -&gt;\n      printfn \"%A\" e\n      1\n</code></pre>"},{"location":"recipes/build/add-build-script/#3-add-the-project-to-the-solution","title":"3. Add the project to the solution","text":"<p>Run the following command</p> <pre><code>dotnet sln add Build.fsproj\n</code></pre>"},{"location":"recipes/build/add-build-script/#4-installing-dependencies","title":"4. Installing dependencies","text":"<p>You will need to install the following dependencies:</p> <pre><code>Fake.Core.Target\nFake.IO.FileSystem\n</code></pre> <p>We recommend migrating to Paket. It is possible to use FAKE without Paket, however this will not be covered in this recipe.</p>"},{"location":"recipes/build/add-build-script/#5-run-the-app","title":"5. Run the app","text":"<p>At the root of the solution, run <code>dotnet paket install</code> to install all your dependencies.</p> <p>If you now execute <code>dotnet run</code>, the default target will be run. This will build the app in development mode and launch it locally.</p> <p>To learn more about targets and FAKE in general, see Getting Started with FAKE.</p>"},{"location":"recipes/build/bundle-app/","title":"How do I bundle my SAFE application?","text":"<p>When developing your SAFE application, the local runtime experience uses Vite to run the client and redirect API calls to the server on a different port. However, when you deploy your application, you'll need to run your Saturn server which will serve up statically-built client resources (HTML, JavaScript, CSS etc.).</p>"},{"location":"recipes/build/bundle-app/#1-run-the-fake-script","title":"1. Run the FAKE script","text":"<p>If you created your SAFE app using the recommended defaults, your application already has a FAKE script which will do the bundling for you. You can create a bundle using the following command:</p> <pre><code>dotnet run Bundle\n</code></pre> <p>This will build and package up both the client and server and place them into the <code>/deploy</code> folder at the root of the repository.</p> <p>See here for more details on this build target.</p>"},{"location":"recipes/build/bundle-app/#testing-the-bundle","title":"Testing the bundle","text":"<ol> <li>Navigate to the <code>deploy</code> folder at the root of your repository.</li> <li>Run the <code>Server.exe</code> application.</li> <li>Navigate in your browser to <code>http://localhost:5000</code>.</li> </ol> <p>You should now see your SAFE application.</p>"},{"location":"recipes/build/bundle-app/#further-reading","title":"Further reading","text":"<p>See this article for more information on architectural concerns regarding the move from dev to production and bundling SAFE Stack applications.</p>"},{"location":"recipes/build/docker-image/","title":"How do I build with docker?","text":"<p>Using Docker makes it possible to deploy your application as a docker container or release an image on docker hub. This recipe walks you through creating a <code>Dockerfile</code> and automating the build and test process with Docker Hub.</p>"},{"location":"recipes/build/docker-image/#1-create-a-dockerignore-file","title":"1. Create a .dockerignore file","text":"<p>Create a <code>.dockerignore</code> file with the same contents as <code>.gitignore</code></p>"},{"location":"recipes/build/docker-image/#linux","title":"Linux","text":"<pre><code>cp .gitignore .dockerignore\n</code></pre>"},{"location":"recipes/build/docker-image/#windows","title":"Windows","text":"<pre><code>copy .gitignore .dockerignore\n</code></pre> <p>Now, add the following lines to the <code>.dockerignore</code> file:</p> <pre><code>.git\n</code></pre>"},{"location":"recipes/build/docker-image/#2-create-the-dockerfile","title":"2. Create the dockerfile","text":"<p>Create a <code>Dockerfile</code> with the following contents:</p> <pre><code>FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build\n\n# Install node\nARG NODE_MAJOR=20\nRUN apt-get update\nRUN apt-get install -y ca-certificates curl gnupg\nRUN mkdir -p /etc/apt/keyrings\nRUN curl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg\nRUN echo \"deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_$NODE_MAJOR.x nodistro main\" | tee /etc/apt/sources.list.d/nodesource.list\nRUN apt-get update &amp;&amp; apt-get install nodejs -y\n\nWORKDIR /workspace\nCOPY . .\nRUN dotnet tool restore\nRUN dotnet run Bundle\n\nFROM mcr.microsoft.com/dotnet/aspnet:8.0-alpine\nCOPY --from=build /workspace/deploy /app\nWORKDIR /app\nEXPOSE 5000\nENTRYPOINT [ \"dotnet\", \"Server.dll\" ]\n</code></pre> <p>This uses multistage builds to keep the final image small.</p>"},{"location":"recipes/build/docker-image/#3-building-and-running-with-docker-locally","title":"3. Building and running with docker locally","text":"<ol> <li>Build the image <code>docker build -t my-safe-app .</code></li> <li>Run the container <code>docker run -it -p 8080:8080 my-safe-app</code></li> <li>Open the page in browser at http://localhost:8080</li> </ol> <p>Because the build is done entirely in docker, Docker Hub automated builds can be setup to automatically build and push the docker image.</p>"},{"location":"recipes/build/docker-image/#4-testing-the-server","title":"4. Testing the server","text":"<p>Create a <code>docker-compose.server.test.yml</code> file with the following contents:</p> <p><pre><code>version: '3.4'\nservices:\n    sut:\n        build:\n            target: build\n            context: .\n        working_dir: /workspace/tests/Server\n        command: dotnet run\n</code></pre> To run the tests execute the command <code>docker-compose -f docker-compose.server.test.yml up --build</code></p> <p>The template is not currently setup for automating the client tests in ci.</p> <p>Docker Hub can also run automated tests for you.</p> <p>Follow the instructions to enable Autotest on docker hub.</p>"},{"location":"recipes/build/docker-image/#5-making-the-docker-build-faster","title":"5. Making the docker build faster","text":"<p>Not recommended for most applications</p> <p>If you often build with docker locally, you may wish to make the build faster by optimising the Dockerfile for caching. For example, it is not necessary to download all paket and npm dependencies on every build unless there have been changes to the dependencies.</p> <p>Furthermore, the client and server can be built in separate build stages so that they are cached independently. Enable Docker BuildKit to build them concurrently.</p> <p>This comes at the expense of making the dockerfile more complex; if any changes are made to the build such as adding new projects or migrating package managers, the dockerfile must be updated accordingly.</p> <p>The following should be a good starting point but is not guaranteed to work.</p> <pre><code>FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build\n\n# Install node\nARG NODE_MAJOR=20\nRUN apt-get update\nRUN apt-get install -y ca-certificates curl gnupg\nRUN mkdir -p /etc/apt/keyrings\nRUN curl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg\nRUN echo \"deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_$NODE_MAJOR.x nodistro main\" | tee /etc/apt/sources.list.d/nodesource.list\nRUN apt-get update &amp;&amp; apt-get install nodejs -y\n\nWORKDIR /workspace\nCOPY .config .config\nRUN dotnet tool restore\nCOPY .paket .paket\nCOPY paket.dependencies paket.lock ./\n\nFROM build as server-build\nCOPY src/Shared src/Shared\nCOPY src/Server src/Server\nRUN cd src/Server &amp;&amp; dotnet publish -c release -o ../../deploy\n\nFROM build as client-build\nCOPY package.json package-lock.json ./\nRUN npm install\nCOPY src/Shared src/Shared\nCOPY src/Client src/Client\n# tailwind.config.js needs to be in the dir where the\n# vite build command is run from otherwise styles will\n# be missing from the bundle\nCOPY src/Client/tailwind.config.js .\nRUN dotnet fable src/Client -o src/Client/output --run npx vite build src/Client\n\nFROM mcr.microsoft.com/dotnet/aspnet:8.0-alpine\nCOPY --from=server-build /workspace/deploy /app\nCOPY --from=client-build /workspace/deploy /app\nWORKDIR /app\nEXPOSE 5000\nENTRYPOINT [ \"dotnet\", \"Server.dll\" ]\n</code></pre>"},{"location":"recipes/build/remove-fake/","title":"How do I remove the use of FAKE?","text":"<p>FAKE is a tool for build automation. The standard SAFE template comes with a ready-made build project at the root of the solution that provides support for many common SAFE tasks.</p> <p>If you would prefer not to use FAKE, you can of course simply ignore it, but this recipes shows how to completely remove it from your repository. It is important to note that having removed FAKE, you will have to follow a more manual approach to each of these processes. This recipe will only include instructions on how to run the application after removing FAKE.</p> <p>Note that the minimal template does not use FAKE by default, and this recipe only applies to the standard template.</p>"},{"location":"recipes/build/remove-fake/#1-build-project","title":"1. Build project","text":"<p>Delete <code>Build.fs</code>, <code>Build.fsproj</code>, <code>Helpers.fs</code>, <code>paket.references</code> at the root of the solution.</p>"},{"location":"recipes/build/remove-fake/#2-dependencies","title":"2. Dependencies","text":"<p>Remove the following dependencies <pre><code>dotnet paket remove Fake.Core.Target\ndotnet paket remove Fake.IO.FileSystem\ndotnet paket remove Farmer\n</code></pre></p>"},{"location":"recipes/build/remove-fake/#running-the-app","title":"Running the App","text":"<p>Now that you have removed the FAKE application dependencies, you will have to separately run the server and the client.</p>"},{"location":"recipes/build/remove-fake/#1-start-the-server","title":"1. Start the Server","text":"<p>Navigate to <code>src/Server</code> inside a terminal and execute <code>dotnet run</code>.</p>"},{"location":"recipes/build/remove-fake/#2-start-the-client","title":"2. Start the Client","text":"<p>Navigate to <code>src/Client</code> inside a terminal and execute the following:</p> <pre><code>dotnet tool restore\nnpm install\ndotnet fable watch -o output -s --run npx vite\n</code></pre> <p>The app will now be running at <code>http://localhost:8080/</code>. Navigate to this address in a browser to see your app running.</p>"},{"location":"recipes/build/remove-fake/#bundling-the-app","title":"Bundling the App","text":"<p>See this guide to learn how to package a SAFE application for deployment to e.g. Azure.</p>"},{"location":"recipes/client-server/fable-remoting/","title":"How Do I Add Support for Fable Remoting?","text":"<p>Fable Remoting is a type-safe RPC communication layer for SAFE apps. It uses HTTP behind the scenes, but allows you to program against protocols that exist across the application without needing to think about the HTTP plumbing, and is a great fit for the majority of SAFE applications.</p> <p>Note that the standard template uses Fable Remoting. This recipe only applies to the minimal template.</p>"},{"location":"recipes/client-server/fable-remoting/#1-install-nuget-packages","title":"1. Install NuGet Packages","text":"<p>Add Fable.Remoting.Giraffe to the Server and Fable.Remoting.Client to the Client.</p> <p>See How Do I Add a NuGet Package to the Server and How Do I Add a NuGet Package to the Client.</p>"},{"location":"recipes/client-server/fable-remoting/#2-create-the-api-protocol","title":"2. Create the API protocol","text":"<p>You now need to create the protocol, or contract, of the API we\u2019ll be creating. Insert the following below the <code>Route</code> module in <code>Shared.fs</code>: <pre><code>type IMyApi =\n    { hello : unit -&gt; Async&lt;string&gt; }\n</code></pre></p>"},{"location":"recipes/client-server/fable-remoting/#3-create-the-routing-function","title":"3. Create the routing function","text":"<p>We need to provide a basic routing function in order to ensure client and server communicate on the same endpoint. Find the <code>Route</code> module in <code>src/Shared/Shared.fs</code> and replace it with the following:</p> <pre><code>module Route =\n    let builder typeName methodName =\n        sprintf \"/api/%s/%s\" typeName methodName\n</code></pre>"},{"location":"recipes/client-server/fable-remoting/#4-create-the-protocol-implementation","title":"4. Create the protocol implementation","text":"<p>We now need to provide an implementation of the protocol on the server. Open <code>src/Server/Server.fs</code> and insert the following right after the <code>open</code> statements:</p> <pre><code>let myApi =\n    { hello = fun () -&gt; async { return \"Hello from SAFE!\" } }\n</code></pre>"},{"location":"recipes/client-server/fable-remoting/#5-hook-into-aspnet","title":"5. Hook into ASP.NET","text":"<p>We now need to \"adapt\" Fable Remoting into the ASP.NET pipeline by converting it into a Giraffe HTTP Handler. Don't worry - this is not hard. Find <code>webApp</code> in <code>Server.fs</code> and replace it with the following:</p> <pre><code>open Fable.Remoting.Server\nopen Fable.Remoting.Giraffe\n\nlet webApp =\n    Remoting.createApi()\n    |&gt; Remoting.withRouteBuilder Route.builder // use the routing function from step 3\n    |&gt; Remoting.fromValue myApi // use the myApi implementation from step 4\n    |&gt; Remoting.buildHttpHandler // adapt it to Giraffe's HTTP Handler\n</code></pre>"},{"location":"recipes/client-server/fable-remoting/#6-create-the-client-proxy","title":"6. Create the Client proxy","text":"<p>We now need a corresponding client proxy in order to be able to connect to the server. Open <code>src/Client/Client.fs</code> and insert the following right after the <code>Msg</code> type: <pre><code>open Fable.Remoting.Client\n\nlet myApi =\n    Remoting.createApi()\n    |&gt; Remoting.withRouteBuilder Route.builder\n    |&gt; Remoting.buildProxy&lt;IMyApi&gt;\n</code></pre></p>"},{"location":"recipes/client-server/fable-remoting/#7-make-calls-to-the-server","title":"7. Make calls to the Server","text":"<p>Replace the following two lines in the <code>init</code> function in <code>Client.fs</code>:</p> <pre><code>let getHello() = Fetch.get&lt;unit, string&gt; Route.hello\nlet cmd = Cmd.OfPromise.perform getHello () GotHello\n</code></pre> <p>with this:</p> <pre><code>let cmd = Cmd.OfAsync.perform myApi.hello () GotHello\n</code></pre>"},{"location":"recipes/client-server/fable-remoting/#done","title":"Done!","text":"<p>At this point, the app should work just as it did before. Now, expanding the API and adding a new endpoint is as easy as adding a new field to the API protocol we defined in <code>Shared.fs</code>, editing the <code>myApi</code> record in <code>Server.fs</code> with the implementation, and finally making calls from the proxy.</p>"},{"location":"recipes/client-server/fable.forms/","title":"Add support for Fable.Forms","text":""},{"location":"recipes/client-server/fable.forms/#install-dependencies","title":"Install dependencies","text":"<p>First off, you need to create a SAFE app, install the relevant dependencies, and wire them up to be available for use in your F# Fable code.</p> <ol> <li>Create a new SAFE app and restore local tools: <pre><code>dotnet new SAFE\ndotnet tool restore\n</code></pre></li> <li> <p>Add bulma to your project: follow this recipe</p> </li> <li> <p>Install Fable.Form.Simple.Bulma using Paket: <pre><code>dotnet paket add Fable.Form.Simple.Bulma -p Client\n</code></pre></p> </li> <li> <p>Install bulma and fable-form-simple-bulma npm packages: <pre><code>npm add fable-form-simple-bulma\nnpm add bulma\n</code></pre></p> </li> </ol>"},{"location":"recipes/client-server/fable.forms/#register-styles","title":"Register styles","text":"<ol> <li> <p>Rename <code>src/Client/Index.css</code> to <code>Index.scss</code></p> </li> <li> <p>Update the import in <code>App.fs</code></p> CodeDiff App.fs<pre><code>...\nimportSideEffects \"./index.scss\"\n...\n</code></pre> App.fs<pre><code>...\n- importSideEffects \"./index.css\"\n+ importSideEffects \"./index.scss\"\n...\n</code></pre> </li> <li> <p>Import bulma and fable-form-simple in <code>Index.scss</code></p> Index.scss<pre><code>@import \"bulma/bulma.sass\";\n@import \"fable-form-simple-bulma/index.scss\";\n...\n</code></pre> </li> <li> <p>Remove the Bulma stylesheet link from <code>./src/Client/index.html</code>, as it is no longer needed:</p> index.html<pre><code>    &lt;link rel=\"icon\" type=\"image/png\" href=\"/favicon.png\"/&gt;\n-   &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css\"&gt;\n</code></pre> </li> </ol>"},{"location":"recipes/client-server/fable.forms/#replace-the-existing-form-with-a-fableform","title":"Replace the existing form with a Fable.Form","text":"<p>With the above preparation done, you can use Fable.Form.Simple.Bulma in your <code>./src/Client/Index.fs</code> file.</p> <ol> <li> <p>Open the newly added namespaces:</p> Index.fs<pre><code>open Fable.Form.Simple\nopen Fable.Form.Simple.Bulma\n</code></pre> </li> <li> <p>Create type <code>Values</code> to represent each input field on the form (a single textbox), and create a type <code>Form</code> which is an alias for <code>Form.View.Model&lt;Values&gt;</code>:</p> Index.fs<pre><code>type Values = { Todo: string }\ntype Form = Form.View.Model&lt;Values&gt;\n</code></pre> </li> <li> <p>In the <code>Model</code> type definition, replace <code>Input: string</code> with <code>Form: Form</code> </p> CodeDiff Index.fs<pre><code>type Model = { Todos: Todo list; Form: Form }\n</code></pre> Index.fs<pre><code>-type Model = { Todos: Todo list; Input: string }\n+type Model = { Todos: Todo list; Form: Form }\n</code></pre> </li> <li> <p>Update the <code>init</code> function to reflect the change in <code>Model</code>:</p> CodeDiff Index.fs<pre><code>let model = { Todos = []; Form = Form.View.idle { Todo = \"\" } }\n</code></pre> Index.fs<pre><code>-let model = { Todos = []; Input = \"\" }\n+let model = { Todos = []; Form = Form.View.idle { Todo = \"\" } }\n</code></pre> </li> <li> <p>Change <code>Msg</code> discriminated union - replace the <code>SetInput</code> case with <code>FormChanged of Form</code>, and add string data to the <code>AddTodo</code> case:</p> CodeDiff Index.fs<pre><code>type Msg =\n    | GotTodos of Todo list\n    | FormChanged of Form\n    | AddTodo of string\n    | AddedTodo of Todo\n</code></pre> Index.fs<pre><code>type Msg =\n    | GotTodos of Todo list\n-   | SetInput of string\n-   | AddTodo\n+   | FormChanged of Form\n+   | AddTodo of string\n    | AddedTodo of Todo\n</code></pre> </li> <li> <p>Modify the <code>update</code> function to handle the changed <code>Msg</code> cases:</p> CodeDiff Index.fs<pre><code>let update (msg: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n    match msg with\n    | GotTodos todos -&gt; { model with Todos = todos }, Cmd.none\n    | FormChanged form -&gt; { model with Form = form }, Cmd.none\n    | AddTodo todo -&gt;\n        let todo = Todo.create todo\n        let cmd = Cmd.OfAsync.perform todosApi.addTodo todo AddedTodo\n        model, cmd\n    | AddedTodo todo -&gt;\n        let newModel =\n            { model with\n                Todos = model.Todos @ [ todo ]\n                Form =\n                    { model.Form with\n                        State = Form.View.Success \"Todo added\"\n                        Values = { model.Form.Values with Todo = \"\" } } }\n        newModel, Cmd.none\n</code></pre> Index.fs<pre><code>let update (msg: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n    match msg with\n    | GotTodos todos -&gt; { model with Todos = todos }, Cmd.none\n-   | SetInput value -&gt; { model with Input = value }, Cmd.none\n+   | FormChanged form -&gt; { model with Form = form }, Cmd.none\n-   | AddTodo -&gt;\n-       let todo = Todo.create model.Input\n-       let cmd = Cmd.OfAsync.perform todosApi.addTodo todo AddedTodo\n-       { model with Input = \"\" }, cmd\n+   | AddTodo todo -&gt;\n+       let todo = Todo.create todo\n+       let cmd = Cmd.OfAsync.perform todosApi.addTodo todo AddedTodo\n+       model, cmd\n-   | AddedTodo todo -&gt; { model with Todos = model.Todos @ [ todo ] }, Cmd.none\n+   | AddedTodo todo -&gt;\n+       let newModel =\n+           { model with\n+               Todos = model.Todos @ [ todo ]\n+               Form =\n+                   { model.Form with\n+                       State = Form.View.Success \"Todo added\"\n+                       Values = { model.Form.Values with Todo = \"\" } } }\n+       newModel, Cmd.none\n</code></pre> </li> <li> <p>Create <code>form</code>. This defines the logic of the form, and how it responds to interaction:</p> Index.fs<pre><code>let form : Form.Form&lt;Values, Msg, _&gt; =\n    let todoField =\n        Form.textField\n            {\n                Parser = Ok\n                Value = fun values -&gt; values.Todo\n                Update = fun newValue values -&gt; { values with Todo = newValue }\n                Error = fun _ -&gt; None\n                Attributes =\n                    {\n                        Label = \"New todo\"\n                        Placeholder = \"What needs to be done?\"\n                        HtmlAttributes = []\n                    }\n            }\n\n    Form.succeed AddTodo\n    |&gt; Form.append todoField\n</code></pre> </li> <li> <p>In the function <code>todoAction</code>, remove the existing form view. Then replace it using <code>Form.View.asHtml</code> to render the view:</p> CodeDiff Index.fs<pre><code>let private todoAction model dispatch =\n    Form.View.asHtml\n        {\n            Dispatch = dispatch\n            OnChange = FormChanged\n            Action = Action.SubmitOnly \"Add\"\n            Validation = Validation.ValidateOnBlur\n        }\n        form\n        model.Form\n</code></pre> Index.fs<pre><code>  let private todoAction model dispatch =\n-      Html.div [\n-      ...\n- ]\n+    Form.View.asHtml\n+       {\n+           Dispatch = dispatch\n+           OnChange = FormChanged\n+           Action = Action.SubmitOnly \"Add\"\n+           Validation = Validation.ValidateOnBlur\n+       }\n+       form\n+       model.Form\n</code></pre> </li> </ol>"},{"location":"recipes/client-server/fable.forms/#adding-new-functionality","title":"Adding new functionality","text":"<p>With the basic structure in place, it's easy to add functionality to the form. For example, the changes necessary to add a high priority checkbox are pretty small.</p>"},{"location":"recipes/client-server/messaging-post/","title":"How do I send and receive data using POST?","text":"<p>This recipe shows how to create an endpoint on the server and hook up it up to the client using HTTP POST. This recipe assumes that you have also followed this recipe and have an understanding of MVU messaging. This recipe only shows how to wire up the client and server.</p> <p>A POST endpoint is normally used to send data from the client to the server in the body, for example from a form. This is useful when we need to supply more data than can easily be provided in the URI.</p> <p>You may wish to use POST for \"write\" operations and use GETs for \"reads\", however this is a highly opinionated topic that is beyond the scope of this recipe.</p>"},{"location":"recipes/client-server/messaging-post/#im-using-the-standard-template-fable-remoting","title":"I'm using the standard template (Fable Remoting)","text":"<p>Fable Remoting takes care of deciding whether to use POST or GET etc. - you don't have to worry about this. Refer to this recipe for more details.</p>"},{"location":"recipes/client-server/messaging-post/#im-using-the-minimal-template-raw-http","title":"I'm using the minimal template (Raw HTTP)","text":""},{"location":"recipes/client-server/messaging-post/#in-shared","title":"In Shared","text":""},{"location":"recipes/client-server/messaging-post/#1-create-contract","title":"1. Create contract","text":"<p>Create the type that will store the payload sent from the client to the server.</p> <pre><code>type SaveCustomerRequest =\n    { Name : string\n      Age : int }\n</code></pre>"},{"location":"recipes/client-server/messaging-post/#on-the-client","title":"On the Client","text":""},{"location":"recipes/client-server/messaging-post/#1-call-the-endpoint","title":"1. Call the endpoint","text":"<p>Create a new function <code>saveCustomer</code> that will call the server. It supplies the customer to save, which is serialized and sent to the server in the body of the message.</p> <pre><code>let saveCustomer customer =\n    let save customer = Fetch.post&lt;SaveCustomerRequest, int&gt; (\"/api/customer\", customer)\n    Cmd.OfPromise.perform save customer CustomerSaved\n</code></pre> <p>The generic arguments of <code>Fetch.post</code> are the input and output types. The example above shows that the input is of type <code>SaveCustomerRequest</code> with the response will contain an integer value. This may be the ID generated by the server for the save operation.</p> <p>This can now be called from within your <code>update</code> function e.g.</p> <pre><code>| SaveCustomer request -&gt;\n    model, saveCustomer request\n| CustomerSaved generatedId -&gt;\n    { model with GeneratedCustomerId = Some generatedId; Message = \"Saved customer!\" }, Cmd.none\n</code></pre>"},{"location":"recipes/client-server/messaging-post/#on-the-server","title":"On the Server","text":""},{"location":"recipes/client-server/messaging-post/#1-write-implementation","title":"1. Write implementation","text":"<p>Create a function that can extract the payload from the body of the request using Giraffe's built-in model binding support:</p> <pre><code>open FSharp.Control.Tasks\nopen Giraffe\nopen Microsoft.AspNetCore.Http\nopen Shared\n\n/// Extracts the request from the body and saves to the database.\nlet saveCustomer next (ctx:HttpContext) = task {\n    let! customer = ctx.BindModelAsync&lt;SaveCustomerRequest&gt;()\n    do! Database.saveCustomer customer\n    return! Successful.OK \"Saved customer\" next ctx\n}\n</code></pre>"},{"location":"recipes/client-server/messaging-post/#2-expose-your-function","title":"2. Expose your function","text":"<p>Tie your function into the router, using the <code>post</code> verb instead of <code>get</code>.</p> <pre><code>let webApp = router {\n    post \"/api/customer\" saveCustomer // Add this\n}\n</code></pre>"},{"location":"recipes/client-server/messaging/","title":"How do I send and receive data?","text":"<p>This recipe shows how to create an endpoint on the server and hook up it up to the client. This recipe assumes that you have also followed this recipe and have an understanding of MVU messaging. This recipe only shows how to wire up the client and server.</p>"},{"location":"recipes/client-server/messaging/#im-using-the-standard-template-fable-remoting","title":"I'm using the standard template (Fable Remoting)","text":"<p>Fable Remoting is a library which allows you to create client/server messaging without any need to think about HTTP verbs or serialization etc.</p>"},{"location":"recipes/client-server/messaging/#in-shared","title":"In Shared","text":""},{"location":"recipes/client-server/messaging/#1-update-contract","title":"1. Update contract","text":"<p>Add your new endpoint onto an existing API contract e.g. <code>ITodosApi</code>. Because Fable Remoting exposes your API through F# on client and server, you get type safety across both.</p> <pre><code>type ITodosApi =\n    { getCustomer : int -&gt; Async&lt;Customer option&gt; }\n</code></pre>"},{"location":"recipes/client-server/messaging/#on-the-server","title":"On the server","text":""},{"location":"recipes/client-server/messaging/#1-write-implementation","title":"1. Write implementation","text":"<p>Create a function that implements the back-end service that you require. Use standard functions to read from databases or other external sources as required. <pre><code>let loadCustomer customerId = async {\n    return Some { Name = \"My Customer\" }\n}\n</code></pre></p> <p>Note the use of <code>async</code> here. Fable Remoting uses async workflows, and not tasks. You can write functions that use task, but will have to at some point map to async using <code>Async.AwaitTask</code>.</p>"},{"location":"recipes/client-server/messaging/#2-expose-your-function","title":"2. Expose your function","text":"<p>Tie the function you've just written into the API implementation. <pre><code>let todosApi =\n    { ///...\n      getCustomer = loadCustomer\n    }\n</code></pre></p>"},{"location":"recipes/client-server/messaging/#3-test-the-endpoint-optional","title":"3. Test the endpoint (optional)","text":"<p>Test out your endpoint using e.g. web browser / Postman / REST Client for VS Code etc. See here for more details on the required format.</p>"},{"location":"recipes/client-server/messaging/#on-the-client","title":"On the client","text":""},{"location":"recipes/client-server/messaging/#1-call-the-endpoint","title":"1. Call the endpoint","text":"<p>Create a new function <code>loadCustomer</code> that will call the endpoint.</p> <pre><code>let loadCustomer customerId =\n    Cmd.OfAsync.perform todosApi.getCustomer customerId LoadedCustomer\n</code></pre> <p>Note the final value supplied, <code>CustomerLoaded</code>. This is the <code>Msg</code> case that will be sent into the Elmish loop once the call returns, with the returned data. It should take in a value that matches the type returned by the Server e.g. <code>CustomerLoaded of Customer option</code>. See here for more information.</p> <p>This can now be called from within your <code>update</code> function e.g.</p> <pre><code>| LoadCustomer customerId -&gt;\n    model, loadCustomer customerId\n</code></pre>"},{"location":"recipes/client-server/messaging/#im-using-the-minimal-template-raw-http","title":"I'm using the minimal template (Raw HTTP)","text":"<p>This recipe shows how to create a GET endpoint on the server and consume it on the client using the Fetch API.</p>"},{"location":"recipes/client-server/messaging/#on-the-server_1","title":"On the Server","text":""},{"location":"recipes/client-server/messaging/#1-write-implementation_1","title":"1. Write implementation","text":"<p>Create a function that implements the back-end service that you require. Use standard functions to read from databases or other external sources as required. <pre><code>open Saturn\nopen FSharp.Control.Tasks\n\n/// Loads a customer from the DB and returns as a Customer in json.\nlet loadCustomer (customerId:int) next ctx = task {\n    let customer = { Name = \"My Customer\" }\n    return! json customer next ctx\n}\n</code></pre></p> <p>Note how we parameterise this function to take in the <code>customerId</code> as the first argument. Any parameters you need should be supplied in this manner. If you do not need any parameters, just omit them and leave the <code>next</code> and <code>ctx</code> ones.</p> <p>This example does not cover dealing with \"missing\" data e.g. invalid customer ID is found.</p>"},{"location":"recipes/client-server/messaging/#2expose-your-function","title":"2.Expose your function","text":"<p>Tie the function into the router with a route.</p> <pre><code>let webApp = router {\n    getf \"/api/customer/%i\" loadCustomer // Add this\n}\n</code></pre> <p>Note the use of <code>getf</code> rather than <code>get</code>. If you do not need any parameters, just use <code>get</code>. See here for reference docs on the use of the Saturn router.</p>"},{"location":"recipes/client-server/messaging/#3-test-the-endpoint-optional_1","title":"3. Test the endpoint (optional)","text":"<p>Test out your endpoint using e.g. web browser / Postman / REST Client for VS Code etc.</p>"},{"location":"recipes/client-server/messaging/#on-the-client_1","title":"On the client","text":""},{"location":"recipes/client-server/messaging/#1-call-the-endpoint_1","title":"1. Call the endpoint","text":"<p>Create a new function <code>loadCustomer</code> that will call the endpoint.</p> <p>This example uses Thoth.Fetch to download and deserialise the response.</p> <pre><code>let loadCustomer customerId =\n    let loadCustomer () = Fetch.get&lt;unit, Customer&gt; (sprintf \"/api/customer/%i\" customerId)\n    Cmd.OfPromise.perform loadCustomer () CustomerLoaded\n</code></pre> <p>Note the final value supplied, <code>CustomerLoaded</code>. This is the <code>Msg</code> case that will be sent into the Elmish loop once the call returns, with the returned data. It should take in a value that matches the type returned by the Server e.g. <code>CustomerLoaded of Customer</code>. See here for more information.</p> <p>An alternative (and slightly more succinct) way of writing this is:</p> <pre><code>let loadCustomer customerId =\n    let loadCustomer = sprintf \"/api/customer/%i\" &gt;&gt; Fetch.get&lt;unit, Customer&gt;\n    Cmd.OfPromise.perform loadCustomer customerId CustomerLoaded\n</code></pre> <p>This can now be called from within your <code>update</code> function e.g.</p> <pre><code>| LoadCustomer customerId -&gt;\n    model, loadCustomer customerId\n</code></pre>"},{"location":"recipes/client-server/mvu-roundtrip/","title":"How do I load data from server to client using MVU?","text":"<p>This recipe demonstrates the steps you need to take to store new data on the client using the MVU pattern, which is typically read from the Server. You will learn the steps required to modify the model, update and view functions to handle a button click which requests data from the server and handles the response.</p>"},{"location":"recipes/client-server/mvu-roundtrip/#in-shared","title":"In Shared","text":""},{"location":"recipes/client-server/mvu-roundtrip/#1-create-shared-domain","title":"1. Create shared domain","text":"<p>Create a type in the Shared project which will act as the contract type between client and server. As SAFE compiles F# into JavaScript for you, you only need a single definition which will automatically be shared. <pre><code>type Customer = { Name : string }\n</code></pre></p>"},{"location":"recipes/client-server/mvu-roundtrip/#on-the-client","title":"On the Client","text":""},{"location":"recipes/client-server/mvu-roundtrip/#1-create-message-pairs","title":"1. Create message pairs","text":"<p>Modify the <code>Msg</code> type to have two new messages:</p> <pre><code>    type Msg =\n        // other messages ...\n        | LoadCustomer of customerId:int // Add this\n        | CustomerLoaded of Customer // Add this\n</code></pre> <p>You will see that this symmetrical pattern is often followed in MVU:</p> <ul> <li>A command to initiate a call to the server for some data (LoadCustomer)</li> <li>An event with the result of calling the command (CustomerLoaded)</li> </ul>"},{"location":"recipes/client-server/mvu-roundtrip/#2-update-the-model","title":"2. Update the Model","text":"<p>Update the Model to store the Customer once it is loaded: <pre><code>type Model =\n    { // ...\n      TheCustomer : Customer option }\n</code></pre></p> <p>Make <code>TheCustomer</code> optional so that it can be initialised as <code>None</code> (see next step).</p>"},{"location":"recipes/client-server/mvu-roundtrip/#3-update-the-init-function","title":"3. Update the Init function","text":"<p>Update the <code>init</code> function to provide default data <pre><code>let model =\n    { // ...\n      TheCustomer = None }\n</code></pre></p>"},{"location":"recipes/client-server/mvu-roundtrip/#4-update-the-view","title":"4. Update the View","text":"<p>Update your view to initiate the <code>LoadCustomer</code> event. Here, we create a button that will start loading customer 42 on click: <pre><code>let view model dispatch =\n    Html.div [\n        // ...\n        Html.button [ \n            prop.onClick (fun _ -&gt; dispatch (LoadCustomer 42))  \n            prop.text \"Load Customer\"\n        ]\n    ]\n</code></pre></p>"},{"location":"recipes/client-server/mvu-roundtrip/#5-handle-the-update","title":"5. Handle the Update","text":"<p>Modify the <code>update</code> function to handle the new messages: <pre><code>let update msg model =\n    match msg with\n    // ....\n    | LoadCustomer customerId -&gt;\n        // Implementation to connect to the server to be defined.\n    | CustomerLoaded c -&gt;\n        { model with TheCustomer = Some c }, Cmd.none\n</code></pre></p> <p>The code to fire off the message to the server differs depending on the client / server communication you are using and normally whether you are reading or writing data. See here for more information.</p>"},{"location":"recipes/client-server/saturn-to-giraffe/","title":"How do I use Giraffe instead of Saturn?","text":"<p>Saturn is a functional alternative to MVC and Razor which sits on top of Giraffe. Giraffe itself is a functional wrapper around the ASP.NET Core web framework, making it easier to work with when using F#.</p> <p>Since Saturn is built on top of Giraffe, migrating to using \"raw\" Giraffe is relatively simple to do.</p>"},{"location":"recipes/client-server/saturn-to-giraffe/#bootstrapping-the-application","title":"Bootstrapping the Application","text":""},{"location":"recipes/client-server/saturn-to-giraffe/#1-open-libraries","title":"1. Open libraries","text":"<p>Navigate to the Server module in the Server project.</p> <p>Remove <pre><code>open Saturn\n</code></pre> and replace it with <pre><code>open Giraffe\nopen Microsoft.AspNetCore.Builder\nopen Microsoft.Extensions.DependencyInjection\nopen Microsoft.Extensions.Hosting\nopen Microsoft.AspNetCore.Hosting\n</code></pre></p>"},{"location":"recipes/client-server/saturn-to-giraffe/#2-replace-application","title":"2. Replace application","text":"<p>In the same module, we need to replace the Server's <code>application</code> computation expression with some functions which set up the default host, configure the application and register services.</p> <p>Remove this</p> <pre><code>let app =\n    application {\n        // ...setup functions\n    }\n\n[&lt;EntryPoint&gt;]\nlet main _ =\n    run app\n    0\n</code></pre> <p>and replace it with this</p> <pre><code>let configureApp (app : IApplicationBuilder) =\n    app\n        .UseFileServer()\n        .UseGiraffe webApp\n\nlet configureServices (services : IServiceCollection) =\n    services\n        .AddGiraffe() |&gt; ignore\n\n[&lt;EntryPoint&gt;]\nlet main _ =\n    Host.CreateDefaultBuilder()\n        .ConfigureWebHostDefaults(\n            fun webHostBuilder -&gt;\n                webHostBuilder\n                    .Configure(configureApp)\n                    .ConfigureServices(configureServices)\n                    .UseWebRoot(\"public\")\n                    |&gt; ignore)\n        .Build()\n        .Run()\n    0\n</code></pre>"},{"location":"recipes/client-server/saturn-to-giraffe/#routing","title":"Routing","text":"<p>If you are using the standard SAFE template, there is nothing more you need to do, as routing is taken care of by Fable Remoting.</p> <p>If however you are using the minimal template, you will need to replace the Saturn router expression with the Giraffe equivalent.</p> <p>Replace this <pre><code>let webApp =\n    router {\n        get Route.hello (json \"Hello from SAFE!\")\n    }\n</code></pre></p> <p>with this <pre><code>let webApp = route Route.hello &gt;=&gt; json \"Hello from SAFE!\"\n</code></pre></p>"},{"location":"recipes/client-server/saturn-to-giraffe/#other-setup","title":"Other setup","text":"<p>The steps shown here are the minimal necessary to get a SAFE app running using Giraffe.</p> <p>As with any Server setup however, there are many more optional parameters that you may wish to configure, such as caching, response compression and serialisation options as seen in the default SAFE templates amongst many others.</p> <p>See the Giraffe and ASP.NET Core host builder, application builder and service collection docs for more information on this.</p>"},{"location":"recipes/client-server/serve-a-file-from-the-backend/","title":"Serve a file from the back-end","text":"<p>In SAFE apps, you can send a file from the server to the client as well as you can send any other type of data.</p>"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#1-define-the-route","title":"1. Define the route","text":"<p>Since the standard template uses Fable.Remoting, we need to edit our API definition first. Find your API type definition in <code>Shared.fs</code>. It's usually the last block of code. The one you see here is named ITodoAPI. Edit this definition to have the <code>download</code> member you see below.</p> <pre><code>type ITodoAPI =\n    { //...other routes \n      download : unit -&gt; Async&lt;byte[]&gt; }\n</code></pre>"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#2-add-the-route","title":"2. Add the route","text":"<p>Open the Server.fs file and find the API that implements the definition we've just edited. It should now have an error since we're not matching the definition at the moment. Add the following route to it</p> <pre><code>//...other functions in todosApi\ndownload =\n    fun () -&gt; async {\n        let byteArray = System.IO.File.ReadAllBytes(\"file.txt\")\n        return byteArray\n    }\n</code></pre> <p>Make sure to replace \"file.txt\" with your file that is placed in <code>src/Server</code> or relative path</p>"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#3-using-the-download-function","title":"3. Using the download function","text":"<p>Since the <code>download</code> function is asynchronous, we can't just call it anywhere in our view. The way we're going to deal with this is to create a <code>Msg</code> case and handle it in our <code>update</code> funciton.</p>"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#a-add-a-couple-of-new-cases-to-the-msg-type","title":"a. Add a couple of new cases to the Msg type","text":"<pre><code>type Msg =\n    //...other cases\n    | DownloadFile\n    | FileDownloaded of byte[]\n</code></pre>"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#b-handle-these-cases-in-the-update-function","title":"b. Handle these cases in the update function","text":"<pre><code>let update (msg: Msg) (model: Model): Model * Cmd&lt;Msg&gt; =\n        match msg with\n    //...other cases\n    | DownloadFile -&gt; model, Cmd.OfAsync.perform todosApi.download () FileDownloaded\n    | FileDownloaded file -&gt;\n        file.SaveFileAs(\"downloaded-file.txt\")\n        model, Cmd.none // You can do something else here\n</code></pre> <p>The <code>SaveFileAs</code> function detects the mime-type/content-type automatically based on the file extension of the file input</p>"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#c-dispatch-this-message-using-a-ui-element","title":"c. Dispatch this message using a UI element","text":"<pre><code>Html.button [\n    prop.onClick (fun _ -&gt; dispatch DownloadFile)\n    prop.text \"Click to download\" \n]\n</code></pre> <p>Having added this last snippet of code into the <code>view</code> function, you will be able to download the file by clicking the button that will now be displayed in your UI. For more information visit the Fable.Remoting documentation</p>"},{"location":"recipes/client-server/server-errors-on-client/","title":"How Do I Handle Server Exceptions on the Client?","text":"<p>SAFE Stack makes it easy to catch and handle exceptions raised by the server on the client.</p>"},{"location":"recipes/client-server/server-errors-on-client/#1-update-the-model","title":"1. Update the Model","text":"<p>Update the model to store the error details that we receive from the server. Find the <code>Model</code> type in <code>src/Client/Index.fs</code> and add it the following <code>Errors</code> field:</p> <pre><code>type Model =\n    { ... // the rest of the fields\n      Errors: string list }\n</code></pre> <p>Now, bind an empty list to the field record inside the <code>init</code> function:</p> <pre><code>let model =\n    { ... // the rest of the fields\n      Errors = [] }\n</code></pre>"},{"location":"recipes/client-server/server-errors-on-client/#2-add-an-error-message-handler","title":"2. Add an Error Message Handler","text":"<p>We now add a new message to handle errors that we get back from the server after making a request. Add the following case to the <code>Msg</code> type:</p> <pre><code>type Msg =\n    | ... // other message cases\n    | GotError of exn\n</code></pre>"},{"location":"recipes/client-server/server-errors-on-client/#3-handle-the-new-message","title":"3. Handle the new Message","text":"<p>In this simple example, we will simply capture the <code>Message</code> of the exception. Add the following line to the end of the pattern match inside the <code>update</code> function:</p> <pre><code>| GotError ex -&gt;\n    { model with Errors = ex.Message :: model.Errors }, Cmd.none\n</code></pre>"},{"location":"recipes/client-server/server-errors-on-client/#4-connect-server-errors-to-elmish","title":"4. Connect Server Errors to Elmish","text":"<p>We now have to connect up the server response to the new message we created. Elmish has support for this through the <code>either</code> Cmd functions (instead of the <code>perform</code> functions). Make the following changes to your server call:</p> <pre><code>let cmd = Cmd.OfAsync.perform todosApi.addTodo todo AddedTodo \n</code></pre> <p>\u2026and replace it with the following:</p> <pre><code>let cmd = Cmd.OfAsync.either todosApi.addTodo todo AddedTodo GotError\n</code></pre>"},{"location":"recipes/client-server/server-errors-on-client/#done","title":"Done!","text":"<p>Now, if you get an exception from the Server, its message will be added to the <code>Errors</code> field of the <code>Model</code> type. Instead of throwing the error, you can now display a meaningful text to the user like so:</p> <p>In the function <code>todoAction</code> in <code>src/Client/Index.fs</code> add the following:</p> <pre><code>Html.button [ \n//other button properties\n]\nfor msg in model.Errors do\n    Html.p msg\n</code></pre>"},{"location":"recipes/client-server/server-errors-on-client/#test","title":"Test","text":"<p>In the <code>todosApi</code> in <code>src/Server/Server.fs</code> replace the <code>addTodo</code> with the following:</p> <pre><code>addTodo =\n    fun todo -&gt; async {\n        failwith \"Something went wrong\"\n        return\n            match Storage.addTodo todo with\n            | Ok() -&gt; todo\n            | Error e -&gt; failwith e\n    }\n</code></pre> <p>and when you try to add a todo then you will see the error message from the server.</p>"},{"location":"recipes/client-server/share-code/","title":"How Do I Share Code Types Between the Client and the Server?","text":"<p>SAFE Stack makes it really simple and easy to share code between the client and the server, since both of them are written in F#. The client side is transpiled into JavaScript by Fable, whilst the server side is compiled down to .NET CIL. Serialization between both happens in the background, so you don't have to worry about it.</p>"},{"location":"recipes/client-server/share-code/#types","title":"Types","text":"<p>Let's say the you have the following type in <code>src/Server/Server.fs</code>: <pre><code>type Customer =\n    { Id : Guid\n      Name : string\n      Email : string\n      PhoneNumber : string }\n</code></pre></p>"},{"location":"recipes/client-server/share-code/#values-and-functions","title":"Values and Functions","text":"<p>And you have the following function that is used to validate this Customer type in <code>src/Client/Index.fs</code>: <pre><code>let customerIsValid customer =\n    (Guid.Empty = customer.Id\n    || String.IsNullOrEmpty customer.Name\n    || String.IsNullOrEmpty customer.Email\n    || String.IsNullOrEmpty customer.PhoneNumber)\n    |&gt; not\n</code></pre></p>"},{"location":"recipes/client-server/share-code/#shared","title":"Shared","text":"<p>If at any point you realise you need to use both the <code>Customer</code> type and the <code>customerIsValid</code> function both in the Client and the Server, all you need to do is to move both of them to <code>Shared</code> project. You can either put them in the <code>Shared.fs</code> file, or create your own file in the Shared project (eg. <code>Customer.fs</code>). After this, you will be able to use both the <code>Customer</code> type and the <code>customerIsValid</code> function in both the Client and the Server.</p>"},{"location":"recipes/client-server/share-code/#serialization","title":"Serialization","text":"<p>SAFE comes out of the box with [Fable.Remoting] or [Thoth] for serialization. These will handle transport of data seamlessly for you.</p>"},{"location":"recipes/client-server/share-code/#considerations","title":"Considerations","text":"<p>Be careful not to place code in <code>Shared.fs</code> that depends on a Client or Server-specific dependency. If your code depends on <code>Fable</code> for example, in most cases it will not be suitable to place it in Shared, since it can only be used in Client. Similarly, if your types rely on .NET specific types in e.g. the framework class library (FCL), beware. Fable has built-in mappings for popular .NET types e.g. <code>System.DateTime</code> and <code>System.Math</code>, but you will have to write your own mappers otherwise.</p>"},{"location":"recipes/client-server/upload-file-from-client/","title":"How do I upload a file from the client?","text":"<p>Fable makes it quick and easy to upload files from the client.</p>"},{"location":"recipes/client-server/upload-file-from-client/#1-create-a-file","title":"1. Create a File","text":"<p>Create a file in the client project named <code>FileUpload.fs</code> somewhere before the <code>Index.fs</code> file and insert the following:</p> <pre><code>module FileUpload\n\nopen Feliz\nopen Fable.Core.JsInterop\n</code></pre>"},{"location":"recipes/client-server/upload-file-from-client/#2-file-event-handler","title":"2. File Event Handler","text":"<p>Then, add the following. The <code>reader.onload</code> block will be executed once we select and confirm a file to be uploaded. Read the FileReader docs to find out more.</p> <pre><code>let handleFileEvent onLoad (fileEvent:Browser.Types.Event) =\n    let files:Browser.Types.FileList = !!fileEvent.target?files\n    if files.length &gt; 0 then\n        let reader = Browser.Dom.FileReader.Create()\n        reader.onload &lt;- (fun _ -&gt; reader.result |&gt; unbox |&gt; onLoad)\n        reader.readAsArrayBuffer(files.[0])\n</code></pre>"},{"location":"recipes/client-server/upload-file-from-client/#3-create-the-ui-element","title":"3. Create the UI Element","text":"<p>Insert the following block of code at the end of <code>FileUpload.fs</code>. This function will create a UI element to be used to upload files.</p> <pre><code>let createFileUpload onLoad =\n    Html.input [ \n        prop.type' \"file\"\n        prop.label \"Choose a file\"\n        prop.onChange (handleFileEvent onLoad)\n    ]\n</code></pre>"},{"location":"recipes/client-server/upload-file-from-client/#4-use-the-ui-element","title":"4. Use the UI Element","text":"<p>Having followed all these steps, you can now use the <code>createFileUpload</code> function in <code>Index.fs</code> to create the UI element for uploading files. </p> <pre><code>FileUpload.createFileUpload (HandleFile &gt;&gt; dispatch)\n</code></pre> <p>One thing to note is that <code>HandleFile</code> is a case of the discriminated union type <code>Msg</code> that's in <code>Index.fs</code>.</p> <pre><code>type Msg =\n    // other messages\n    | HandleFile of Browser.Types.Event\n\nlet update msg model =\n    match msg with\n    //other messages\n    | HandleFile event -&gt;\n    // do what you need with the file\n</code></pre>"},{"location":"recipes/developing-and-testing/debug-safe-app/","title":"How do I debug a SAFE app?","text":""},{"location":"recipes/developing-and-testing/debug-safe-app/#im-using-visual-studio","title":"I'm using Visual Studio","text":"<p>In order to debug Server code from Visual Studio, we need set the correct URLs in the project's debug properties.</p>"},{"location":"recipes/developing-and-testing/debug-safe-app/#debugging-the-server","title":"Debugging the Server","text":""},{"location":"recipes/developing-and-testing/debug-safe-app/#1-configure-launch-settings","title":"1. Configure launch settings","text":"<p>You can do this through the Server project's Properties/Debug editor or by editing the <code>launchSettings.json</code> file in <code>src/Server/Properties</code></p> <p>After selecting the debug profile that you wish to edit (IIS Express or Server), you will need to set the App URL field to <code>http://localhost:5000</code> and Launch browser field to <code>http://localhost:8080</code>. The process is very similar for VS Mac.</p> <p>Once this is done, you can expect your <code>launchSettings.json</code> file to look something like this: <pre><code>{\n  \"iisSettings\": {\n    \"windowsAuthentication\": false,\n    \"anonymousAuthentication\": true,\n    \"iisExpress\": {\n      \"applicationUrl\": \"http://localhost:5000/\",\n      \"sslPort\": 44330\n    }\n  },\n  \"profiles\": {\n    \"IIS Express\": {\n      \"commandName\": \"IISExpress\",\n      \"launchBrowser\": true,\n      \"launchUrl\": \"http://localhost:8080/\",\n      \"environmentVariables\": {\n        \"ASPNETCORE_ENVIRONMENT\": \"Development\"\n      }\n    },\n    \"Server\": {\n      \"commandName\": \"Project\",\n      \"launchBrowser\": true,\n      \"launchUrl\": \"http://localhost:8080\",\n      \"environmentVariables\": {\n        \"ASPNETCORE_ENVIRONMENT\": \"Development\"\n      },\n      \"applicationUrl\": \"http://localhost:5000\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"recipes/developing-and-testing/debug-safe-app/#2-start-the-client","title":"2. Start the Client","text":"<p>Since you will be running the server directly through Visual Studio, you cannot use a FAKE script to start the application. Launch the Client directly by running the following command in <code>src/Client</code></p> <pre><code>dotnet fable watch -o output -s --run npx vite\n</code></pre>"},{"location":"recipes/developing-and-testing/debug-safe-app/#3-debug-the-server","title":"3. Debug the Server","text":"<p>Set the server as your Startup project, either using the drop-down menu at the top of the IDE or by right clicking on the project itself and selecting Set as Startup Project. Select the profile that you set up earlier and wish to launch from the drop-down at the top of the IDE. Either press the Play button at the top of the IDE or hit F5 on your keyboard to start the Server debugging and launch a browser pointing at the website.</p>"},{"location":"recipes/developing-and-testing/debug-safe-app/#debugging-the-client","title":"Debugging the Client","text":"<p>Although we write our client-side code using F#, it is being converted into JavaScript at runtime by Fable and executed in the browser. However, we can still debug it via the magic of source mapping. If you are using Visual Studio, you cannot directly connect to the browser debugger. You can, however, debug your client F# code using the browser's development tools.</p>"},{"location":"recipes/developing-and-testing/debug-safe-app/#1-set-breakpoints-in-client-code","title":"1. Set breakpoints in Client code","text":"<p>The exact instructions will depend on your browser, but essentially it simply involves:</p> <ul> <li>Opening the Developer tools panel (usually by hitting F12).</li> <li>Finding the F# file you want to add breakpoints to in the source of the website.</li> <li>Add breakpoints to it in your browser inspector.</li> </ul>"},{"location":"recipes/developing-and-testing/debug-safe-app/#im-using-vs-code","title":"I'm using VS Code","text":"<p>VS Code allows \"full stack\" debugging i.e. both the client and server. Prerequisites that you should install:</p>"},{"location":"recipes/developing-and-testing/debug-safe-app/#install-prerequisites","title":"Install Prerequisites","text":"<ul> <li>Install either Google Chrome or Microsoft Edge: Enables client-side debugging.</li> <li>Configure your browser with the following extensions:<ul> <li>Redux Dev Tools: Provides improved debugging support in Chrome with Elmish and access to Redux debugging.</li> <li>React Developer Tools: Provides access to React debugging in Chrome.</li> </ul> </li> <li>Configure VS Code with the following extensions:<ul> <li>Ionide: Provides F# support to Code.</li> <li>C#: Provides .NET Core debugging support.</li> </ul> </li> </ul>"},{"location":"recipes/developing-and-testing/debug-safe-app/#debug-the-server","title":"Debug the Server","text":"<ol> <li>Click the debug icon on the left hand side, or hit <code>ctrl+shift+d</code> to open the debug pane.</li> <li>Hit the <code>Run and Debug</code> button</li> <li>In the bar with the play error, where it says \"No Configurations\", use the dropdown to select \".NET 5 and .NET Core\". In the dialog that pops up, select  \"Server.Fsproj: Server\"</li> <li>Hit F5</li> </ol> <p>The server is now running. You can use the bar at the top of your screen to pause, restart or kill the debugger</p>"},{"location":"recipes/developing-and-testing/debug-safe-app/#debug-the-client","title":"Debug the Client","text":"<ol> <li>Start the Client by running <code>dotnet fable watch -o output -s --run npx vite</code> from <code>&lt;repo root&gt;/src/Client/</code>. </li> <li>Open the Command Palettek using <code>ctrl+shift+p</code> and run <code>Debug: Open Link</code>. </li> <li>When prompted for a url, type <code>http://localhost:8080/</code>. This will launch a browser which is pointed at the URL and connect the debugger to it. </li> <li>You can now set breakpoints in your F# code by opening files via the \"Loaded Scrips\" tab in the debugger; setting breakpoints in files opened from disk does NOT work.</li> </ol> <p>If you find that your breakpoints aren't being hit, try stopping the Client, disconnecting the debugger and re-launching them both.</p> <p>To find out more about the VS Code debugger, see here.</p>"},{"location":"recipes/developing-and-testing/specify-app-settings/","title":"How do I add custom application settings?","text":"<p>There are many ways to supply custom application settings e.g. connection strings to your application, and the official ASP .NET documentation explains in great detail the various options you have available.</p>"},{"location":"recipes/developing-and-testing/specify-app-settings/#configuration-of-the-server","title":"Configuration of the Server","text":"<p>In this recipe, we show how to add configuration using an <code>appsettings.json</code> configuration file.</p> <p>Never store secrets in plain text files such as <code>appsettings.json</code> - our recommendation is to use it for non-secret configuration data that is shared across your development team; see here for more guidance.</p> <ol> <li>In the Server folder, add a file <code>appsettings.json</code>. It does not need to be added to the  project file.</li> <li>Add the following content to it: <pre><code>{\n    \"MyKey\": \"My appsettings.json Value\"\n}\n</code></pre></li> <li>In <code>Server.fs</code>, ensure that your API builder functions take in an <code>HTTPContext</code> as an argument and change the construction of your Fable Remoting endpoint to supply one: <pre><code>++open Microsoft.AspNetCore.Http\n\n--let todosApi = {\n++let todosApi (context: HttpContext) = {\n\n...\n\n--    |&gt; Remoting.fromValue todosApi\n++    |&gt; Remoting.fromContext todosApi\n</code></pre></li> <li>Use the <code>context</code> to get a handle to the <code>IConfiguration</code> object, which allows you to access settings regardless of what infrastructure you are using to store them e.g. <code>appsettings.json</code>, environment variables etc. <pre><code>++open Giraffe\n++open Microsoft.Extensions.Configuration\n\nlet todosApi (context: HttpContext) =\n++    let cfg = context.GetService&lt;IConfiguration&gt;()\n++    let value = cfg[\"MyKey\"] // \"My appsettings.json Value\"\n</code></pre> <p>Note that the <code>todosApi</code> function will be called on every single ASP .NET request. It is safe to \"capture\" the <code>cfg</code> value and use it across multiple API methods.</p> </li> </ol>"},{"location":"recipes/developing-and-testing/specify-app-settings/#publishing-settings-files","title":"Publishing settings files","text":"<p>Be aware that <code>appsettings.json</code> files will be included in your bundle by default. However, depending on your application, it can be overridden by e.g. environment variables.</p>"},{"location":"recipes/developing-and-testing/specify-app-settings/#working-with-user-secrets","title":"Working with User Secrets","text":"<p>User Secrets are an alternative way of storing secrets which, although still stored in plain text files, are not stored in your repository folder and therefore less at risk to accidentally committing into source control. However, Saturn currently disables User Secrets as part of its startup routine, and you must manually turn them back on:</p> <pre><code>++type DummyType() = class end\n\nlet app = application {\n++    host_config (fun hostBuilder -&gt;\n++        hostBuilder.ConfigureAppConfiguration(fun _ configBuilder -&gt;\n++            configBuilder.AddUserSecrets&lt;DummyType&gt;()\n++            |&gt; ignore\n++        )\n++    )\n}\n</code></pre> <p>You can then access the <code>IConfiguration</code> as before, and user secrets values will be accessible.</p>"},{"location":"recipes/developing-and-testing/specify-app-settings/#configuration-of-the-client","title":"Configuration of the client","text":"<p>Configuration of the client can be done in many ways, but generally a simple strategy is to have an API endpoint which is called on startup that provides any settings required by the client.</p>"},{"location":"recipes/developing-and-testing/testing-the-client/","title":"How do I test the client?","text":"<p>Testing on the client is a little different than on the server.</p> <p>This is because the code which is ultimately being executed in the browser is JavaScript, translated from F# by Fable, and so it must be tested in a JavaScript environment.</p> <p>Furthermore, code that is shared between the Client and Server must be tested in both a dotnet environment and a JavaScript environment.</p> <p>The SAFE template uses a library called Fable.Mocha which allows us to run the same tests in both environments. It mirrors the Expecto API and works in much the same way.</p>"},{"location":"recipes/developing-and-testing/testing-the-client/#im-using-the-standard-template","title":"I'm using the standard template","text":"<p>If you are using the standard template then there is nothing more you need to do in order to start testing your Client.</p> <p>In the tests/Client folder, there is a project named <code>Client.Tests</code> with a single script demonstrating how to use Mocha to test the TODO sample.</p> <p>Note the compiler directive here which makes sure that the Shared tests are only included when executing in a JavaScript (Fable) context. They are covered by Expecto under dotnet as you can see in <code>Server.Tests.fs</code>.</p>"},{"location":"recipes/developing-and-testing/testing-the-client/#1-launch-the-test-server","title":"1. Launch the test server","text":"<p>In order to run the tests, instead of starting your application using <pre><code>dotnet run\n</code></pre> you should instead use <pre><code>dotnet run WatchRunTests\n</code></pre></p> <p>Prior to template version 5.0.8, the command to run the tests was <code>dotnet run RunTests</code></p>"},{"location":"recipes/developing-and-testing/testing-the-client/#2-view-the-results","title":"2. View the results","text":"<p>Once the build is complete and the website is running, navigate to <code>http://localhost:8081/</code> in a web browser. You should see a test results page that looks like this:</p> <p></p> <p>This command builds and runs the Server test project too. If you want to run the Client tests alone, you can simply launch the test server using <code>npm run test:live</code>, which executes a command stored in <code>package.json</code>.</p>"},{"location":"recipes/developing-and-testing/testing-the-client/#im-using-the-minimal-template","title":"I'm using the minimal template","text":"<p>If you are using the minimal template, you will need to first configure a test project as none are included.</p>"},{"location":"recipes/developing-and-testing/testing-the-client/#1-add-a-test-project","title":"1. Add a test project","text":"<p>Create a <code>.Net</code> library called <code>Client.Tests</code> in the <code>tests/Client</code> subdirectory using the following commands:</p> <pre><code>dotnet new classlib -lang F# -n Client.Tests -o tests/Client\ndotnet sln add tests/Client\n</code></pre>"},{"location":"recipes/developing-and-testing/testing-the-client/#2-reference-the-client-project","title":"2. Reference the Client project","text":"<p>Reference the Client project from the Client.Tests project:</p> <pre><code>dotnet add tests/Client reference src/Client\n</code></pre>"},{"location":"recipes/developing-and-testing/testing-the-client/#3-add-the-fablemocha-package-to-test-project","title":"3. Add the Fable.Mocha package to Test project","text":"<p>Run the following command:</p> <pre><code>dotnet add tests/Client package Fable.Mocha\n</code></pre>"},{"location":"recipes/developing-and-testing/testing-the-client/#4-add-something-to-test","title":"4. Add something to test","text":"<p>Add this function to Client.fs in the Client project</p> <pre><code>let sayHello name = $\"Hello {name}\"\n</code></pre>"},{"location":"recipes/developing-and-testing/testing-the-client/#5-add-a-test","title":"5. Add a test","text":"<p>Replace the contents of <code>tests/Client/Library.fs</code> with the following code:</p> <pre><code>module Tests\n\nopen Fable.Mocha\n\nlet client = testList \"Client\" [\n    testCase \"Hello received\" &lt;| fun _ -&gt;\n        let hello = Client.sayHello \"SAFE V3\"\n\n        Expect.equal hello \"Hello SAFE V3\" \"Unexpected greeting\"\n]\n\nlet all =\n    testList \"All\"\n        [\n            client\n        ]\n\n[&lt;EntryPoint&gt;]\nlet main _ = Mocha.runTests all\n</code></pre>"},{"location":"recipes/developing-and-testing/testing-the-client/#6-add-test-web-page","title":"6. Add Test web page","text":"<p>Add a file called <code>index.html</code> to the tests/Client folder with following contents: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;SAFE Client Tests&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;script type=\"module\" src=\"/output/Library.js\"&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"recipes/developing-and-testing/testing-the-client/#7-add-test-vite-config","title":"7. Add test Vite config","text":"<p>Add a file called <code>vite.config.mts</code> to <code>tests/Client</code>:</p> <pre><code>import { defineConfig } from \"vite\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n    server: {\n        port: 8081\n    }\n});\n</code></pre>"},{"location":"recipes/developing-and-testing/testing-the-client/#8-install-the-clients-dependencies","title":"8. Install the client's dependencies","text":"<pre><code>npm install\n</code></pre>"},{"location":"recipes/developing-and-testing/testing-the-client/#9-launch-the-test-website","title":"9. Launch the test website","text":"<pre><code>cd tests/Client\ndotnet fable watch -o output --run npx vite\n</code></pre> <p>Once the build is complete and the website is running, navigate to <code>http://localhost:8081/</code> in a web browser. You should see a test results page that looks like this:</p> <p></p>"},{"location":"recipes/developing-and-testing/testing-the-server/","title":"How do I test the Server?","text":"<p>Testing your Server code in a SAFE app is just the same as in any other dotnet app, and you can use the same tools and frameworks that you are familiar with. These include all of the usual suspects such as NUnit, XUnit, FSUnit, Expecto, FSCheck, AutoFixture etc.</p> <p>In this guide we will look at using Expecto, as this is included with the standard SAFE template.</p>"},{"location":"recipes/developing-and-testing/testing-the-server/#im-using-the-standard-template","title":"I'm using the standard template","text":""},{"location":"recipes/developing-and-testing/testing-the-server/#using-the-expecto-runner","title":"Using the Expecto runner","text":"<p>If you are using the standard template, then there is nothing more you need to do in order to start testing your Server code.</p> <p>In the tests/Server folder, there is a project named <code>Server.Tests</code> with a single script demonstrating how to use Expecto to test the TODO sample.</p> <p>In order to run the tests, instead of starting your application using <pre><code>dotnet run\n</code></pre></p> <p>you should instead use <pre><code>dotnet run WatchRunTests\n</code></pre></p> <p>Prior to template version 5.0.8, the command to run the tests was <code>dotnet run RunTests</code></p> <p>This will execute the tests and print the results into the console window.</p> <p></p> <p>This method builds and runs the Client test project too, which can be slow. If you want to run the Server tests alone, you can simply navigate to the tests/Server directory and run the project using <code>dotnet run</code>.</p>"},{"location":"recipes/developing-and-testing/testing-the-server/#using-dotnet-test-or-the-visual-studio-test-runner","title":"Using dotnet test or the Visual Studio Test runner","text":"<p>If you would like to use dotnet tests from the command line or the test runner that comes with Visual Studio, there are a couple of extra steps to follow.</p>"},{"location":"recipes/developing-and-testing/testing-the-server/#1-install-the-test-adapters","title":"1. Install the Test Adapters","text":"<p>Run the following commands at the root of your solution: <pre><code>dotnet paket add Microsoft.NET.Test.Sdk -p Server.Tests\n</code></pre> <pre><code>dotnet paket add YoloDev.Expecto.TestSdk -p Server.Tests\n</code></pre></p>"},{"location":"recipes/developing-and-testing/testing-the-server/#2-disable-entrypoint-generation","title":"2. Disable EntryPoint generation","text":"<p>Open your ServerTests.fsproj file and add the following element:</p> <pre><code>&lt;PropertyGroup&gt;\n    &lt;GenerateProgramFile&gt;false&lt;/GenerateProgramFile&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"recipes/developing-and-testing/testing-the-server/#3-discover-tests","title":"3. Discover tests","text":"<p>To allow your tests to be discovered, you will need to decorate them with a <code>[&lt;Tests&gt;]</code> attribute.</p> <p>The provided test would look like this: <pre><code>[&lt;Tests&gt;]\nlet server = testList \"Server\" [\n    testCase \"Adding valid Todo\" &lt;| fun _ -&gt;\n        let storage = Storage()\n        let validTodo = Todo.create \"TODO\"\n        let expectedResult = Ok ()\n\n        let result = storage.AddTodo validTodo\n\n        Expect.equal result expectedResult \"Result should be ok\"\n        Expect.contains (storage.GetTodos()) validTodo \"Storage should contain new todo\"\n]\n</code></pre></p>"},{"location":"recipes/developing-and-testing/testing-the-server/#4-run-tests","title":"4. Run tests","text":"<p>There are now two ways to run these tests.</p> <p>From the command line, you can just run <pre><code>dotnet test tests/Server\n</code></pre> from the root of your solution.</p> <p>Alternatively, if you are using Visual Studio or VS Mac you can make use of the built-in test explorers.</p> <p></p>"},{"location":"recipes/developing-and-testing/testing-the-server/#im-using-the-minimal-template","title":"I'm using the minimal template","text":"<p>If you are using the minimal template, you will need to first configure a test project as none are included.</p>"},{"location":"recipes/developing-and-testing/testing-the-server/#1-add-a-test-project","title":"1. Add a test project","text":"<p>Create a <code>.Net</code> console project called <code>Server.Tests</code> in the tests/Server folder.</p> <pre><code>dotnet new console -lang F# -n Server.Tests -o tests/Server\ndotnet sln add tests/Server\n</code></pre>"},{"location":"recipes/developing-and-testing/testing-the-server/#2-reference-the-server-project","title":"2. Reference the Server project","text":"<p>Reference the Server project from the Server.Tests project:</p> <pre><code>dotnet add tests/Server reference src/Server\n</code></pre>"},{"location":"recipes/developing-and-testing/testing-the-server/#3-add-expecto-to-the-test-project","title":"3. Add Expecto to the Test project","text":"<p>Run the following command:</p> <pre><code>dotnet add tests/Server package Expecto\n</code></pre>"},{"location":"recipes/developing-and-testing/testing-the-server/#4-add-something-to-test","title":"4. Add something to test","text":"<p>Update the Server.fs file in the Server project to extract the message logic from the router like so: <pre><code>let getMessage () = \"Hello from SAFE!\"\n\nlet webApp =\n    router {\n        get Route.hello (getMessage () |&gt; json )\n    }\n</code></pre></p>"},{"location":"recipes/developing-and-testing/testing-the-server/#5-add-a-test","title":"5. Add a test","text":"<p>Replace the contents of <code>tests/Server/Program.fs</code> with the following:</p> <pre><code>open Expecto\n\nlet server = testList \"Server\" [\n    testCase \"Message returned correctly\" &lt;| fun _ -&gt;\n        let expectedResult = \"Hello from SAFE!\"        \n        let result = Server.getMessage()\n        Expect.equal result expectedResult \"Result should be ok\"\n]\n\n[&lt;EntryPoint&gt;]\nlet main _ = runTestsWithCLIArgs [] [||] server\n</code></pre>"},{"location":"recipes/developing-and-testing/testing-the-server/#6-run-the-test","title":"6. Run the test","text":"<pre><code>dotnet run -p tests/Server\n</code></pre> <p>This will print out the results in the console window</p> <p></p>"},{"location":"recipes/developing-and-testing/testing-the-server/#7-using-dotnet-test-or-the-visual-studio-test-explorer","title":"7. Using dotnet test or the Visual Studio Test Explorer","text":"<p>Add the libraries <code>Microsoft.NET.Test.Sdk</code> and <code>YoloDev.Expecto.TestSdk</code> to your Test project, using NuGet.</p> <p>The way you do this will depend on whether you are using NuGet directly or via Paket. See this recipe for more details.</p> <p>You can now add <code>[&lt;Test&gt;]</code> attributes to your tests so that they can be discovered, and then run them using the dotnet tooling in the same way as explained earlier for the standard template.</p>"},{"location":"recipes/javascript/import-js-module/","title":"How do I import a JavaScript module?","text":"<p>Sometimes you need to use a JS library directly, instead of using it through a wrapper library that makes it easy to use from F# code. In this case you need to import a module from the library. Here are the most common import patterns used in JS.</p>"},{"location":"recipes/javascript/import-js-module/#default-export","title":"Default export","text":""},{"location":"recipes/javascript/import-js-module/#setup","title":"Setup","text":"<p>In most cases components use the default export syntax which is when the the component being exported from the module becomes available. For example, if the module being imported below looked something like: <pre><code>// module-name\nconst foo = () =&gt; \"hello\"\n\nexport default foo\n</code></pre> We can use the below syntax to have access to the function <code>foo</code>. <pre><code>import foo from 'module-name' // JS\n</code></pre> <pre><code>let foo = importDefault \"module-name\" // F#\n</code></pre></p>"},{"location":"recipes/javascript/import-js-module/#testing-the-import","title":"Testing the import","text":"<p>To ensure that the import was successful you can console log the value and you should see the value in the browsers console window which you can get to by right-clicking and selecting the Inspect Element. <pre><code>Browser.Dom.console.log(\"imported value\", foo)\n</code></pre></p>"},{"location":"recipes/javascript/import-js-module/#example","title":"Example","text":"<p>An example of this in use is how React is imported <pre><code>import React from \"react\"\n\n// Although in the newer versions of React this is uneeded\n</code></pre></p>"},{"location":"recipes/javascript/import-js-module/#named-export","title":"Named export","text":""},{"location":"recipes/javascript/import-js-module/#setup_1","title":"Setup","text":"<p>In some cases components can use the named export syntax. In the below case \"module-name\" has an object/function/class that is called <code>bar</code>. By referncing it below it is brought into the current scope.  For example, if the module below contained something like: <pre><code>export const bar (x,y) =&gt; x + y \n</code></pre> We can directly access the function with the below syntax  <pre><code>import { bar } from \"module-name\" // JS\n</code></pre> <pre><code>let bar = import \"bar\" \"module-name\" // F#\n</code></pre></p>"},{"location":"recipes/javascript/import-js-module/#testing-the-import_1","title":"Testing the import","text":"<p>To ensure that the import was successful you can console log the value and you should see the value in the browsers console window which you can get to by right-clicking and selecting the Inspect Element. <pre><code>Browser.Dom.console.log(\"imported value\", bar)\n</code></pre></p>"},{"location":"recipes/javascript/import-js-module/#example_1","title":"Example","text":"<p>An example of this is how React hooks are imported <pre><code>import { useState } from \"react\"\n</code></pre></p>"},{"location":"recipes/javascript/import-js-module/#entire-module-contents","title":"Entire module contents","text":"<p>In rare cases you may have to import an entire module's contents and provide an alias in the below case we named it myModule. You can now use dot notation to access anything that is exported from module-name. For example, if the module being imported below includes an export to a function <code>doAllTheAmazingThings()</code> you could access it like: <pre><code>myModule.doAllTheAmazingThings()\n</code></pre> <pre><code>import * as myModule from 'module-name' // JS\n</code></pre> <pre><code>let myModule = importAll \"module-name\" // F#\n</code></pre></p>"},{"location":"recipes/javascript/import-js-module/#testing-the-import_2","title":"Testing the import","text":"<p>To ensure that the import was successful you can console log the value and you should see the value in the browsers console window which you can get to by right-clicking and selecting the Inspect Element. <pre><code>Browser.Dom.console.log(\"imported value\", myModule)\n</code></pre></p>"},{"location":"recipes/javascript/import-js-module/#example_2","title":"Example","text":"<p>An example of this is another way to import React  <pre><code>import * as React from \"react\"\n\n// Uncommon since importDefault is the standard\n</code></pre></p>"},{"location":"recipes/javascript/import-js-module/#more-information","title":"More information","text":"<p>See the Fable docs for more ways to import modules and use JavaScript from Fable.</p>"},{"location":"recipes/javascript/third-party-react-package/","title":"Add Support for a Third Party React Library","text":"<p>To use a third-party React library in a SAFE application, you need to write an F# wrapper around it. There are two ways for doing this - using Feliz or using Fable.React.</p>"},{"location":"recipes/javascript/third-party-react-package/#prerequisites","title":"Prerequisites","text":"<p>This recipe uses the react-d3-speedometer NPM package for demonstration purposes. Add it to your Client before continuing.</p>"},{"location":"recipes/javascript/third-party-react-package/#feliz-setup","title":"Feliz - Setup","text":"<p>If you don't already have Feliz installed, add it to your client. In the Client projects <code>Index.fs</code> add the following snippets</p> <pre><code>open Fable.Core.JsInterop\n</code></pre> <p>Within the view function </p> <pre><code>Feliz.Interop.reactApi.createElement (importDefault \"react-d3-speedometer\", createObj [\n    \"minValue\" ==&gt; 0\n    \"maxValue\" ==&gt; 100\n    \"value\" ==&gt; 10\n])\n</code></pre> <ul> <li><code>createElement</code> from <code>Feliz.ReactApi.IReactApi</code> takes the component you're wrapping react-d3-speedometer, the props that component takes and creates a ReactComponent we can use in F#.</li> <li><code>importDefault</code> from <code>Fable.Core.JsInterop</code> is giving us access to the component and is equivalent to </li> </ul> <pre><code>import ReactSpeedometer from \"react-d3-speedometer\"\n</code></pre> <p>The reason for using <code>importDefault</code> is the documentation for the component uses a default export \"ReactSpeedometer\". Please find a list of common import statetments at the end of this recipe</p> <p>As a quick check to ensure that the library is being imported and we have no typos you can <code>console.log</code> the following at the top within the view function </p> <pre><code>Browser.Dom.console.log(\"REACT-D3-IMPORT\", importDefault \"react-d3-speedometer\")\n</code></pre> <p>In the console window (which can be reached by right-clicking and selecting Insepct Element) you should see some output from the above log.  If nothing is being seen you may need a slightly different import statement, please refer to this recipe.</p> <ul> <li><code>createObj</code> from <code>Fable.Core.JsInterop</code> takes a sequence of <code>string * obj</code> which is a prop name and value for the component, you can find the full prop list for react-d3-speedometer here.</li> <li>Using <code>==&gt;</code> (short hand for <code>prop.custom</code>) to transform the sequence into a JavaScript object </li> </ul> <pre><code>createObj [\n    \"minValue\" ==&gt; 0\n    \"maxValue\" ==&gt; 10\n]\n</code></pre> <p>Is equivalent to </p> <pre><code>{ minValue: 0, maxValue: 10 }\n</code></pre> <p>That's the bare minimum needed to get going!</p>"},{"location":"recipes/javascript/third-party-react-package/#next-steps-for-feliz","title":"Next steps for Feliz","text":"<p>Once your component is working you may want to extract out the logic so that it can be used in multiple pages of your app. For a full detailed tutorial head over to this blog post!</p>"},{"location":"recipes/javascript/third-party-react-package/#fablereact-setup","title":"Fable.React - Setup","text":""},{"location":"recipes/javascript/third-party-react-package/#1-create-a-new-file","title":"1. Create a new file","text":"<p>Create an empty file named <code>ReactSpeedometer.fs</code> in the Client project above <code>Index.fs</code> and insert the following statements at the beginning of the file.</p> <pre><code>module ReactSpeedometer\n\nopen Fable.Core\nopen Fable.Core.JsInterop\nopen Fable.React\n</code></pre>"},{"location":"recipes/javascript/third-party-react-package/#2-define-the-props","title":"2. Define the Props","text":"<p>Prop represents the props of the React component. In this recipe, we're using the props listed here for <code>react-d3-speedometer</code>. We model them in Fable.React using a discriminated union.</p> <pre><code>type Prop =\n    | Value of int\n    | MinValue of int\n    | MaxValue of int \n    | StartColor of string\n</code></pre> <p>One difference to note is that we use PascalCase rather than camelCase.</p> <p>Note that we can model any props here, both simple values and \"event handler\"-style ones.</p>"},{"location":"recipes/javascript/third-party-react-package/#3-write-the-component","title":"3. Write the Component","text":"<p>Add the following function to the file. Note that the last argument passed into the <code>ofImport</code> function is a list of <code>ReactElements</code> to be used as children of the react component. In this case, we are passing an empty list since the component doesn't have children.</p> <pre><code>let reactSpeedometer (props : Prop list) : ReactElement =\n    let propsObject = keyValueList CaseRules.LowerFirst props // converts Props to JS object\n    ofImport \"default\" \"react-d3-speedometer\" propsObject [] // import the default function/object from react-d3-speedometer\n</code></pre>"},{"location":"recipes/javascript/third-party-react-package/#4-use-the-component","title":"4. Use the Component","text":"<p>With all these in place, you can use the React element in your client like so:</p> <pre><code>open ReactSpeedometer\n\nreactSpeedometer [\n    Prop.Value 10 // Since Value is already decalred in HTMLAttr you can use Prop.Value to tell the F# compiler its of type Prop and not HTMLAttr\n    MaxValue 100\n    MinValue 0 \n    StartColor \"red\"\n    ]\n</code></pre>"},{"location":"recipes/package-management/add-npm-package-to-client/","title":"How do I add an NPM package to the Client?","text":"<p>When you want to call a JavaScript library from your Client, it is easy to import and reference it using NPM.</p> <p>Run the following command: <pre><code>npm install name-of-package\n</code></pre></p> <p>This will download the package into the solution's node_modules folder. </p> <p>You will also see a reference to the package in the Client's package.json file:  <pre><code>\"dependencies\": {\n    \"name-of-package\": \"^1.0.0\"\n}\n</code></pre></p>"},{"location":"recipes/package-management/add-nuget-package-to-client/","title":"How do I add a NuGet package to the Client?","text":"<p>Adding packages to the Client project is a very similar process to the Server, with a few key differences:</p> <ul> <li> <p>Any references to the <code>Server</code> directory should be <code>Client</code></p> </li> <li> <p>Client code written in F# is converted into JavaScript using Fable. Because of this, we must be careful to only reference libraries which are Fable compatible.</p> </li> <li> <p>If the NuGet package uses any JS libraries you must install them.   For simplicity, use Femto to sync - if the NuGet package is compatible - or install via NPM manually, if not.</p> </li> </ul> <p>There are lots of great libraries available to choose from.</p>"},{"location":"recipes/package-management/add-nuget-package-to-server/","title":"How do I add a NuGet package to the Server?","text":"<p>You can add NuGet packages to the server to give it more capabilities. You can download a wide variety of packages from the official NuGet site.</p> <p>In this example we will add the FsToolkit ErrorHandling package package.</p>"},{"location":"recipes/package-management/add-nuget-package-to-server/#1-add-the-package","title":"1. Add the package","text":"<p>Navigate to the root directory of your solution and run:</p> <pre><code>dotnet paket add FsToolkit.ErrorHandling -p Server\n</code></pre> <p>This will add an entry to both the solution paket.dependencies file and the Server project's paket.reference file, as well as update the lock file with the updated dependency graph.</p> <p>For a detailed explanation of package management using Paket, visit the official docs.</p>"},{"location":"recipes/package-management/migrate-to-nuget/","title":"How do I migrate to NuGet from Paket?","text":"<p>Note that the minimal template uses NuGet by default. This recipe only applies to the full template.</p> <p>Paket is a fully featured package manager that acts as an alternative to the NuGet package manager commonly used in .NET.</p> <p>It can help you reference libraries from NuGet, Git repositories or Http resources. It also provides precise control over your dependencies, separating direct and transitive references and capturing the exact configuration with each commit. You can find out more at the Paket website.</p> <p>For most use cases, we would recommend sticking with Paket. If, however, you are in a position where you wish to remove it and revert back to the NuGet package manager, you can easily do so with the following steps.</p>"},{"location":"recipes/package-management/migrate-to-nuget/#1-remove-paket-targets-import-from-fsproj-files","title":"1. Remove Paket targets import from .fsproj files","text":"<p>In every project's <code>.fsproj</code> file you will find the following line. Remove it and save.</p> <pre><code>&lt;Import Project=\"..\\..\\.paket\\Paket.Restore.targets\" /&gt;\n</code></pre>"},{"location":"recipes/package-management/migrate-to-nuget/#2-remove-paketdependencies","title":"2. Remove paket.dependencies","text":"<p>You will find this file at the root of your solution. Remove it from your solution if included and then delete it.</p>"},{"location":"recipes/package-management/migrate-to-nuget/#3-add-project-dependencies-via-nuget","title":"3. Add project dependencies via NuGet","text":"<p>Each project directory will contain a <code>paket.references</code> file. This lists all the NuGet packages that the project requires.</p> <p>Inside a new <code>ItemGroup</code> in the project's <code>.fsproj</code> file you will need to add an entry for each of these packages.</p> <pre><code>&lt;ItemGroup&gt;\n  &lt;PackageReference Include=\"Azure.Core\" Version=\"1.24\" /&gt;\n  &lt;PackageReference Include=\"AnotherPackage\" Version=\"2.0.1\" /&gt;\n  &lt;!--...add entry for each package in the references file...--&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <p>You can find the version of each package in the <code>paket.lock</code> file at the root of the solution. The version number is contained in brackets next to the name of the package at the first level of indentation. For example, in this case Azure.Core is version 1.24: </p> <pre><code>Azure.Core (1.24)\n    Microsoft.Bcl.AsyncInterfaces (&gt;= 1.1.1)\n    System.Diagnostics.DiagnosticSource (&gt;= 4.6)\n    System.Memory.Data (&gt;= 1.0.2)\n    System.Numerics.Vectors (&gt;= 4.5)\n    System.Text.Encodings.Web (&gt;= 4.7.2)\n    System.Text.Json (&gt;= 4.7.2)\n    System.Threading.Tasks.Extensions (&gt;= 4.5.4)\n</code></pre>"},{"location":"recipes/package-management/migrate-to-nuget/#4-remove-remaining-paket-files","title":"4. Remove remaining paket files","text":"<p>Once you have added all of your dependencies to the relevant <code>.fsproj</code> files, you can remove the folowing files and folders from your solution.</p> <p>Files: * <code>paket.lock</code> * <code>paket.dependencies</code>  * all of the <code>paket.references</code> files</p> <p>Folders: * <code>.paket</code>  * <code>paket-files</code> </p>"},{"location":"recipes/package-management/migrate-to-nuget/#5-remove-paket-tool","title":"5. Remove paket tool","text":"<p>If you open <code>.config/dotnet-tools.json</code> you will find an entry for paket. Remove it.</p> <p>Alternatively, run </p> <p><pre><code>dotnet tool uninstall paket\n</code></pre> at the root of your solution.</p>"},{"location":"recipes/package-management/migrate-to-paket/","title":"How do I migrate to Paket from NuGet?","text":"<p>Paket is a fully featured package manager that acts as an alternative to the NuGet package manager.</p> <p>It can help you reference libraries from NuGet, Git repositories or Http resources. It also provides precise control over your dependencies, separating direct and transitive references and capturing the exact configuration with each commit. You can find out more at the Paket website.</p> <p>Note that the standard template uses Paket by default. This recipe only applies to the minimal template.</p>"},{"location":"recipes/package-management/migrate-to-paket/#1-install-and-restore-paket","title":"1. Install and restore Paket","text":"<pre><code>dotnet tool install paket\ndotnet tool restore\n</code></pre>"},{"location":"recipes/package-management/migrate-to-paket/#2-run-the-migration","title":"2. Run the Migration","text":"<p>Run this command to move existing NuGet references to Paket from your packages.config or .fsproj file: <pre><code>dotnet paket convert-from-nuget\n</code></pre></p> <p>This will add three files to your solution, all of which should be committed to source control:</p> <ul> <li>paket.dependencies: This will be at the solution root and contains the top level list of dependencies for your project. It is also used to specify any rules such as where they should be downloaded from and which versions etc.</li> <li>paket.lock: This will also be at the solution root and contains the concrete resolution of all direct and transitive dependencies.</li> <li>paket.references: There will be one of these in each project directory. It simply specifies which packages the project requires.</li> </ul> <p>For a more detailed explanation of this process see the official migration guide.</p> <p>In the case where you have added a NuGet project to a solution which is already using paket, run this command with the option <code>--force</code>.</p> <p>If you are working in Visual Studio and wish to see your Paket files in the Solution Explorer, you will need to add both the paket.lock and any paket.references files created in your project directories during the last step to your solution.</p>"},{"location":"recipes/package-management/opt-out-of-meta-packages/","title":"How do I opt out of Meta packages?","text":"<p>By default, projects created using the SAFE template depend on the SAFE.Meta packages. This package provides functionality, but mainly exists to simplify dependency management; a standard SAFE app might very well exist with only two dependencies, being the SAFE.Client and SAFE.Server packages.</p> <p>If your app starts deviating a lot from the standard SAFE app, you might want to uninstall the SAFE.Meta packages, so that you can remove packages it pulls in. This recipe explains how to do so.</p>"},{"location":"recipes/package-management/opt-out-of-meta-packages/#1-add-the-safe-dependencies-explicitly-to-your-safe-app","title":"1. Add the SAFE dependencies explicitly to your SAFE app.","text":"<p>Add the packages that SAFE.Meta relies on as explicit dependencies:</p> <p>Instead of using the snippets here, you can also copy these sections from the SAFE.Meta repository, to make sure you have the most up-to-date versions</p> paket.dependencies<pre><code>  source https://api.nuget.org/v3/index.json\n  framework: net8.0\n  storage: none\n\n  nuget Expecto ~&gt; 9\n\n- nuget SAFE.Server ~&gt; 5\n- nuget SAFE.Client ~&gt; 5\n+ nuget FSharp.Core ~&gt; 8\n+ \n+ nuget Fable.Remoting.Giraffe ~&gt; 5\n+ nuget Saturn ~&gt; 0\n+ \n+ nuget Fable.Core ~&gt; 4\n+ nuget Fable.Elmish ~&gt; 4\n+ nuget Fable.Elmish.React ~&gt; 4\n+ nuget Fable.Elmish.HMR ~&gt; 7\n+ nuget Fable.Mocha ~&gt; 2\n+ nuget Fable.Remoting.Client ~&gt; 7\n+ nuget Fable.SimpleJson\n+ nuget Feliz ~&gt; 2\n\n  nuget Fake.Core.Target ~&gt; 5\n  nuget Fake.IO.FileSystem ~&gt; 5\n  nuget Farmer ~&gt; 1\n</code></pre> src/Client/paket.references<pre><code>- SAFE.Client\n+ FSharp.Core\n+ Fable.Core\n+ Fable.Elmish\n+ Fable.Elmish.React\n+ Fable.Elmish.HMR\n+ Fable.Mocha\n+ Fable.Remoting.Client\n+ Feliz\n+ Fable.SimpleJson\n</code></pre> src/Server/paket.references<pre><code>- Safe.Server\n+ FSharp.Core\n+ Saturn\n+ Fable.Remoting.Giraffe\n</code></pre> <p>And re-install the paket dependencies</p> <pre><code>dotnet paket install\n</code></pre> <p>This will remove the Meta packages from paket.lock, and may, depending on how up-to-date your project is, update any out-of-date packages. </p> paket.lock<pre><code>  ...\n-     SAFE.Client (5.1.1)\n-       Fable.Core (&gt;= 4.5 &lt; 5.0)\n-       Fable.Elmish (&gt;= 4.2 &lt; 5.0)\n-       Fable.Elmish.HMR (&gt;= 7.0 &lt; 8.0)\n-       Fable.Elmish.React (&gt;= 4.0 &lt; 5.0)\n-       Fable.Mocha (&gt;= 2.17 &lt; 3.0)\n-       Fable.Remoting.Client (&gt;= 7.32 &lt; 8.0)\n-       Fable.SimpleJson (&gt;= 3.24)\n-       Feliz (&gt;= 2.9 &lt; 3.0)\n-       FSharp.Core (&gt;= 8.0.403 &lt; 9.0)\n-     SAFE.Server (5.1.1)\n-       Fable.Remoting.Giraffe (&gt;= 5.21 &lt; 6.0)\n-       FSharp.Core (&gt;= 8.0.403 &lt; 9.0)\n-       Saturn (&gt;= 0.17 &lt; 1.0)\n  ...\n</code></pre>"},{"location":"recipes/package-management/opt-out-of-meta-packages/#2-copy-safemeta-functionality-into-your-own-project","title":"2. Copy SAFE.Meta functionality into your own project","text":"<p>If you are using any of the code supplied by the Meta packages, you need to copy the code into your own project:</p> <p>Navigate to the SAFE.Meta repository and copy the following files into your repository:</p> <ul> <li>src/SAFE.Client/SAFE.fs -&gt; src/Client/SAFE.fs</li> <li>src/SAFE.Server/SAFE.fs -&gt; src/Server/SAFE.fs</li> </ul> <p>and update the corresponding project files:</p> Client.fsproj<pre><code>  &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n  &lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;\n      &lt;PropertyGroup&gt;\n          &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;\n          &lt;DefineConstants&gt;FABLE_COMPILER&lt;/DefineConstants&gt;\n      &lt;/PropertyGroup&gt;\n      &lt;ItemGroup&gt;\n          &lt;None Include=\"postcss.config.js\" /&gt;\n          &lt;None Include=\"tailwind.config.js\" /&gt;\n          &lt;None Include=\"index.html\" /&gt;\n          &lt;None Include=\"paket.references\" /&gt;\n+         &lt;Compile Include=\"SAFE.fs\" /&gt;\n          &lt;Compile Include=\"Index.fs\" /&gt;\n          &lt;Compile Include=\"App.fs\" /&gt;\n          &lt;None Include=\"vite.config.mts\" /&gt;\n      &lt;/ItemGroup&gt;\n      &lt;ItemGroup&gt;\n          &lt;ProjectReference Include=\"..\\Shared\\Shared.fsproj\" /&gt;\n      &lt;/ItemGroup&gt;\n      &lt;Import Project=\"..\\..\\.paket\\Paket.Restore.targets\" /&gt;\n  &lt;/Project&gt;\n</code></pre> Server.fsproj<pre><code>  &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n  &lt;Project Sdk=\"Microsoft.NET.Sdk.Web\"&gt;\n    &lt;PropertyGroup&gt;\n      &lt;OutputType&gt;Exe&lt;/OutputType&gt;\n      &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;\n      &lt;AutoGenerateBindingRedirects&gt;true&lt;/AutoGenerateBindingRedirects&gt;\n    &lt;/PropertyGroup&gt;\n    &lt;ItemGroup&gt;\n      &lt;None Include=\"paket.references\" /&gt;\n+     &lt;Compile Include=\"SAFE.fs\" /&gt;\n      &lt;Compile Include=\"Server.fs\" /&gt;\n    &lt;/ItemGroup&gt;\n    &lt;ItemGroup&gt;\n      &lt;ProjectReference Include=\"..\\Shared\\Shared.fsproj\" /&gt;\n    &lt;/ItemGroup&gt;\n    &lt;Import Project=\"..\\..\\.paket\\Paket.Restore.targets\" /&gt;\n  &lt;/Project&gt;\n</code></pre>"},{"location":"recipes/package-management/opt-out-of-meta-packages/#3-use-paket-to-remove-any-redundant-dependencies","title":"3. Use Paket to remove any redundant dependencies","text":"<p>You're now able to remove any dependencies you do not need with Paket.</p> <pre><code>dotnet paket remove &lt;package-name&gt;\n</code></pre>"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/","title":"How do I ensure NPM and NuGet packages stay in sync?","text":"<p>SAFE Stack uses Fable bindings, which are NuGet packages that provide idiomatic and type-safe wrappers around native JavaScript APIs. These bindings often rely on third-party JavaScript libraries distributed via the NPM registry. This leads to the problem of keeping both the NPM package in sync with its corresponding NuGet F# wrapper. Femto is a dotnet CLI tool that solves this issue.</p> <p>For in-depth information about Femto, see Introducing Femto.</p>"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#1-install-femto","title":"1. Install Femto","text":"<p>Navigate to the root folder of the solution and execute the following command: <pre><code>dotnet tool install femto\n</code></pre></p>"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#2-analyse-dependencies","title":"2. Analyse Dependencies","text":"<p>In the root directory, run the following: <pre><code>dotnet femto ./src/Client\n</code></pre></p> <p>alternatively, you can call femto directly from <code>./src/Client</code>:</p> <pre><code>cd ./src/Client\ndotnet femto\n</code></pre> <p>This will give you a report of discrepancies between the NuGet packages and the NPM packages for the project, as well as steps to take in order to resolve them.</p>"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#3-resolve-dependencies","title":"3. Resolve Dependencies","text":"<p>To sync your NPM dependencies with your NuGet dependencies, you can either manually follow the steps returned by step 2, or resolve them automatically using the following command: <pre><code>dotnet femto ./src/Client --resolve\n</code></pre></p>"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#done","title":"Done!","text":"<p>Keeping your NPM dependencies in sync with your NuGet packages is now as easy as repeating step 3. Of course, you can instead repeat the step 2 and resolve packages manually, too.</p>"},{"location":"recipes/patterns/add-dependency-injection/","title":"Use Dependency Injection","text":"<p>This recipe is not a detailed discussion of the pros and cons of Dependency Injection (DI) compared to other patterns. It simply illustrates how to use it within a SAFE Stack application!</p> <ol> <li> <p>Create a class that you wish to inject with a dependency (in this example, we use the built-in <code>IConfiguration</code> type that is included in ASP .NET):</p> <pre><code>open Microsoft.Extensions.Configuration\n\ntype DatabaseRepository(config:IConfiguration) =\n    member _.SaveDataToDb (text:string) =\n        let connectionString = config[\"SqlConnectionString\"]\n        // Connect to SQL using the above connection string etc.\n        Ok 1\n</code></pre> <p>Instead of functions or modules, DI in .NET and F# only works with classes.</p> </li> <li> <p>Register your type with ASP .NET during startup within the <code>application { }</code> block.     <pre><code>++ open Microsoft.Extensions.DependencyInjection\n\n   application {\n       //...\n++     service_config (fun services -&gt; services.AddSingleton&lt;DatabaseRepository&gt;())\n</code></pre></p> <p>This section of the official ASP .NET Core article explain the distinction between different lifetime registrations, such as Singleton and Transient.</p> </li> <li> <p>Ensure that your Fable Remoting API can access the <code>HttpContext</code> type by using the <code>fromContext</code> builder function.     <pre><code>--  |&gt; Remoting.fromValue createFableRemotingApi\n++  |&gt; Remoting.fromContext createFableRemotingApi\n</code></pre></p> </li> <li> <p>Within your Fable Remoting API, use the supplied <code>context</code> to retrieve your dependency:</p> <pre><code>++ open Microsoft.AspNetCore.Http\n\n   let createFableRemotingApi\n++     (context:HttpContext) =\n++     let dbRepository = context.GetService&lt;DatabaseRepository&gt;()\n       // ...\n       // Return the constructed API record value...\n</code></pre> <p>Giraffe provides the <code>GetService&lt;'T&gt;</code> extension to allow you to quickly retrieve a dependency from the <code>HttpContext</code>.</p> <p>This will instruct ASP .NET to get a handle to the <code>DatabaseRepository</code> object; ASP .NET will automatically supply the <code>IConfiguration</code> object to the constructor. Whether a new <code>DatabaseRepository</code> object is constructed on each call depends on the lifetime you have registered it with.</p> </li> </ol> <p>You can have your types depend on other types that you create, as long as they are registering into ASP .NET Core's DI container using methods such as <code>AddSingleton</code> etc.</p>"},{"location":"recipes/patterns/add-dependency-injection/#further-reading","title":"Further Reading","text":"<ul> <li>Official documentation on DI in ASP .NET Core</li> <li>Archived example PR to update the SAFE Template Todo App to use DI</li> </ul>"},{"location":"recipes/storage/use-litedb/","title":"How Do I Use LiteDB?","text":"<p>The default template uses in-memory storage. This recipe will show you how to replace the in-memory storage with LiteDB in the form of LiteDB.FSharp.</p>"},{"location":"recipes/storage/use-litedb/#1-add-litedbfsharp","title":"1. Add LiteDB.FSharp","text":"<p>Add the LiteDB.FSharp NuGet package to the server project.</p>"},{"location":"recipes/storage/use-litedb/#2-create-the-database","title":"2. Create the database","text":"<p>Replace the use of the <code>ResizeArray</code> in the <code>Storage</code> type with a database and collection:</p> <pre><code>open LiteDB.FSharp\nopen LiteDB\n\ntype Storage () =\n    let database =\n        let mapper = FSharpBsonMapper()\n        let connStr = \"Filename=Todo.db;mode=Exclusive\"\n        new LiteDatabase (connStr, mapper)\n    let todos = database.GetCollection&lt;Todo&gt; \"todos\"\n</code></pre> <p>LiteDb is a file-based database, and will create the file if it does not exist automatically.</p> <p>This will create a database file <code>Todo.db</code> in the <code>Server</code> folder. The option <code>mode=Exclusive</code> is added for MacOS support (see this issue).</p> <p>See here for more information on connection string arguments.</p> <p>See the official docs for details on constructor arguments.</p>"},{"location":"recipes/storage/use-litedb/#3-implement-the-rest-of-the-repository","title":"3. Implement the rest of the repository","text":"<p>Replace the implementations of <code>GetTodos</code> and <code>AddTodo</code> as follows:</p> <pre><code>    /// Retrieves all todo items.\n    member _.GetTodos () =\n        todos.FindAll () |&gt; List.ofSeq\n\n    /// Tries to add a todo item to the collection.\n    member _.AddTodo (todo:Todo) =\n        if Todo.isValid todo.Description then\n            todos.Insert todo |&gt; ignore\n            Ok ()\n        else\n            Error \"Invalid todo\"\n</code></pre>"},{"location":"recipes/storage/use-litedb/#4-initialise-the-database","title":"4. Initialise the database","text":"<p>Modify the existing \"priming\" so that it first checks if there are any records in the database before inserting data:</p> <pre><code>if storage.GetTodos() |&gt; Seq.isEmpty then\n    storage.AddTodo(Todo.create \"Create new SAFE project\") |&gt; ignore\n    storage.AddTodo(Todo.create \"Write your app\") |&gt; ignore\n    storage.AddTodo(Todo.create \"Ship it !!!\") |&gt; ignore\n</code></pre>"},{"location":"recipes/storage/use-litedb/#5-make-todo-compatible-with-litedb","title":"5. Make Todo compatible with LiteDb","text":"<p>Add the CLIMutable attribute to the <code>Todo</code> record in <code>Shared.fs</code></p> <pre><code>[&lt;CLIMutable&gt;]\ntype Todo =\n    { Id : Guid\n      Description : string }\n</code></pre> <p>This is required to allow LiteDB to hydrate (read) data into F# records.</p>"},{"location":"recipes/storage/use-litedb/#all-done","title":"All Done!","text":"<ul> <li>Run the application.</li> <li>You will see that a database has been created in the Server folder and that you are presented with the standard TODO list.</li> <li>Add an item and restart the application; observe that your data is still there.</li> </ul>"},{"location":"recipes/storage/use-sqlprovider-ssdt/","title":"Using SQLProvider SQL Server SSDT","text":""},{"location":"recipes/storage/use-sqlprovider-ssdt/#set-up-your-database-server-using-docker","title":"Set up your database Server using Docker","text":"<p>The easiest way to get a database running locally is using Docker. You can find the installer on their website. Once docker is installed, use the following command to spin up a database server</p> <pre><code>docker run -e \"ACCEPT_EULA=Y\" -e \"MSSQL_SA_PASSWORD=&lt;your password&gt;\" -p 1433:1433 -d mcr.microsoft.com/mssql/server:2022-latest\n</code></pre>"},{"location":"recipes/storage/use-sqlprovider-ssdt/#creating-a-safetodo-database-with-azure-data-studio","title":"Creating a \"SafeTodo\" Database with Azure Data Studio","text":""},{"location":"recipes/storage/use-sqlprovider-ssdt/#connecting-to-a-sql-server-instance","title":"Connecting to a SQL Server Instance","text":"<p>1) In the \"Connections\" tab, click the \"New Connection\" button</p> <p></p> <p>2) Enter your connection details, leaving the \"Database\" dropdown set to <code>&lt;Default&gt;</code>.</p> <p></p>"},{"location":"recipes/storage/use-sqlprovider-ssdt/#creating-a-new-safetodo-database","title":"Creating a new \"SafeTodo\" Database","text":"<ul> <li>Right click your server and choose \"New Query\"</li> <li>Execute this script:</li> </ul> <pre><code>USE master\nGO\nIF NOT EXISTS (\n SELECT name\n FROM sys.databases\n WHERE name = N'SafeTodo'\n)\n CREATE DATABASE [SafeTodo];\nGO\nIF SERVERPROPERTY('ProductVersion') &gt; '12'\n ALTER DATABASE [SafeTodo] SET QUERY_STORE=ON;\nGO\n</code></pre> <ul> <li>Right-click the \"Databases\" folder and choose \"Refresh\" to see the new database.</li> </ul> <p>NOTE: Alternatively, if you don't want to manually create the new database, you can install the \"New Database\" extension in Azure Data Studio which gives you a \"New Database\" option when right clicking the \"Databases\" folder.</p>"},{"location":"recipes/storage/use-sqlprovider-ssdt/#create-a-todos-table","title":"Create a \"Todos\" Table","text":"<ul> <li>Right-click on the SafeTodo database and choose \"New Query\"</li> <li>Execute this script: <pre><code>CREATE TABLE [dbo].[Todos]\n(\n  [Id] UNIQUEIDENTIFIER NOT NULL PRIMARY KEY,\n  [Description] NVARCHAR(500) NOT NULL,\n  [IsDone] BIT NOT NULL\n)\n</code></pre></li> </ul>"},{"location":"recipes/storage/use-sqlprovider-ssdt/#creating-an-ssdt-project-sqlproj","title":"Creating an SSDT Project (.sqlproj)","text":"<p>At this point, you should have a SAFE Stack solution and a minimal \"SafeTodo\" SQL Server database with a \"Todos\" table. Next, we will use Azure Data Studio with the \"SQL Database Projects\" extension to create a new SSDT (SQL Server Data Tools) .sqlproj that will live in our SAFE Stack .sln. </p> <p>1) Install the \"SQL Database Projects\" extension.</p> <p>2) Right click the SafeTodo database and choose \"Create Project From Database\" (this option is added by the \"SQL Database Projects\" extension)</p> <p></p> <p>3) Configure a path within your SAFE Stack solution folder and a project name and then click \"Create\". NOTE: If you choose to create an \"ssdt\" subfolder as I did, you will need to manually create this subfolder first.</p> <p></p> <p>4) You should now be able to view your SQL Project by clicking the \"Projects\" tab in Azure Data Studio.</p> <p></p> <p>5) Finally, right click the SafeTodoDB project and select \"Build\". This will create a .dacpac file which we will use in the next step.</p>"},{"location":"recipes/storage/use-sqlprovider-ssdt/#create-a-todorepository-using-the-new-ssdt-provider-in-sqlprovider","title":"Create a TodoRepository Using the new SSDT provider in SQLProvider","text":""},{"location":"recipes/storage/use-sqlprovider-ssdt/#installing-sqlprovider-from-nuget","title":"Installing SQLProvider from NuGet","text":"<p>Install dependencies <code>SqlProvider</code> and <code>Microsoft.Data.SqlClient</code></p> <pre><code>dotnet paket add SqlProvider -p Server\ndotnet paket add Microsoft.Data.SqlClient -p Server\n</code></pre>"},{"location":"recipes/storage/use-sqlprovider-ssdt/#initialize-type-provider","title":"Initialize Type Provider","text":"<p>Next, we will wire up our type provider to generate database types based on the compiled .dacpac file.</p> <p>1) In the Server project, create a new file, <code>Database.fs</code>. (this should be above <code>Server.fs</code>).</p> <pre><code>module Database\nopen FSharp.Data.Sql\n\n[&lt;Literal&gt;]\nlet SsdtPath = __SOURCE_DIRECTORY__ + @\"/../../ssdt/SafeTodoDB/bin/Debug/SafeTodoDB.dacpac\"\n\ntype DB = \n    SqlDataProvider&lt;\n        Common.DatabaseProviderTypes.MSSQLSERVER_SSDT,\n        SsdtPath = SsdtPath,\n        UseOptionTypes = Common.NullableColumnType.OPTION\n    &gt;\n\n//TO RELOAD SCHEMA: 1) uncomment the line below; 2) save; 3) recomment; 4) save again and wait.\n//DB.GetDataContext().``Design Time Commands``.ClearDatabaseSchemaCache\n\nlet createContext (connectionString: string) =\n    DB.GetDataContext(connectionString)\n</code></pre> <p>2) Create <code>TodoRepository.fs</code> below <code>Database.fs</code>.</p> <pre><code>module TodoRepository\nopen FSharp.Data.Sql\nopen Database\nopen Shared\n\n/// Get all todos that have not been marked as \"done\". \nlet getTodos (db: DB.dataContext) = \n    query {\n        for todo in db.Dbo.Todos do\n        where (not todo.IsDone)\n        select \n            { Shared.Todo.Id = todo.Id\n              Shared.Todo.Description = todo.Description }\n    }\n    |&gt; List.executeQueryAsync\n\nlet addTodo (db: DB.dataContext) (todo: Shared.Todo) =\n    async {\n        let t = db.Dbo.Todos.Create()\n        t.Id &lt;- todo.Id\n        t.Description &lt;- todo.Description\n        t.IsDone &lt;- false\n\n        do! db.SubmitUpdatesAsync() |&gt; Async.AwaitTask\n    }\n</code></pre> <p>3) Create <code>TodoController.fs</code> below <code>TodoRepository.fs</code>.</p> <pre><code>module TodoController\nopen Database\nopen Shared\n\nlet getTodos (db: DB.dataContext) = \n    TodoRepository.getTodos db |&gt; Async.AwaitTask\n\nlet addTodo (db: DB.dataContext) (todo: Todo) = \n    async {\n        if Todo.isValid todo.Description then\n            do! TodoRepository.addTodo db todo\n            return todo\n        else \n            return failwith \"Invalid todo\"\n    }\n</code></pre> <p>4) Finally, replace the stubbed todosApi implementation in <code>Server.fs</code> with our type provided implementation.</p> <pre><code>module Server\n\nopen Fable.Remoting.Server\nopen Fable.Remoting.Giraffe\nopen Saturn\nopen System\nopen Shared\nopen Microsoft.AspNetCore.Http\n\nlet todosApi =\n    let db = Database.createContext @\"Data Source=localhost,1433;Database=SafeTodo;User ID=sa;Password=&lt;your password&gt;;TrustServerCertificate=True\"\n    { getTodos = fun () -&gt; TodoController.getTodos db\n      addTodo = TodoController.addTodo db }\n\nlet webApp =\n    Remoting.createApi()\n    |&gt; Remoting.withRouteBuilder Route.builder\n    |&gt; Remoting.fromValue todosApi\n    |&gt; Remoting.withErrorHandler fableRemotingErrorHandler\n    |&gt; Remoting.buildHttpHandler\n\nlet app =\n    application {\n        use_router webApp\n        memory_cache\n        use_static \"public\"\n        use_gzip\n    }\n\nrun app\n</code></pre>"},{"location":"recipes/storage/use-sqlprovider-ssdt/#run-the-app","title":"Run the App!","text":"<p>From the VS Code terminal in the SafeTodo folder, launch the app (server and client):</p> <p><code>dotnet run</code></p> <p>You should now be able to add todos.</p> <p></p>"},{"location":"recipes/storage/use-sqlprovider-ssdt/#deployment","title":"Deployment","text":"<p>When creating a Release build for deployment, it is important to note that SQLProvider SSDT expects that the .dacpac file will be copied to the deployed Server project bin folder. </p> <p>Here are the steps to accomplish this:</p> <p>1) Modify your Server.fsproj to include the .dacpac file with \"CopyToOutputDirectory\" to ensure that the .dacpac file will always exist in the Server project bin folder.</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;None Include=\"..\\{relative path to SSDT project}\\ssdt\\SafeTodo\\bin\\$(Configuration)\\SafeTodoDB.dacpac\" Link=\"SafeTodoDB.dacpac\"&gt;\n        &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;\n    &lt;/None&gt;\n\n    { other files... }\n&lt;/ItemGroup&gt;\n</code></pre> <p>2) In your Server.Database.fs file, you should also modify the SsdtPath binding so that it can build the project in either Debug or Release mode:</p> <pre><code>[&lt;Literal&gt;]\n#if DEBUG\nlet SsdtPath = __SOURCE_DIRECTORY__ + @\"/../../ssdt/SafeTodoDB/bin/Debug/SafeTodoDB.dacpac\"\n#else\nlet SsdtPath = __SOURCE_DIRECTORY__ + @\"/../../ssdt/SafeTodoDB/bin/Release/SafeTodoDB.dacpac\"\n#endif\n</code></pre> <p>NOTE: This assumes that your SSDT .sqlproj will be built in Release mode (you can build it manually, or use a FAKE build script to handle this).</p>"},{"location":"recipes/ui/add-bulma/","title":"How do I add Bulma to a SAFE project?","text":"<p>Bulma is a free open-source UI framework based on flexbox that helps you create modern and responsive layouts.</p> <p>When using Feliz (the standard for a SAFE app), follow the instructions below. When using Fable.React, use the Fulma wrapper for Bulma.</p>"},{"location":"recipes/ui/add-bulma/#1-add-the-felizbulma-nuget-package-to-the-client-project","title":"1. Add the Feliz.Bulma NuGet package to the client project","text":"<pre><code>dotnet paket add Feliz.Bulma -p Client\n</code></pre>"},{"location":"recipes/ui/add-bulma/#2-add-the-bulma-stylesheet-to-indexhtml","title":"2. Add the Bulma stylesheet to <code>index.html</code>","text":"<pre><code> ...\n &lt;head&gt;\n     ...\n+    &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\"&gt;\n &lt;/head&gt;\n ...\n</code></pre>"},{"location":"recipes/ui/add-bulma/#3-start-using-felizbulma-components-in-your-f-files","title":"3. Start using Feliz.Bulma components in your F# files.","text":"<pre><code>open Feliz.Bulma\n\nBulma.button.button [\n   str \"Click me!\"\n]\n</code></pre>"},{"location":"recipes/ui/add-daisyui/","title":"How do I add daisyUI to a SAFE project?","text":"<p>DaisyUI is a component library for Tailwind CSS. To use the library from within F# we will use Feliz.DaisyUI (Github).</p> <ol> <li> <p>Open a terminal at <code>./src/Client</code></p> </li> <li> <p>Add daisyUI JS dependencies using NPM: <code>npm i -D daisyui@latest</code></p> </li> <li> <p>Add Feliz.DaisyUI .NET dependency...</p> <ul> <li>via Paket:  <code>dotnet paket add Feliz.DaisyUI</code></li> <li>via NuGet: <code>dotnet add package Feliz.DaisyUI</code></li> </ul> </li> <li> <p>Update the <code>tailwind.config.js</code> file's <code>module.exports.plugins</code> array; add <code>require(\"daisyui\")</code></p> tailwind.config.js<pre><code>module.exports = {\n    content: [\n        '.index.html',\n        './**/*.fs',\n    ],\n    theme: {\n        extend: {},\n    },\n    plugins: [\n        require('daisyui'),\n    ],\n}\n</code></pre> </li> <li> <p>Open the daisyUI namespace wherever you want to use it.     YourFileHere.fs<pre><code>open Feliz.DaisyUI\n</code></pre></p> </li> <li> <p>Congratulations, now you can use daisyUI components!     Documentation can be found at https://dzoukr.github.io/Feliz.DaisyUI/</p> </li> </ol>"},{"location":"recipes/ui/add-feliz/","title":"How do I add Feliz to a SAFE project?","text":"<p>Feliz is a wrapper for the base React DSL library that emphasises consistency, lightweight formatting, discoverable attributes and full type-safety. The default SAFE Template already uses Feliz.</p>"},{"location":"recipes/ui/add-feliz/#using-feliz","title":"Using Feliz","text":"<ol> <li>Add Feliz to your project</li> </ol> <pre><code>dotnet paket add Feliz -p Client\n</code></pre> <ol> <li>Start using Feliz in your code.</li> </ol> <pre><code>open Feliz\n\nHtml.button [\n    prop.style [ style.marginLeft 5 ]\n    prop.onClick (fun _ -&gt; setCount(count - 1))\n    prop.text \"Decrement\"\n]\n</code></pre>"},{"location":"recipes/ui/add-fontawesome/","title":"How Do I Use FontAwesome?","text":"<p>FontAwesome is the most popular icon set out there and will provide you with a handful of free icons as well as a multitude of premium icons. The standard SAFE template has out-of-the-box support for FontAwesome. You can just start using it in your Client code like so:</p> <p><pre><code>open Feliz\n\nHtml.i [ prop.className \"fas fa-star\" ]\n</code></pre> This will display a solid star icon.</p>"},{"location":"recipes/ui/add-fontawesome/#im-not-using-the-standard-safe-template","title":"I'm not using the standard SAFE template!","text":"<p>If you don't need the full features of Feliz we suggest using <code>Fable.FontAwesome.Free</code>.</p>"},{"location":"recipes/ui/add-fontawesome/#1-the-nuget-package","title":"1. The NuGet Package","text":"<p>Add Fable.FontAwesome.Free NuGet Package to the Client project.</p> <p>See How do I add a Nuget package to the Client?.</p>"},{"location":"recipes/ui/add-fontawesome/#2-the-cdn-link","title":"2. The CDN Link","text":"<p>Open the <code>index.html</code> file and add the following line to the <code>head</code> element: <pre><code>&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css\"&gt;\n</code></pre></p>"},{"location":"recipes/ui/add-fontawesome/#3-code-snippet","title":"3. Code snippet","text":"<pre><code>open Fable.FontAwesome\n\nIcon.icon [\n    Fa.i [ Fa.Solid.Star ] [ ]\n]\n</code></pre>"},{"location":"recipes/ui/add-fontawesome/#all-done","title":"All Done!","text":"<p>Now you can use FontAwesome in your code</p>"},{"location":"recipes/ui/add-routing-with-separate-models/","title":"How do I add routing to a SAFE app with separate model for every page?","text":"<p>If your application has multiple separate components, there is no need to have one big, complex model that manages all the state for all components. In this recipe we separate the information of the todo list out of the main <code>Model</code>, and give the todo list application its own route. We also add a \"Page not found\" page.</p>"},{"location":"recipes/ui/add-routing-with-separate-models/#1-adding-the-feliz-router","title":"1. Adding the Feliz router","text":"<p>Install Feliz.Router in the client project</p> <pre><code>dotnet paket add Feliz.Router -p Client\n</code></pre> <p>To include the router in the Client, open <code>Feliz.Router</code> at the top of Index.fs</p> Index.fs<pre><code>open Feliz.Router\n</code></pre>"},{"location":"recipes/ui/add-routing-with-separate-models/#2-creating-a-module-for-the-todo-list","title":"2. Creating a module for the Todo list","text":"<p>Move the following functions and types to a new <code>TodoList</code> Module in a file <code>TodoList.fs</code>:</p> <ul> <li>Model</li> <li>Msg</li> <li>todosApi</li> <li>init</li> <li>update</li> <li>toDoAction</li> <li>todoList; rename this to view and remove the <code>private</code> access modifier</li> </ul> <p>also open <code>Shared</code>, <code>Fable.Remoting.Client</code>, <code>Elmish</code> and <code>Feliz</code></p> TodoList.fs<pre><code>module TodoList\n\nopen Shared\nopen Fable.Remoting.Client\nopen Elmish\nopen Feliz\n\ntype Model = { Todos: Todo list; Input: string }\n\ntype Msg =\n    | GotTodos of Todo list\n    | SetInput of string\n    | AddTodo\n    | AddedTodo of Todo\n\nlet todosApi =\n    Remoting.createApi ()\n    |&gt; Remoting.withRouteBuilder Route.builder\n    |&gt; Remoting.buildProxy&lt;ITodosApi&gt;\n\nlet init () =\n    let model = { Todos = []; Input = \"\" }\n    let cmd = Cmd.OfAsync.perform todosApi.getTodos () GotTodos\n    model, cmd\n\nlet update msg model =\n    match msg with\n    | GotTodos todos -&gt; { model with Todos = todos }, Cmd.none\n    | SetInput value -&gt; { model with Input = value }, Cmd.none\n    | AddTodo -&gt;\n        let todo = Todo.create model.Input\n\n        let cmd = Cmd.OfAsync.perform todosApi.addTodo todo AddedTodo\n\n        { model with Input = \"\" }, cmd\n    | AddedTodo todo -&gt;\n        {\n            model with\n                Todos = model.Todos @ [ todo ]\n        },\n        Cmd.none\n\nlet private todoAction model dispatch =\n    Html.div [\n        prop.className \"flex flex-col sm:flex-row mt-4 gap-4\"\n        prop.children [\n            Html.input [\n                prop.className\n                    \"shadow appearance-none border rounded w-full py-2 px-3 outline-none focus:ring-2 ring-teal-300 text-grey-darker\"\n                prop.value model.Input\n                prop.placeholder \"What needs to be done?\"\n                prop.autoFocus true\n                prop.onChange (SetInput &gt;&gt; dispatch)\n                prop.onKeyPress (fun ev -&gt;\n                    if ev.key = \"Enter\" then\n                        dispatch AddTodo)\n            ]\n            Html.button [\n                prop.className\n                    \"flex-no-shrink p-2 px-12 rounded bg-teal-600 outline-none focus:ring-2 ring-teal-300 font-bold text-white hover:bg-teal disabled:opacity-30 disabled:cursor-not-allowed\"\n                prop.disabled (Todo.isValid model.Input |&gt; not)\n                prop.onClick (fun _ -&gt; dispatch AddTodo)\n                prop.text \"Add\"\n            ]\n        ]\n    ]\n\nlet view model dispatch =\n    Html.div [\n        prop.className \"bg-white/80 rounded-md shadow-md p-4 w-5/6 lg:w-3/4 lg:max-w-2xl\"\n        prop.children [\n            Html.ol [\n                prop.className \"list-decimal ml-6\"\n                prop.children [\n                    for todo in model.Todos do\n                        Html.li [ prop.className \"my-1\"; prop.text todo.Description ]\n                ]\n            ]\n\n            todoAction model dispatch\n        ]\n    ]\n</code></pre>"},{"location":"recipes/ui/add-routing-with-separate-models/#3-adding-a-new-model-to-the-index-page","title":"3. Adding a new Model to the Index page","text":"<p>Create a new Model in the <code>Index</code> module, to keep track of the open page</p> Index.fs<pre><code>type Page =\n    | TodoList of TodoList.Model\n    | NotFound \n\ntype Model = { CurrentPage: Page }\n</code></pre>"},{"location":"recipes/ui/add-routing-with-separate-models/#4-updating-the-todolist-model","title":"4. Updating the TodoList model","text":"<p>Add a <code>Msg</code> type with a case of <code>TodoList.Msg</code></p> Index.fs<pre><code>type Msg =\n    | TodoListMsg of TodoList.Msg\n</code></pre> <p>Create an <code>update</code> function (we moved the original one to <code>TodoList</code>). Handle the <code>TodoListMsg</code> by updating the <code>TodoList</code> Model. Wrap the command returned by the <code>update</code> of the todo list in a <code>TodoListMsg</code> before returning it. We expand this function later with other cases that deal with navigation.</p> Index.fs<pre><code>let update message model =\n    match model.CurrentPage, message with\n    | TodoList todoList, TodoListMsg todoListMessage -&gt;\n        let newTodoListModel, todoCommand = TodoList.update todoListMessage todoList\n\n        let model = {\n            model with\n                CurrentPage = TodoList newTodoListModel\n        }\n\n        model, todoCommand |&gt; Cmd.map TodoListMsg\n</code></pre>"},{"location":"recipes/ui/add-routing-with-separate-models/#5-initializing-from-url","title":"5. Initializing from URL","text":"<p>Create a function <code>initFromUrl</code>; initialize the <code>TodoList</code> app when given the URL of the todo list app. Also return the command that TodoList's <code>init</code> may return, wrapped in a <code>TodoListMsg</code></p> Index.fs<pre><code>let initFromUrl url =\n    match url with\n    | [ \"todo\" ] -&gt;\n        let todoListModel, todoListMsg = TodoList.init ()\n        let model = { CurrentPage = TodoList todoListModel }\n\n        model, todoListMsg |&gt; Cmd.map TodoListMsg\n</code></pre> <p>Add a wildcard, so any URLs that are not registered display the \"not found\" page</p> CodeDiff Index.fs<pre><code>let initFromUrl url =\n    match url with\n    ...\n    | _ -&gt; { CurrentPage = NotFound }, Cmd.none\n</code></pre> Index.fs<pre><code> let initFromUrl url =\n     match url with\n     ...\n+    | _ -&gt; { CurrentPage = NotFound }, Cmd.none\n</code></pre>"},{"location":"recipes/ui/add-routing-with-separate-models/#6-elmish-initialization","title":"6. Elmish initialization","text":"<p>Add an <code>init</code> function to <code>Index</code>; return the current page based on <code>Router.currentUrl</code></p> Index.fs<pre><code>let init () =\n    Router.currentUrl ()\n    |&gt; initFromUrl\n</code></pre>"},{"location":"recipes/ui/add-routing-with-separate-models/#7-handling-url-changes","title":"7. Handling URL Changes","text":"<p>Add an <code>UrlChanged</code> case of <code>string list</code> to the <code>Msg</code> type</p> CodeDiff Index.fs<pre><code>type Msg =\n    ...\n    | UrlChanged of string list\n</code></pre> Index.fs<pre><code> type Msg =\n     ...\n+    | UrlChanged of string list\n</code></pre> <p>Handle the case in the <code>update</code> function by calling <code>initFromUrl</code></p> CodeDiff Index.fs<pre><code>let update message model =\n    ...\n    match model.CurrentPage, message with\n    | _, UrlChanged url -&gt; initFromUrl url\n</code></pre> Index.fs<pre><code> let update message model =\n     ...\n+    match model.CurrentPage, message with\n+    | _, UrlChanged url -&gt; initFromUrl url\n</code></pre>"},{"location":"recipes/ui/add-routing-with-separate-models/#8-catching-all-cases-in-the-update-function","title":"8. Catching all cases in the update function","text":"<p>Complete the pattern match in the <code>update</code> function, adding a case with a wildcard for both <code>message</code> and <code>model</code>. Return the model, and no command</p> CodeDiff Index.fs<pre><code>let update message model =\n    ...\n    | _, _ -&gt; model, Cmd.none\n</code></pre> Index.fs<pre><code> let update message model =\n     ...\n+    | _, _ -&gt; model, Cmd.none\n</code></pre>"},{"location":"recipes/ui/add-routing-with-separate-models/#9-rendering-pages","title":"9. Rendering pages","text":"<p>Add a function pageContent to the <code>Index</code> module. If the CurrentPage is of <code>TodoList</code>, render the todo list using <code>TodoList.view</code>; in order to dispatch a <code>TodoList.Msg</code>, it needs to be wrapped in a <code>TodoListMsg</code>.</p> <p>For the <code>NotFound</code> page, return a \"Page not found\" box</p> Index.fs<pre><code>let pageContent model dispatch =\n    match model.CurrentPage with\n    | TodoList todoListModel -&gt; TodoList.view todoListModel (TodoListMsg &gt;&gt; dispatch)\n    | NotFound -&gt; Html.text \"Page not found\"\n</code></pre> <p>In the view function, replace the call to <code>todoList</code> with a call to <code>pageContent</code></p> CodeDiff Index.fs<pre><code>let view model dispatch =\n    ...\n    pageContent model dispatch\n    ...\n</code></pre> Index.fs<pre><code> let view model dispatch =\n     ...\n-     todoList model dispatch\n+     pageContent model dispatch\n     ...\n</code></pre>"},{"location":"recipes/ui/add-routing-with-separate-models/#10-adding-the-react-router-to-the-view","title":"10. Adding the React router to the view","text":"<p>Wrap the content of the view function in a <code>router.children</code> property of a <code>React.router</code>. Also add an <code>onUrlChanged</code> property, that dispatches the 'UrlChanged' message.</p> CodeDiff Index.fs<pre><code>let view model dispatch =\n    React.router [\n        router.onUrlChanged (UrlChanged &gt;&gt; dispatch)\n        router.children [\n            Html.section [\n            ...\n            ]\n        ]\n    ]\n</code></pre> Index.fs<pre><code> let view model dispatch =\n+    React.router [\n+        router.onUrlChanged (UrlChanged &gt;&gt; dispatch)\n+        router.children [\n             Html.section [\n             ...\n             ]\n+        ]\n+    ]\n</code></pre>"},{"location":"recipes/ui/add-routing-with-separate-models/#11-running-the-app","title":"11. Running the app","text":"<p>The routing should work now. Try navigating to localhost:8080; you should see a page with \"Page not Found\". If you go to localhost:8080/#/todo, you should see the todo app.</p> <p># sign</p> <p>You might be surprised to see the hash sign as part of the URL. It enables React to react to URL changes without a full page refresh. There are ways to omit this, but getting this to work properly is outside of the scope of this recipe.</p>"},{"location":"recipes/ui/add-routing/","title":"How do I add routing to a SAFE app with a shared model for all pages?","text":"<p>When building larger apps, you probably want different pages to be accessible through different URLs. In this recipe, we show you how to add routes to different pages to an application, including adding a \"page not found\" page that is displayed when an unknown URL is entered.</p> <p>In this recipe we use the simplest approach to storing states for multiple pages, by creating a single state for the full app. A potential benefit of this approach is that the state of a page is not lost when navigating away from it. You will see how that works at the end of the recipe.</p>"},{"location":"recipes/ui/add-routing/#1-adding-the-feliz-router","title":"1. Adding the Feliz router","text":"<p>Install Feliz.Router in the client project</p> <pre><code>dotnet paket add Feliz.Router -p Client\n</code></pre> <p>To include the router in the Client, open <code>Feliz.Router</code> at the top of Index.fs</p> <pre><code>open Feliz.Router\n</code></pre>"},{"location":"recipes/ui/add-routing/#2-adding-the-url-object","title":"2. Adding the URL object","text":"<p>Add the current page to the model of the client, using a new <code>Page</code> type</p> CodeDiff <pre><code>type Page =\n    | TodoList\n    | NotFound\n\ntype Model =\n    { CurrentPage: Page\n      Todos: Todo list\n      Input: string }\n</code></pre> <pre><code>+ type Page =\n+     | TodoList\n+     | NotFound\n+\n- type Model = { Todos: Todo list; Input: string }\n+ type Model =\n+    { CurrentPage: Page\n+      Todos: Todo list\n+      Input: string }\n</code></pre>"},{"location":"recipes/ui/add-routing/#3-parsing-urls","title":"3.  Parsing URLs","text":"<p>Create a function to parse a URL to a page, including a wildcard for unmapped pages</p> <pre><code>let parseUrl url = \n    match url with\n    | [\"todo\"] -&gt; Page.TodoList\n    | _ -&gt; Page.NotFound\n</code></pre>"},{"location":"recipes/ui/add-routing/#4-initialization-when-using-a-url","title":"4. Initialization when using a URL","text":"<p>On initialization, set the current page</p> CodeDiff <pre><code>let init () : Model * Cmd&lt;Msg&gt; =\n    let page = Router.currentUrl () |&gt; parseUrl\n\n    let model =\n        { CurrentPage = page\n          Todos = []\n          Input = \"\" }\n    ...\n    model, cmd\n</code></pre> <pre><code>  let init () : Model * Cmd&lt;Msg&gt; =\n+     let page = Router.currentUrl () |&gt; parseUrl\n+\n-      let model = { Todos = []; Input = \"\" }\n+      let model =\n+        { CurrentPage = page\n+         Todos = []\n+         Input = \"\" }\n      ...\n      model, cmd\n</code></pre>"},{"location":"recipes/ui/add-routing/#5-updating-the-url","title":"5. Updating the URL","text":"<p>Add an action to handle navigation.</p> <p>To the <code>Msg</code> type, add a <code>PageChanged</code> case of <code>Page</code></p> CodeDiff <pre><code>type Msg =\n    ...\n    | PageChanged of Page\n</code></pre> <pre><code> type Msg =\n     ...\n+    | PageChanged of Page\n</code></pre> <p>Add the <code>PageChanged</code> update action</p> CodeDiff <pre><code>let update (msg: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n    match msg with\n    ...\n    | PageChanged page -&gt; { model with CurrentPage = page }, Cmd.none\n</code></pre> <pre><code>  let update (msg: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n      match msg with\n      ...\n+     | PageChanged page -&gt; { model with CurrentPage = page }, Cmd.none\n</code></pre>"},{"location":"recipes/ui/add-routing/#6-displaying-the-correct-content","title":"6. Displaying the correct content","text":"<p>Rename the <code>view</code> function to <code>todoView</code></p> CodeDiff <pre><code>let todoView model dispatch =\n    Html.section [\n    ...\n    ]\n</code></pre> <pre><code>- let view model dispatch =\n+ let todoView model dispatch =\n      Html.section [\n      ...\n      ]\n</code></pre> <p>Add a new view function, that returns the appropriate page</p> <pre><code>let view model dispatch =\n    match model.CurrentPage with\n    | TodoList -&gt; todoView model dispatch\n    | NotFound -&gt;\n        Html.div [\n            prop.className \"flex flex-col items-center justify-center h-full\"\n            prop.text \"Page not found\"\n        ]\n</code></pre> <p>Adding UI elements to every page of the website</p> <p>In this recipe, we moved all the page content to the <code>todoView</code>, but you don't have to. You can add UI you want to display on every page of the application to the <code>view</code> function.</p>"},{"location":"recipes/ui/add-routing/#7-adding-the-react-router-to-the-view","title":"7. Adding the React router to the view","text":"<p>Add the <code>React.Router</code> element as the outermost element of the view. Dispatch the PageChanged event on <code>onUrlChanged</code></p> CodeDiff <pre><code>let view (model: Model) (dispatch: Msg -&gt; unit) =\n    React.router [\n        router.onUrlChanged (parseUrl &gt;&gt; PageChanged &gt;&gt; dispatch)\n        router.children [\n            match model.CurrentPage with\n            ...\n        ]\n    ]\n</code></pre> <pre><code>  let view (model: Model) (dispatch: Msg -&gt; unit) =\n+     React.router [\n+         router.onUrlChanged (parseUrl &gt;&gt; PageChanged &gt;&gt; dispatch)\n          router.children [\n              match model.CurrentPage with\n              ...\n          ]\n      ]\n</code></pre>"},{"location":"recipes/ui/add-routing/#9-try-it-out","title":"9.  Try it out","text":"<p>The routing should work now. Try navigating to localhost:8080; you should see a page with \"Page not Found\". If you go to localhost:8080/#/todo, you should see the todo app.</p> <p>To see how the state is maintained even when navigating away from the page, type something in the text box and move away from the page by entering another path in the address bar. Then go back to the todo page. The entered text is still there.</p> <p># sign</p> <p>You might be surprised to see the hash sign as part of the URL. It enables React to react to URL changes without a full page refresh. There are ways to omit this, but getting this to work properly is outside of the scope of this recipe.</p>"},{"location":"recipes/ui/add-routing/#10-adding-more-pages","title":"10. Adding more pages","text":"<p>Now that you have set up the routing, adding more pages is simple: add a new case to the <code>Page</code> type; add a route for this page in the <code>parseUrl</code> function; add a function that takes a model and dispatcher to generate your new page, and add a new case to the pattern match inside the <code>view</code> function to display the new case.</p>"},{"location":"recipes/ui/add-shadcn/","title":"How do I add shadcn to a SAFE project?","text":"<p>Note: The SAFE.Template has recently been updated to move <code>package.json</code> and <code>package-lock.json</code>. If you are using a version of the template prior to this change, you will need to move those files into the <code>src/Client</code> directory. For reference, here is the PR detailing this change.</p> <p>Integrating Feliz.Shadcn into your SAFE Stack application is straightforward. The following example demonstrates how to integrate Shadcn copmonents within an existing SAFE app.</p> <p>We will be using the Feliz.Shadcn wrapper written by reaptor</p>"},{"location":"recipes/ui/add-shadcn/#1-setup-tailwind","title":"1. Setup Tailwind","text":"<p>Note: When you use the SAFE template you will already have Tailwind installed by default. You can skip this step.</p> <p>Check out the following recipe here to install Tailwind: Add Tailwind</p>"},{"location":"recipes/ui/add-shadcn/#2-configure-import-alias-in-tsconfig","title":"2. Configure import alias in tsconfig:","text":"<p>Create a file named <code>tsconfig.json</code> in <code>/src/Client</code> and add the following:</p> <pre><code>{\n    \"files\": [],\n    \"compilerOptions\": {\n        \"baseUrl\": \".\",\n        \"paths\": {\n            \"@/*\": [\n                \"./*\"\n            ]\n        }\n    }\n}\n</code></pre>"},{"location":"recipes/ui/add-shadcn/#3-update-the-viteconfigmts-within-srcclient","title":"3. Update the <code>vite.config.mts</code> within <code>/src/Client</code>","text":"<p>Add the <code>resolve</code> property below under the <code>defineConfig</code></p> <pre><code>export default defineConfig({\n    ...\n    resolve: {\n        alias: {\n            \"@\": path.resolve(__dirname),\n        },\n    },\n    ...\n});\n</code></pre>"},{"location":"recipes/ui/add-shadcn/#4-install-shadcnui","title":"4. Install shadcn/ui","text":"<p>Note: ensure your node version is &gt; 20.5.0</p> <p>Inside the <code>/src/Client</code> directory run: <pre><code>npx shadcn@latest init\n</code></pre></p> <p>You will be asked a few questions to configure components.json</p>"},{"location":"recipes/ui/add-shadcn/#5-add-felizshadcn","title":"5. Add Feliz.Shadcn","text":"<p>Inside the <code>/src/Client</code> directory run: <pre><code>dotnet add package Feliz.Shadcn\n</code></pre></p>"},{"location":"recipes/ui/add-shadcn/#6-start-adding-any-shadcn-component","title":"6. Start adding any shadcn component","text":"<p>Specify first which components you want to use. You can find the list of available components here:</p> <p>Inside the <code>/src/Client</code> directory run: <pre><code>npx shadcn@latest add button\n</code></pre></p>"},{"location":"recipes/ui/add-shadcn/#7-use-it-in-feliz","title":"7. Use it in Feliz:","text":"<pre><code>open Feliz.Shadcn\n\n\nlet view =\n    Shadcn.button [\n        prop.text \"Button\" ]\n</code></pre> <p>Congratulations, now you can use shadcn components! Further documentation can be found at https://reaptor.github.io/Feliz.Shadcn/</p>"},{"location":"recipes/ui/add-style/","title":"How do I use stylesheets with SAFE?","text":"<p>The default way to add extra styles is to add them using Tailwind classes. If you wish to use your own CSS stylesheets with SAFE apps, Vite can bundle them up for you.</p> <p>There are two different approaches to adding your own CSS file, depending on what files you have available.</p>"},{"location":"recipes/ui/add-style/#method-a-import-into-indexcss","title":"Method A: Import into <code>index.css</code>","text":"<p>The default template includes a stylesheet at  <code>src/Client/index.css</code> which contains references to Tailwind. The cleanest way to add your own stylesheet is to create a new file e.g. <code>src/Client/custom-style.css</code> and then reference it from <code>index.css</code>.</p> <ol> <li>Create your custom css file in <code>src/Client</code>, e.g. <code>custom-style.css</code></li> <li>Import it into <code>index.css</code> <pre><code>+@import \"./custom-style.css\";\n @tailwind base;\n @tailwind components;\n @tailwind utilities;\n</code></pre></li> </ol>"},{"location":"recipes/ui/add-style/#method-b-import-without-indexcss","title":"Method B: Import without <code>index.css</code>","text":"<p>In order for Vite to know that there are styles to be bundled, you must import them into your app. By default this is already configured for <code>index.css</code> but if you don't have it set up, not to worry! Follow these steps:</p> <ol> <li>Create your custom css file in <code>src/Client</code>, e.g. <code>custom-style.css</code></li> <li>Direct Fable to emit an import for your style file.<ul> <li>Add the following to <code>App.fs</code>:     <pre><code>open Fable.Core.JsInterop\nimportSideEffects \"./custom-style.css\"\n</code></pre></li> </ul> </li> </ol>"},{"location":"recipes/ui/add-style/#there-you-have-it","title":"There you have it!","text":"<p>You can now style your app by writing to the <code>custom-style.css</code> file.</p>"},{"location":"recipes/ui/add-tailwind/","title":"How do I add Tailwind to a SAFE project?","text":"<p>Tailwind is a utility-first CSS framework which can be composed to build any design, directly in your markup.</p> <p>As of SAFE version 5 (released in December 2023) it is included in the template by default so it can be used straight away.</p> <p>If you are are using the minimal template or if you are upgrading from an old version of SAFE, continue reading for installation instructions.</p> <ol> <li> <p>Add a stylesheet to the project</p> </li> <li> <p>Install the required npm packages     <pre><code>npm install -D tailwindcss postcss autoprefixer\n</code></pre></p> </li> <li>Initialise a <code>tailwind.config.js</code> <pre><code>npx tailwindcss init\n</code></pre></li> <li> <p>Amend the <code>tailwind.config.js</code> as follows     <pre><code>/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  mode: \"jit\",\n  content: [\n    \"./index.html\",\n    \"./**/*.{fs,js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n</code></pre></p> </li> <li> <p>Create a <code>postcss.config.js</code> with the following     <pre><code>module.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  }\n}\n</code></pre></p> </li> <li> <p>Add the Tailwind layers to your stylesheet     <pre><code>@tailwind base;\n@tailwind components;\n@tailwind utilities;\n</code></pre></p> </li> <li> <p>Start using tailwind classes e.g.     <pre><code>for todo in model.Todos do\n    Html.li [\n        prop.classes [ \"text-red-200\" ]\n        prop.text todo.Description\n    ]\n</code></pre></p> </li> </ol>"},{"location":"recipes/ui/cdn-to-npm/","title":"How do I migrate from a CDN stylesheet to an NPM package?","text":""},{"location":"recipes/ui/cdn-to-npm/#often-referencing-a-stylesheet-from-a-cdn-is-all-thats-needed-to-add-new-styles-but-you-can-use-an-npm-package-instead","title":"Often, referencing a stylesheet from a CDN is all that's needed to add new styles but you can use an NPM package instead.","text":""},{"location":"recipes/ui/cdn-to-npm/#1-remove-the-cdn-reference","title":"1. Remove the CDN Reference","text":"<p>Remove the CDN reference from the index template in <code>src/Client/index.html</code>: <pre><code>&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\"&gt;\n</code></pre></p>"},{"location":"recipes/ui/cdn-to-npm/#2-add-the-npm-package","title":"2. Add the NPM Package","text":"<p>Add styles from NPM. How do I add an NPM package to the client? In this example we will add the Bulma NPM package.</p>"},{"location":"recipes/ui/cdn-to-npm/#3-add-a-reference-to-your-stylesheet","title":"3. Add a reference to your stylesheet","text":"<ol> <li>Add a stylesheet to your project using this recipe. Add a scss file instead of a css file.</li> <li>Add the following lines to your scss file:     <pre><code>// Set variables to affect Bulma styles\n$body-color: #c6538c;\n@import 'bulma/bulma.sass';\n</code></pre></li> </ol>"},{"location":"recipes/ui/remove-tailwind/","title":"Remove Tailwind support","text":"<p>By default, a full SAFE-stack application uses Tailwind CSS for styling. You might not always want to manage your styling using Tailwind, for example because you want to use a CSS framework like Bulma. In this recipe we describe how to fully remove Tailwind</p>"},{"location":"recipes/ui/remove-tailwind/#1-remove-tailwind-css-classes","title":"1. Remove Tailwind css classes","text":"<p>Tailwind uses classes to style UI elements. In <code>src/Client</code>, search for all occurrences of <code>prop.className</code> and <code>prop.classes</code> and remove them if they are used for Tailwind support. In a vanilla SAFE template installation, this means removing all occurrences of <code>prop.className</code>.</p>"},{"location":"recipes/ui/remove-tailwind/#2-uninstall-npm-packages","title":"2. Uninstall NPM packages","text":"<p>Remove NPM packages that were installed for Tailwind using</p> <pre><code> npm uninstall tailwindcss postcss autoprefixer\n</code></pre>"},{"location":"recipes/ui/remove-tailwind/#3-remove-configuration-files","title":"3. Remove configuration files","text":"<p>Remove the following files:</p> <pre><code>src/Client/postcss.config.js\nsrc/Client/tailwind.config.js\nsrc/Client/index.css\n</code></pre> <p>Your SAFE Stack app is now Tailwind-free.</p>"},{"location":"recipes/ui/routing-with-elmish/","title":"How do I create multi-page applications with routing and the useElmish hook?","text":"<p>UseElmish is a powerful package that allows you to write standalone components using Elmish. A component built around the <code>UseElmish</code> hook has its own view, state and update function.</p> <p>In this recipe we add routing to a safe app, and implement the todo list page using the <code>UseElmish</code> hook.</p>"},{"location":"recipes/ui/routing-with-elmish/#1-installing-dependencies","title":"1. Installing dependencies","text":"<p>Install Feliz.Router in the Client project</p> <pre><code>dotnet paket add Feliz.Router -p Client\n</code></pre> <p>Install Feliz.UseElmish in the Client project</p> <pre><code>cd src/Client\ndotnet femto install Feliz.UseElmish\n</code></pre> <p>Open the router in the client project</p> Index.fs<pre><code>open Feliz.Router\n</code></pre>"},{"location":"recipes/ui/routing-with-elmish/#2-extracting-the-todo-list-module","title":"2. Extracting the todo list module","text":"<p>Create a new Module <code>TodoList</code> in the client project. Move the following functions and types to the TodoList Module:</p> <ul> <li>Model</li> <li>Msg</li> <li>todosApi</li> <li>init</li> <li>todoAction</li> <li>todoList</li> </ul> <p>Also open <code>Shared</code>, <code>Fable.Remoting.Client</code>, <code>Elmish</code> and <code>Feliz</code>. </p> TodoList.fs<pre><code>module TodoList\n\nopen Shared\nopen Fable.Remoting.Client\nopen Elmish\n\nopen Feliz\n\ntype Model = { Todos: Todo list; Input: string }\n\ntype Msg =\n    | GotTodos of Todo list\n    | SetInput of string\n    | AddTodo\n    | AddedTodo of Todo\n\nlet todosApi =\n    Remoting.createApi ()\n    |&gt; Remoting.withRouteBuilder Route.builder\n    |&gt; Remoting.buildProxy&lt;ITodosApi&gt;\n\nlet init () =\n    let model = { Todos = []; Input = \"\" }\n    let cmd = Cmd.OfAsync.perform todosApi.getTodos () GotTodos\n    model, cmd\n\nlet update msg model =\n    match msg with\n    | GotTodos todos -&gt; { model with Todos = todos }, Cmd.none\n    | SetInput value -&gt; { model with Input = value }, Cmd.none\n    | AddTodo -&gt;\n        let todo = Todo.create model.Input\n\n        let cmd = Cmd.OfAsync.perform todosApi.addTodo todo AddedTodo\n\n        { model with Input = \"\" }, cmd\n    | AddedTodo todo -&gt;\n        {\n            model with\n                Todos = model.Todos @ [ todo ]\n        },\n        Cmd.none\n\nlet private todoAction model dispatch =\n    Html.div [\n        prop.className \"flex flex-col sm:flex-row mt-4 gap-4\"\n        prop.children [\n            Html.input [\n                prop.className\n                    \"shadow appearance-none border rounded w-full py-2 px-3 outline-none focus:ring-2 ring-teal-300 text-grey-darker\"\n                prop.value model.Input\n                prop.placeholder \"What needs to be done?\"\n                prop.autoFocus true\n                prop.onChange (SetInput &gt;&gt; dispatch)\n                prop.onKeyPress (fun ev -&gt;\n                    if ev.key = \"Enter\" then\n                        dispatch AddTodo)\n            ]\n            Html.button [\n                prop.className\n                    \"flex-no-shrink p-2 px-12 rounded bg-teal-600 outline-none focus:ring-2 ring-teal-300 font-bold text-white hover:bg-teal disabled:opacity-30 disabled:cursor-not-allowed\"\n                prop.disabled (Todo.isValid model.Input |&gt; not)\n                prop.onClick (fun _ -&gt; dispatch AddTodo)\n                prop.text \"Add\"\n            ]\n        ]\n    ]\n\n[&lt;ReactComponent&gt;]\nlet todoList model dispatch =\n    Html.div [\n        prop.className \"bg-white/80 rounded-md shadow-md p-4 w-5/6 lg:w-3/4 lg:max-w-2xl\"\n        prop.children [\n            Html.ol [\n                prop.className \"list-decimal ml-6\"\n                prop.children [\n                    for todo in model.Todos do\n                        Html.li [ prop.className \"my-1\"; prop.text todo.Description ]\n                ]\n            ]\n\n            todoAction model dispatch\n        ]\n    ]\n</code></pre>"},{"location":"recipes/ui/routing-with-elmish/#4-add-the-useelmish-hook-to-the-todolist-view-function","title":"4. Add the UseElmish hook to the TodoList view function","text":"<p>open Feliz.UseElmish in the TodoList Module</p> TodoList.fs<pre><code>open Feliz.UseElmish\n...\n</code></pre> <p>In the todoList module, rename the function <code>todoList</code> to <code>view</code>, and remove the <code>private</code> access modifier. On the first line, call <code>React.useElmish</code>, passing it the <code>init</code> and <code>update</code> functions. Bind the output to <code>model</code> and <code>dispatch</code></p> CodeDiff TodoList.fs<pre><code>let view model dispatch =\n    let model, dispatch = React.useElmish (init, update, [||])\n    ...\n</code></pre> TodoList.fs<pre><code>-let containerBox model dispatch =\n+let view model dispatch =\n+    let model, dispatch = React.useElmish (init, update, [||])\n    ...\n</code></pre> <p>Replace the arguments of the function with unit, and add the <code>ReactComponent</code> attribute to it</p> CodeDiff Index.fs<pre><code>[&lt;ReactComponent&gt;]\nlet view () =\n    ...\n</code></pre> Index.fs<pre><code>+ [&lt;ReactComponent&gt;]\n- let view model dispatch =\n+ let view () =\n      ...\n</code></pre>"},{"location":"recipes/ui/routing-with-elmish/#5-add-a-new-model-to-the-index-module","title":"5. Add a new model to the Index module","text":"<p>In the <code>Index module</code>, create a model that holds the current page</p> Index.fs<pre><code>type Page =\n    | TodoList\n    | NotFound\n\ntype Model =\n    { CurrentPage: Page }\n</code></pre>"},{"location":"recipes/ui/routing-with-elmish/#6-initializing-the-application","title":"6. Initializing the application","text":"<p>Create a function that initializes the app based on an url</p> Index.fs<pre><code>let initFromUrl url =\n    match url with\n    | [ \"todo\" ] -&gt;\n        let model = { CurrentPage = TodoList }\n\n        model, Cmd.none\n    | _ -&gt;\n        let model = { CurrentPage = NotFound }\n\n        model, Cmd.none\n</code></pre> <p>Create a new <code>init</code> function, that fetches the current url, and calls initFromUrl. </p> Index.fs<pre><code>let init () = Router.currentUrl () |&gt; initFromUrl\n</code></pre>"},{"location":"recipes/ui/routing-with-elmish/#7-updating-the-page","title":"7. Updating the Page","text":"<p>Add a <code>Msg</code> type, with an PageChanged case</p> <p>Index.fs<pre><code>type Msg = \n    | PageChanged of string list\n</code></pre> Add an <code>update</code> function, that reinitializes the app based on an URL</p> Index.fs<pre><code>let update msg model =\n    match msg with\n    | PageChanged url -&gt; initFromUrl url\n</code></pre>"},{"location":"recipes/ui/routing-with-elmish/#8-displaying-pages","title":"8. Displaying pages","text":"<p>Add a pageContent function to the <code>Index</code> module, that returns the appropriate page content</p> Index.fs<pre><code>let pageContent model =\n    match model.CurrentPage with\n    | NotFound -&gt; Html.text \"Page not found\"\n    | TodoList -&gt; TodoList.view ()\n</code></pre> <p>In the <code>view</code> function, replace the call to <code>todoList</code> with a call to <code>pageContent</code></p> CodeDiff Index.fs<pre><code>let view model dispatch =\n    Html.section [\n        ...\n        pageContent model\n        ...\n    ]\n</code></pre> Index.fs<pre><code> let view model dispatch =\n     Html.section [\n     ...\n -   todoList view model\n +   pageContent model\n     ...\n     ]\n</code></pre>"},{"location":"recipes/ui/routing-with-elmish/#9-add-the-router-to-the-view","title":"9. Add the router to the view","text":"<p>Wrap the content of the view method in a <code>React.Router</code> element's router.children property, and add a <code>router.onUrlChanged</code> property to dispatch the urlChanged message</p> CodeDiff Index.fs<pre><code>let view model dispatch =\n    React.router [\n        router.onUrlChanged ( PageChanged&gt;&gt;dispatch )\n        router.children [\n            Html.section [\n            ...\n            ]\n        ]\n    ]\n</code></pre> Index.fs<pre><code>let view (model: Model) (dispatch: Msg -&gt; unit) =\n+   React.router [\n+       router.onUrlChanged ( PageChanged&gt;&gt;dispatch )\n+       router.children [\n            Html.section [\n            ...\n            ]\n+       ]\n+   ]\n</code></pre>"},{"location":"recipes/ui/routing-with-elmish/#10-try-it-out","title":"10.  Try it out","text":"<p>The routing should work now. Try navigating to localhost:8080; you should see a page with \"Page not Found\". If you go to localhost:8080/#/todo, you should see the todo app.</p> <p># sign</p> <p>You might be surprised to see the hash sign as part of the URL. It enables React to react to URL changes without a full page refresh. There are ways to omit this, but getting this to work properly is outside of the scope of this recipe.</p>"},{"location":"recipes/upgrading/v2-to-v3/","title":"How do I upgrade from SAFE v2 to v3?","text":"<p>There have been a number of changes between the second and third major versions of the SAFE template. This guide shows you how to upgrade your v2 project to v3.</p> <p>If you haven't done so already then you will need to install the prequisites listed in the Quick Start guide.</p>"},{"location":"recipes/upgrading/v2-to-v3/#terminology-for-this-recipe","title":"Terminology for this Recipe:","text":"<ul> <li>\"Overwrite\": Take the file from the \"new\" V3 template and copy it over the equivalent file in your existing project.</li> <li>\"Delete\": Delete the file from your existing project. It is no longer required.</li> <li>\"Add\": Add the file to your existing project. It is a new file added in V3.</li> </ul>"},{"location":"recipes/upgrading/v2-to-v3/#1-install-the-v3-template","title":"1. Install the v3 template","text":"<p>Download and install the latest SAFE Stack V3 template by running the following command:</p> <pre><code>dotnet new install SAFE.Template::3.1.1\n</code></pre>"},{"location":"recipes/upgrading/v2-to-v3/#2-create-a-v3-project","title":"2. Create a v3 project","text":"<p>Create a new SAFE project in the <code>safetemp</code> folder. We will use this as a basis for our conversion.</p> <pre><code>dotnet new SAFE -o safetemp\n</code></pre>"},{"location":"recipes/upgrading/v2-to-v3/#3-branch-your-code","title":"3. Branch your code","text":"<p>We advise committing or stashing any unsaved changes to your code and making a new branch to perform the upgrade.</p> <p>You can then test it in isolation and then safely merge back in.</p>"},{"location":"recipes/upgrading/v2-to-v3/#4-update-dotnet-tools","title":"4. Update dotnet tools","text":"<p>This file lists any custom dotnet tools used.</p> <ul> <li>Overwrite the <code>.config/dotnet-tools.json</code> file.</li> </ul> <p>Important! If you have installed extra dotnet tools, you will need to add them back in manually.</p>"},{"location":"recipes/upgrading/v2-to-v3/#5-update-globaljson","title":"5. Update global.json","text":"<ul> <li>Overwrite the <code>global.json</code> file</li> </ul>"},{"location":"recipes/upgrading/v2-to-v3/#6-update-paket-dependencies","title":"6. Update Paket dependencies","text":"<ul> <li>Overwrite the <code>paket.dependencies</code> file in the root of the solution.</li> <li>Overwrite the <code>paket.lock</code> file.</li> <li>Overwrite all <code>paket.references</code> files.</li> </ul> <p>Important If you have installed extra NuGet packages, you will need to add them back in manually to the dependencies and references files.</p> <p>Run paket to update project references:</p> <pre><code>dotnet paket install\n</code></pre> <ul> <li>If you have added any extra NuGet packages, this command will also generate a new <code>paket.lock</code> file.</li> </ul>"},{"location":"recipes/upgrading/v2-to-v3/#7-update-the-npm-dependancies","title":"7. Update the npm dependancies","text":"<ul> <li>Overwite the <code>package.json</code> file</li> <li>Overwite the <code>package-lock.json</code> file</li> </ul> <p>Important If you have installed extra npm packages, you will need to add them back in manually to the dependencies.</p>"},{"location":"recipes/upgrading/v2-to-v3/#8-update-gitignore","title":"8. Update .gitignore","text":"<ul> <li>Overwite the <code>.gitignore</code> file in the root of the solution</li> </ul>"},{"location":"recipes/upgrading/v2-to-v3/#9-update-the-build-process","title":"9. Update the build process","text":"<ul> <li>Delete the <code>build.fsx</code> FAKE script.</li> <li>Add the <code>Build.fs</code> file</li> <li>Add the <code>Helpers.fs</code> file</li> <li>Add the <code>Build.fsproj</code> project</li> <li>Add the <code>paket.references</code> file (the one directly under the root directory)</li> <li>Add the build project to the solution by running   <pre><code>dotnet sln add Build.fsproj\n</code></pre></li> </ul> <p>Important If you have made any modifications to the build script e.g. extra targets, you will need to add them back in manually. You will also need to add any packages you added for the build to the paket.references file.</p>"},{"location":"recipes/upgrading/v2-to-v3/#10-update-the-webpack-config","title":"10. Update the webpack config","text":"<ul> <li>Overwrite the <code>webpack.config.js</code> file.</li> <li>Overwrite the <code>webpack.tests.config.js</code> file</li> </ul> <p>Important If you have made any modifications to the webpack file, you will need to apply them back in manually.</p> <ul> <li>If you were using CSS files, make sure to follow the Stylesheet recipe to add them back in.</li> </ul>"},{"location":"recipes/upgrading/v2-to-v3/#11-update-targetframework-in-all-projects","title":"11. Update TargetFramework in all projects","text":"<ul> <li>Overwite the <code>Client.fsproj</code></li> <li>Overwite the <code>Server.fsproj</code></li> <li>Overwite the <code>Shared.fsproj</code></li> </ul>"},{"location":"recipes/upgrading/v2-to-v3/#12-check-that-it-runs","title":"12. Check that it runs","text":"<p>Run <pre><code>dotnet run\n</code></pre> at the root of the solution to launch the app and check everything is working as expected.</p> <p>If you have problems loading your website, carefully check that you haven't missed out any JavaScript or NuGet packages when overwriting the paket and package files. The console output will usually give you a good guide if this is the case.</p>"},{"location":"recipes/upgrading/v3-to-v4/","title":"How do I upgrade from SAFE v3 to v4?","text":"<p>This guide shows you how to upgrade your v3 project to v4.</p> <p>If you haven't done so already then you will need to install the prequisites listed in the Quick Start guide.</p>"},{"location":"recipes/upgrading/v3-to-v4/#terminology-for-this-recipe","title":"Terminology for this Recipe:","text":"<ul> <li>\"Overwrite\": Take the file from the \"new\" V4 template and copy it over the equivalent file in your existing project.</li> <li>\"Delete\": Delete the file from your existing project. It is no longer required.</li> <li>\"Add\": Add the file to your existing project. It is a new file added in V4.</li> </ul>"},{"location":"recipes/upgrading/v3-to-v4/#1-install-the-v4-template","title":"1. Install the v4 template","text":"<p>Download and install the latest SAFE Stack V3 template by running the following command:</p> <pre><code>dotnet new install SAFE.Template\n</code></pre>"},{"location":"recipes/upgrading/v3-to-v4/#2-create-a-v4-project","title":"2. Create a v4 project","text":"<p>Create a new SAFE project in the <code>safetemp</code> folder. We will use this as a basis for our conversion.</p> <pre><code>dotnet new SAFE -o safetemp\n</code></pre>"},{"location":"recipes/upgrading/v3-to-v4/#3-branch-your-code","title":"3. Branch your code","text":"<p>We advise committing or stashing any unsaved changes to your code and making a new branch to perform the upgrade.</p> <p>You can then test it in isolation and then safely merge back in.</p>"},{"location":"recipes/upgrading/v3-to-v4/#4-update-dotnet-tools","title":"4. Update dotnet tools","text":"<p>This file lists any custom dotnet tools used.</p> <ul> <li>Overwrite the <code>.config/dotnet-tools.json</code> file.</li> </ul> <p>Important! If you have installed extra dotnet tools, you will need to add them back in manually.</p>"},{"location":"recipes/upgrading/v3-to-v4/#5-update-globaljson","title":"5. Update global.json","text":"<ul> <li>Overwrite the <code>global.json</code> file</li> </ul>"},{"location":"recipes/upgrading/v3-to-v4/#6-update-paket-dependencies","title":"6. Update Paket dependencies","text":"<ul> <li>Overwrite the <code>paket.dependencies</code> file in the root of the solution.</li> <li>Overwrite the <code>paket.lock</code> file.</li> <li>Overwrite all <code>paket.references</code> files.</li> </ul> <p>Important If you have installed extra NuGet packages, you will need to add them back in manually to the dependencies and references files.</p> <p>Run paket to update project references:</p> <pre><code>dotnet paket install\n</code></pre> <ul> <li>If you have added any extra NuGet packages, this command will also generate a new <code>paket.lock</code> file.</li> </ul>"},{"location":"recipes/upgrading/v3-to-v4/#7-update-the-npm-dependancies","title":"7. Update the npm dependancies","text":"<ul> <li>Overwite the <code>package.json</code> file</li> <li>Overwite the <code>package-lock.json</code> file</li> </ul> <p>Important If you have installed extra npm packages, you will need to add them back in manually to the dependencies.</p>"},{"location":"recipes/upgrading/v3-to-v4/#8-update-gitignore","title":"8. Update .gitignore","text":"<ul> <li>Overwite the <code>.gitignore</code> file in the root of the solution</li> </ul>"},{"location":"recipes/upgrading/v3-to-v4/#9-update-the-build-process","title":"9. Update the build process","text":"<ul> <li>Overwite the <code>Build.fs</code> file</li> <li>Overwite the <code>Build.fsproj</code> file</li> </ul> <p>Important If you have made any modifications to the build script e.g. extra targets, you will need to add them back in manually.</p>"},{"location":"recipes/upgrading/v3-to-v4/#10-update-the-webpack-config","title":"10. Update the webpack config","text":"<ul> <li>Overwrite the <code>webpack.config.js</code> file.</li> <li>Delete the <code>webpack.tests.config.js</code> file</li> </ul> <p>Important If you have made any modifications to the webpack file, you will need to apply them back in manually.</p>"},{"location":"recipes/upgrading/v3-to-v4/#11-update-targetframework-in-all-projects","title":"11. Update TargetFramework in all projects","text":"<ul> <li>Update the <code>Client.Tests.fsproj</code> file</li> <li>Update the <code>Server.Tests.fsproj</code> file</li> <li>Update the <code>Shared.Tests.fsproj</code> file</li> <li>Update the <code>Client.fsproj</code> file</li> <li>Update the <code>Server.fsproj</code> file</li> <li>Update the <code>Shared.fsproj</code> file</li> </ul> <p>For all of the above, change <code>&lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;</code> to <code>&lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;</code></p>"},{"location":"recipes/upgrading/v3-to-v4/#12-update-the-launch-settings","title":"12. Update the launch settings","text":"<ul> <li>Overwite the <code>Server/Properties/launch.json</code> file</li> </ul>"},{"location":"recipes/upgrading/v3-to-v4/#13-check-that-it-runs","title":"13. Check that it runs","text":"<p>Run <pre><code>dotnet run\n</code></pre> at the root of the solution to launch the app and check everything is working as expected.</p> <p>If you have problems loading your website, carefully check that you haven't missed out any JavaScript or NuGet packages when overwriting the paket and package files. The console output will usually give you a good guide if this is the case.</p>"},{"location":"recipes/upgrading/v3-to-v4/#issues","title":"Issues","text":"<p>On mac you might get an error like this:</p> <pre><code>&gt; dotnet run\ndotnet watch \ud83d\ude80 Started\n/Users/espen/code/dotnet-new-safe-4.1.1/.paket/Paket.Restore.targets(219,5): error MSB3073: The command \"dotnet paket restore --project \"/Users/espen/code/dotnet-new-safe-4.1.1/src/Shared/Shared.fsproj\" --output-path \"obj\" --target-framework \"net6.0\"\" exited with code 134. [/Users/espen/code/dotnet-new-safe-4.1.1/src/Shared/Shared.fsproj]\n\nThe build failed. Fix the build errors and run again.\ndotnet watch \u274c Exited with error code 1\ndotnet watch \u23f3 Waiting for a file to change before restarting dotnet...\n^Cdotnet watch \ud83d\uded1 Shutdown requested. Press Ctrl+C again to force exit.\n</code></pre> <p>If so, try uninstalling all .NET SDKs and runtimes below 3.0.100. See NET uninstall tool for how to unistall SDKs on mac.</p>"},{"location":"recipes/upgrading/v4-to-v5/","title":"How do I upgrade from SAFE v4 to v5?","text":""},{"location":"recipes/upgrading/v4-to-v5/#f-tools-and-dependencies","title":"F# tools and dependencies","text":"<ol> <li> <p>Get the latest dotnet tools such as Fable and Fantomas into your repository.</p> <ol> <li>Overwrite your <code>dotnet-tools.json</code> file from here.</li> <li>Ensure tools have been downloaded to your machine with <code>dotnet tool restore</code>.</li> </ol> </li> <li> <p>Use our preferred F# formatting style.</p> <ol> <li>Overwrite your <code>.editorconfig</code> file from here.</li> </ol> </li> <li> <p>Migrate all dependencies to .NET 8.</p> <ol> <li> <p>Overwrite your <code>global.json</code> file from here.</p> </li> <li> <p>Update each of your project files to target .NET 8.</p> <pre><code>&lt;PropertyGroup&gt;\n    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;\n&lt;/PropertyGroup&gt;\n</code></pre> </li> <li> <p>Upgrade all .NET dependencies to the latest versions for SAFE v5:</p> <ol> <li>Run <code>dotnet paket remove Fable.React -p Client</code>.</li> <li>Run <code>dotnet paket remove Feliz.Bulma -p Client</code>.</li> <li>Overwrite your <code>paket.dependencies</code> file from here.</li> <li>Overwrite your <code>paket.lock</code> file from here.</li> <li>Overwrite your Shared project's <code>paket.references</code> file from here.</li> <li>Run <code>dotnet paket install</code> to update the Shared project.</li> <li>Manually re-add any custom dependencies that you previously had in any projects (Client, Server or Shared etc.):<ol> <li><code>cd</code> into the required project.</li> <li><code>dotnet paket add &lt;package&gt; --keep-minor</code>. This will download the latest version of the package you required but will not update any associated dependencies outside of their existing major version.</li> </ol> </li> </ol> </li> </ol> </li> </ol>"},{"location":"recipes/upgrading/v4-to-v5/#javascript-tools-and-dependencies","title":"Javascript tools and dependencies","text":"<ol> <li>Update all dependencies.<ol> <li>Replace <code>package.json</code> with this file.</li> <li>Replace <code>package-lock.json</code> with this file.</li> <li>Install Node v18 or v20 and NPM v9 or v10.</li> <li>Re-add any NPM packages that you previously had.</li> </ol> </li> <li>Migrate from webpack to vite.<ol> <li>Delete <code>webpack.config.js</code></li> <li>Add the <code>src/Client/vite.config.mts</code> file from here.</li> </ol> </li> </ol>"},{"location":"recipes/upgrading/v4-to-v5/#styling-configuration","title":"Styling configuration","text":"<ol> <li> <p>Install Tailwind.</p> <ol> <li>Run <code>npx tailwindcss init -p</code> in <code>src/Client</code></li> <li>Add the <code>src/Client/tailwind.config.js</code> file from here.</li> <li>Add the <code>src/Client/index.css</code> file from here.</li> </ol> </li> <li> <p>Update HTML and F# code.</p> <ol> <li>Overwrite <code>src/Client/index.html</code> with this file.</li> <li>Add the following lines at the top of <code>src/Client/App.fs</code>, after the existing open declarations     <pre><code>open Fable.Core.JsInterop\n\nimportSideEffects \"./index.css\"\n</code></pre></li> </ol> </li> </ol>"},{"location":"recipes/upgrading/v4-to-v5/#automated-tests","title":"Automated tests","text":"<ol> <li>Add the file <code>tests/Client/vite.config.mts</code> from here.</li> <li>Overwrite the <code>tests/Client/index.html</code> file from here.</li> <li>Add the file <code>.fantomasignore</code> from here.</li> </ol>"},{"location":"recipes/upgrading/v4-to-v5/#automated-build","title":"Automated build","text":"<ol> <li> <p>In the <code>Build.fs</code> file replace the following lines:</p> <p>Line 27:</p> <pre><code>- \"client\", dotnet [ \"fable\"; \"-o\"; \"output\"; \"-s\"; \"--run\"; \"npm\"; \"run\"; \"build\" ] clientPath ]\n+ \"client\", dotnet [ \"fable\"; \"-o\"; \"output\"; \"-s\"; \"--run\"; \"npx\"; \"vite\"; \"build\" ] clientPath ]\n</code></pre> <p>Line 35:</p> <pre><code>- operating_system OS.Windows\n- runtime_stack Runtime.DotNet60\n+ operating_system OS.Linux\n+ runtime_stack (DotNet \"8.0\")\n</code></pre> <p>Line 51:</p> <pre><code>- \"client\", dotnet [ \"fable\"; \"watch\"; \"-o\"; \"output\"; \"-s\"; \"--run\"; \"npm\"; \"run\"; \"start\" ] clientPath ]\n+ \"client\", dotnet [ \"fable\"; \"watch\"; \"-o\"; \"output\"; \"-s\"; \"--run\"; \"npx\"; \"vite\" ] clientPath ]\n</code></pre> <p>Line 58:</p> <pre><code>- \"client\", dotnet [ \"fable\"; \"watch\"; \"-o\"; \"output\"; \"-s\"; \"--run\"; \"npm\"; \"run\"; \"test:live\" ] clientTestsPath ]\n+ \"client\", dotnet [ \"fable\"; \"watch\"; \"-o\"; \"output\"; \"-s\"; \"--run\"; \"npx\"; \"vite\" ] clientTestsPath ]\n</code></pre> <p>Note: If you are using a template created prior to version v4.3, you may have the following string syntax for the <code>dotnet</code> commands and therefore the change you need to make will be slightly different.</p> <pre><code>- \"client\", dotnet \"fable -o output -s --run npm run build\" clientPath\n+ \"client\", dotnet \"fable -o output -s --run npx vite build\" clientPath\n</code></pre> </li> </ol>"},{"location":"recipes/upgrading/v4-to-v5/#additional-resources","title":"Additional resources","text":"<ol> <li>VSCode Tailwind intellisense.<ol> <li>Install the <code>Tailwind CSS Intellisense</code> extension.</li> <li>Create the <code>.vscode/settings.json</code> file from here. The regexes in this file are for Feliz style DSL, if you want to support Fable.React DSL you will need to adapt the regexes.</li> </ol> </li> </ol>"},{"location":"v4-recipes/build/add-build-script/","title":"How do I add build automation to the project?","text":""},{"location":"v4-recipes/build/add-build-script/#fake","title":"FAKE","text":"<p>Fake is a DSL for build tasks that is modular, extensible and easy to start with. Fake allows you to easily build, bundle, deploy your app and more by executing a single command.</p> <p>The standard template comes with a FAKE project by default, so this recipe only applies to the minimal template.</p>"},{"location":"v4-recipes/build/add-build-script/#1-create-a-build-project","title":"1. Create a build project","text":"<p>Create a new console app called 'Build' at the root of your solution</p> <pre><code>dotnet new console -lang f# -n Build -o .\n</code></pre> <p>We are creating the project directly at the root of the solution in order to allow us to execute the build without needing to navigate into a subfolder.</p>"},{"location":"v4-recipes/build/add-build-script/#2-create-a-build-script","title":"2. Create a build script","text":"<p>Open the project you just created in your IDE and rename the module it contains from <code>Program.fs</code> to <code>Build.fs</code>.</p> <p>This renaming isn't explicitly necessary, however it keeps your solution consistent with other SAFE apps and is a better name for the file really.</p> <p>If you just rename the file directly rather than in your IDE, then the Build project won't be able to find it unless you edit the Build.fsproj file as well</p> <p>Open <code>Build.fs</code> and paste in the following code.</p> <pre><code>open Fake.Core\nopen Fake.IO\nopen System\n\nlet redirect createProcess =\n    createProcess\n    |&gt; CreateProcess.redirectOutputIfNotRedirected\n    |&gt; CreateProcess.withOutputEvents Console.WriteLine Console.WriteLine\n\nlet createProcess exe arg dir =\n    CreateProcess.fromRawCommandLine exe arg\n    |&gt; CreateProcess.withWorkingDirectory dir\n    |&gt; CreateProcess.ensureExitCode\n\nlet dotnet = createProcess \"dotnet\"\n\nlet npm =\n    let npmPath =\n        match ProcessUtils.tryFindFileOnPath \"npm\" with\n        | Some path -&gt; path\n        | None -&gt; failwith \"npm was not found in path.\"\n    createProcess npmPath\n\nlet run proc arg dir =\n    proc arg dir\n    |&gt; Proc.run\n    |&gt; ignore\n\nlet execContext = Context.FakeExecutionContext.Create false \"build.fsx\" [ ]\nContext.setExecutionContext (Context.RuntimeContext.Fake execContext)\n\nTarget.create \"Clean\" (fun _ -&gt; Shell.cleanDir (Path.getFullName \"deploy\"))\n\nTarget.create \"InstallClient\" (fun _ -&gt; run npm \"install\" \".\")\n\nTarget.create \"Run\" (fun _ -&gt;\n    run dotnet \"build\" (Path.getFullName \"src/Shared\")\n    [ dotnet \"watch run\" (Path.getFullName \"src/Server\")\n      dotnet \"fable watch --run webpack-dev-server\" (Path.getFullName \"src/Client\") ]\n    |&gt; Seq.toArray\n    |&gt; Array.map redirect\n    |&gt; Array.Parallel.map Proc.run\n    |&gt; ignore\n)\n\nopen Fake.Core.TargetOperators\n\nlet dependencies = [\n    \"Clean\"\n        ==&gt; \"InstallClient\"\n        ==&gt; \"Run\"\n]\n\n[&lt;EntryPoint&gt;]\nlet main args =\n  try\n      match args with\n      | [| target |] -&gt; Target.runOrDefault target\n      | _ -&gt; Target.runOrDefault \"Run\"\n      0\n  with e -&gt;\n      printfn \"%A\" e\n      1\n</code></pre>"},{"location":"v4-recipes/build/add-build-script/#3-add-the-project-to-the-solution","title":"3. Add the project to the solution","text":"<p>Run the following command</p> <pre><code>dotnet sln add Build.fsproj\n</code></pre>"},{"location":"v4-recipes/build/add-build-script/#4-installing-dependencies","title":"4. Installing dependencies","text":"<p>You will need to install the following dependencies:</p> <pre><code>Fake.Core.Target\nFake.IO.FileSystem\n</code></pre> <p>We recommend migrating to Paket. It is possible to use FAKE without Paket, however this will not be covered in this recipe.</p>"},{"location":"v4-recipes/build/add-build-script/#5-run-the-app","title":"5. Run the app","text":"<p>At the root of the solution, run <code>dotnet paket install</code> to install all your dependencies.</p> <p>If you now execute <code>dotnet run</code>, the default target will be run. This will build the app in development mode and launch it locally.</p> <p>To learn more about targets and FAKE in general, see Getting Started with FAKE.</p>"},{"location":"v4-recipes/build/bundle-app/","title":"How do I bundle my SAFE application?","text":"<p>When developing your SAFE application, the local runtime experience uses WebPack to run the client and redirect API calls to the server on a different port. However, when you deploy your application, you'll need to run your Saturn server which will serve up statically-built client resources (HTML, JavaScript, CSS etc.).</p>"},{"location":"v4-recipes/build/bundle-app/#im-using-the-standard-template","title":"I'm using the standard template","text":""},{"location":"v4-recipes/build/bundle-app/#1-run-the-fake-script","title":"1. Run the FAKE script","text":"<p>If you created your SAFE app using the recommended defaults, your application already has a FAKE script which will do the bundling for you. You can create a bundle using the following command:</p> <pre><code>dotnet run Bundle\n</code></pre> <p>This will build and package up both the client and server and place them into the <code>/deploy</code> folder at the root of the repository.</p> <p>See here for more details on this build target.</p>"},{"location":"v4-recipes/build/bundle-app/#im-using-the-minimal-template","title":"I'm using the minimal template","text":"<p>If you created your SAFE app using the minimal option, you need to bundle up the client and server separately.</p>"},{"location":"v4-recipes/build/bundle-app/#1-bundle-the-client-fable-application","title":"1. Bundle the Client (Fable) application","text":"<p>Execute the following commands:</p> <pre><code>npm install\n\ndotnet tool restore \n\ndotnet fable src/Client --run webpack\n</code></pre> <p>This will build the client project and copy all outputs into <code>/deploy/public</code>.</p>"},{"location":"v4-recipes/build/bundle-app/#2-bundle-the-server-saturn-application","title":"2. Bundle the Server (Saturn) application","text":"<p>Execute the following commands:</p> <pre><code>cd src/Server\ndotnet publish -c release -o ../../deploy\n</code></pre> <p>This will bundle the server project and copy all outputs into the <code>deploy</code> folder.</p>"},{"location":"v4-recipes/build/bundle-app/#testing-the-bundle","title":"Testing the bundle","text":"<ol> <li>Navigate to the <code>deploy</code> folder at the root of your repository.</li> <li>Run the <code>Server.exe</code> application.</li> <li>Navigate in your browser to <code>http://localhost:5000</code>.</li> </ol> <p>You should now see your SAFE application.</p>"},{"location":"v4-recipes/build/bundle-app/#further-reading","title":"Further reading","text":"<p>See this article for more information on architectural concerns regarding the move from dev to production and bundling SAFE Stack applications.</p>"},{"location":"v4-recipes/build/docker-image/","title":"How do I build with docker?","text":"<p>Using Docker makes it possible to deploy your application as a docker container or release an image on docker hub. This recipe walks you through creating a <code>Dockerfile</code> and automating the build and test process with Docker Hub.</p>"},{"location":"v4-recipes/build/docker-image/#1-create-a-dockerignore-file","title":"1. Create a .dockerignore file","text":"<p>Create a <code>.dockerignore</code> file with the same contents as <code>.gitignore</code></p>"},{"location":"v4-recipes/build/docker-image/#linux","title":"Linux","text":"<pre><code>cp .gitignore .dockerignore\n</code></pre>"},{"location":"v4-recipes/build/docker-image/#windows","title":"Windows","text":"<pre><code>copy .gitignore .dockerignore\n</code></pre> <p>Now, add the following lines to the <code>.dockerignore</code> file:</p> <pre><code>.git\n</code></pre>"},{"location":"v4-recipes/build/docker-image/#2-create-the-dockerfile","title":"2. Create the dockerfile","text":"<p>Create a <code>Dockerfile</code> with the following contents:</p> <pre><code>FROM mcr.microsoft.com/dotnet/sdk:6.0 as build\n\n# Install node\nRUN curl -sL https://deb.nodesource.com/setup_16.x | bash\nRUN apt-get update &amp;&amp; apt-get install -y nodejs\n\nWORKDIR /workspace\nCOPY . .\nRUN dotnet tool restore\n\nRUN dotnet run Bundle\n\n\nFROM mcr.microsoft.com/dotnet/aspnet:6.0-alpine\nCOPY --from=build /workspace/deploy /app\nWORKDIR /app\nEXPOSE 5000\nENTRYPOINT [ \"dotnet\", \"Server.dll\" ]\n</code></pre> <p>This uses multistage builds to keep the final image small.</p>"},{"location":"v4-recipes/build/docker-image/#using-the-minimal-template","title":"Using the minimal template?","text":"<p>Replace the line</p> <pre><code>RUN dotnet run Bundle\n</code></pre> <p>with</p> <pre><code>RUN npm install\nRUN dotnet fable src/Client --run webpack\nRUN cd src/Server &amp;&amp; dotnet publish -c release -o ../../deploy\n</code></pre>"},{"location":"v4-recipes/build/docker-image/#3-building-and-running-with-docker-locally","title":"3. Building and running with docker locally","text":"<ol> <li>Build the image <code>docker build -t my-safe-app .</code></li> <li>Run the container <code>docker run -it -p 5000:80 my-safe-app</code></li> </ol> <p>Because the build is done entirely in docker, Docker Hub automated builds can be setup to automatically build and push the docker image.</p>"},{"location":"v4-recipes/build/docker-image/#4-testing-the-server","title":"4. Testing the server","text":"<p>Create a <code>docker-compose.server.test.yml</code> file with the following contents:</p> <p><pre><code>version: '3.4'\nservices:\n    sut:\n        build:\n            target: build\n            context: .\n        working_dir: /workspace/tests/Server\n        command: dotnet run\n</code></pre> To run the tests execute the command <code>docker-compose -f docker-compose.server.test.yml up --build</code></p> <p>You can add server tests to the minimal template with the testing the server recipe.</p> <p>The template is not currently setup for automating the client tests in ci.</p> <p>Docker Hub can also run automated tests for you.</p> <p>Follow the instructions to enable Autotest on docker hub.</p>"},{"location":"v4-recipes/build/docker-image/#5-making-the-docker-build-faster","title":"5. Making the docker build faster","text":"<p>Not recommended for most applications</p> <p>If you often build with docker locally, you may wish to make the build faster by optimising the Dockerfile for caching. For example, it is not necessary to download all paket and npm dependencies on every build unless there have been changes to the dependencies.</p> <p>Furthermore, the client and server can be built in separate build stages so that they are cached independently. Enable Docker BuildKit to build them concurrently.</p> <p>This comes at the expense of making the dockerfile more complex; if any changes are made to the build such as adding new projects or migrating package managers, the dockerfile must be updated accordingly.</p> <p>The following should be a good starting point but is not guarenteed to work.</p> <pre><code>FROM mcr.microsoft.com/dotnet/sdk:6.0 as build\n\n# Install node\nRUN curl -sL https://deb.nodesource.com/setup_16.x | bash\nRUN apt-get update &amp;&amp; apt-get install -y nodejs\n\nWORKDIR /workspace\nCOPY .config .config\nRUN dotnet tool restore\nCOPY .paket .paket\nCOPY paket.dependencies paket.lock ./\n\nFROM build as server-build\nCOPY src/Shared src/Shared\nCOPY src/Server src/Server\nRUN cd src/Server &amp;&amp; dotnet publish -c release -o ../../deploy\n\n\nFROM build as client-build\nCOPY package.json package-lock.json ./\nRUN npm install\nCOPY webpack.config.js ./\nCOPY src/Shared src/Shared\nCOPY src/Client src/Client\nRUN dotnet fable src/Client --run webpack\n\n\nFROM mcr.microsoft.com/dotnet/aspnet:6.0-alpine\nCOPY --from=server-build /workspace/deploy /app\nCOPY --from=client-build /workspace/deploy /app\nWORKDIR /app\nEXPOSE 5000\nENTRYPOINT [ \"dotnet\", \"Server.dll\" ]\n</code></pre>"},{"location":"v4-recipes/build/remove-fake/","title":"How do I remove the use of FAKE?","text":"<p>FAKE is a tool for build automation. The standard SAFE template comes with a ready-made build project at the root of the solution that provides support for many common SAFE tasks.</p> <p>If you would prefer not to use FAKE, you can of course simply ignore it, but this recipes shows how to completely remove it from your repository. It is important to note that having removed FAKE, you will have to follow a more manual approach to each of these processes. This recipe will only include instructions on how to build and deploy the application after removing FAKE.</p> <p>Note that the minimal template does not use FAKE by default, and this recipe only applies to the standard template.</p>"},{"location":"v4-recipes/build/remove-fake/#1-build-project","title":"1. Build project","text":"<p>Delete <code>Build.fs</code>, <code>Build.fsproj</code>, <code>Helpers.fs</code>, <code>paket.references</code> at the root of the solution.</p>"},{"location":"v4-recipes/build/remove-fake/#2-dependencies","title":"2. Dependencies","text":"<p>Remove the following dependencies  <pre><code>dotnet paket remove Fake.Core.Target\ndotnet paket remove Fake.IO.FileSystem\ndotnet paket remove Farmer\n</code></pre></p>"},{"location":"v4-recipes/build/remove-fake/#running-the-app","title":"Running the App","text":"<p>Now that you have the FAKE dependencies removed, you will have to separately run the server and the client.</p>"},{"location":"v4-recipes/build/remove-fake/#1-start-the-server","title":"1. Start the Server","text":"<p>Navigate to <code>src/Server</code> inside a terminal and execute <code>dotnet run</code>.</p>"},{"location":"v4-recipes/build/remove-fake/#2-start-the-client","title":"2. Start the Client","text":"<p>Execute the following commands inside a terminal at the root of the solution.</p> <pre><code>dotnet tool restore\nnpm install\ndotnet fable src/Client --run webpack-dev-server\n</code></pre> <p>The app will now be running at <code>http://0.0.0.0:8080/</code>. Navigate to this address in a browser to see your app running.</p>"},{"location":"v4-recipes/build/remove-fake/#bundling-the-app","title":"Bundling the App","text":"<p>See this guide to learn how to package a SAFE application for deployment to e.g. Azure.</p>"},{"location":"v4-recipes/client-server/fable-remoting/","title":"How Do I Add Support for Fable Remoting?","text":"<p>Fable Remoting is a type-safe RPC communication layer for SAFE apps. It uses HTTP behind the scenes, but allows you to program against protocols that exist across the application without needing to think about the HTTP plumbing, and is a great fit for the majority of SAFE applications.</p> <p>Note that the standard template uses Fable Remoting. This recipe only applies to the minimal template.</p>"},{"location":"v4-recipes/client-server/fable-remoting/#1-install-nuget-packages","title":"1. Install NuGet Packages","text":"<p>Add Fable.Remoting.Giraffe to the Server and Fable.Remoting.Client to the Client.</p> <p>See How Do I Add a NuGet Package to the Server and How Do I Add a NuGet Package to the Client.</p>"},{"location":"v4-recipes/client-server/fable-remoting/#2-create-the-api-protocol","title":"2. Create the API protocol","text":"<p>You now need to create the protocol, or contract, of the API we\u2019ll be creating. Insert the following below the <code>Route</code> module in <code>Shared.fs</code>: <pre><code>type IMyApi =\n    { hello : unit -&gt; Async&lt;string&gt; }\n</code></pre></p>"},{"location":"v4-recipes/client-server/fable-remoting/#3-create-the-routing-function","title":"3. Create the routing function","text":"<p>We need to provide a basic routing function in order to ensure client and server communicate on the same endpoint. Find the <code>Route</code> module in <code>src/Shared/Shared.fs</code> and replace it with the following:</p> <pre><code>module Route =\n    let builder typeName methodName =\n        sprintf \"/api/%s/%s\" typeName methodName\n</code></pre>"},{"location":"v4-recipes/client-server/fable-remoting/#4-create-the-protocol-implementation","title":"4. Create the protocol implementation","text":"<p>We now need to provide an implementation of the protocol on the server. Open <code>src/Server/Server.fs</code> and insert the following right after the <code>open</code> statements:</p> <pre><code>let myApi =\n    { hello = fun () -&gt; async { return \"Hello from SAFE!\" } }\n</code></pre>"},{"location":"v4-recipes/client-server/fable-remoting/#5-hook-into-aspnet","title":"5. Hook into ASP.NET","text":"<p>We now need to \"adapt\" Fable Remoting into the ASP.NET pipeline by converting it into a Giraffe HTTP Handler. Don't worry - this is not hard. Find <code>webApp</code> in <code>Server.fs</code> and replace it with the following:</p> <pre><code>open Fable.Remoting.Server\nopen Fable.Remoting.Giraffe\n\nlet webApp =\n    Remoting.createApi()\n    |&gt; Remoting.withRouteBuilder Route.builder // use the routing function from step 3\n    |&gt; Remoting.fromValue myApi // use the myApi implementation from step 4\n    |&gt; Remoting.buildHttpHandler // adapt it to Giraffe's HTTP Handler\n</code></pre>"},{"location":"v4-recipes/client-server/fable-remoting/#6-create-the-client-proxy","title":"6. Create the Client proxy","text":"<p>We now need a corresponding client proxy in order to be able to connect to the server. Open <code>src/Client/Client.fs</code> and insert the following right after the <code>Msg</code> type: <pre><code>open Fable.Remoting.Client\n\nlet myApi =\n    Remoting.createApi()\n    |&gt; Remoting.withRouteBuilder Route.builder\n    |&gt; Remoting.buildProxy&lt;IMyApi&gt;\n</code></pre></p>"},{"location":"v4-recipes/client-server/fable-remoting/#7-make-calls-to-the-server","title":"7. Make calls to the Server","text":"<p>Replace the following two lines in the <code>init</code> function in <code>Client.fs</code>:</p> <pre><code>let getHello() = Fetch.get&lt;unit, string&gt; Route.hello\nlet cmd = Cmd.OfPromise.perform getHello () GotHello\n</code></pre> <p>with this:</p> <pre><code>let cmd = Cmd.OfAsync.perform myApi.hello () GotHello\n</code></pre>"},{"location":"v4-recipes/client-server/fable-remoting/#done","title":"Done!","text":"<p>At this point, the app should work just as it did before. Now, expanding the API and adding a new endpoint is as easy as adding a new field to the API protocol we defined in <code>Shared.fs</code>, editing the <code>myApi</code> record in <code>Server.fs</code> with the implementation, and finally making calls from the proxy.</p>"},{"location":"v4-recipes/client-server/fable.forms/","title":"Add support for Fable.Forms","text":""},{"location":"v4-recipes/client-server/fable.forms/#install-dependencies","title":"Install dependencies","text":"<p>First off, you need to create a SAFE app, install the relevant dependencies, and wire them up to be available for use in your F# Fable code.</p> <ol> <li> <p>Create a new SAFE app and restore local tools: <pre><code>dotnet new SAFE\ndotnet tool restore\n</code></pre></p> </li> <li> <p>Install Fable.Form.Simple.Bulma using Paket: <pre><code>dotnet paket add --project src/Client/ Fable.Form.Simple.Bulma --version 3.0.0\n</code></pre></p> </li> <li> <p>Install bulma and fable-form-simple-bulma npm packages: <pre><code>npm add fable-form-simple-bulma\nnpm add bulma@0.9.0\n</code></pre></p> </li> </ol>"},{"location":"v4-recipes/client-server/fable.forms/#register-styles","title":"Register styles","text":"<ol> <li> <p>Create <code>./src/Client/style.scss</code> with the following contents:</p> CodeDiff style.scss<pre><code>@import \"~bulma\";\n@import \"~fable-form-simple-bulma\";\n</code></pre> style.scss<pre><code>+@import \"~bulma\";\n+@import \"~fable-form-simple-bulma\";\n</code></pre> </li> <li> <p>Update webpack config to include the new stylesheet:</p> <p>a. Add a <code>cssEntry</code> property to the <code>CONFIG</code> object:</p> CodeDiff webpack.config.js<pre><code>cssEntry: './src/Client/style.scss',\n</code></pre> webpack.config.js<pre><code>+cssEntry: './src/Client/style.scss',\n</code></pre> <p>b. Modify the <code>entry</code> property of the object returned from <code>module.exports</code> to include <code>cssEntry</code>:</p> CodeDiff webpack.config.js<pre><code>entry: isProduction ? {\n        app: [resolve(config.fsharpEntry), resolve(config.cssEntry)]\n} : {\n        app: resolve(config.fsharpEntry),\n        style: resolve(config.cssEntry)\n},\n</code></pre> webpack.config.js<pre><code>-   entry: {\n-       app: resolve(config.fsharpEntry)\n-   },\n+   entry: isProduction ? {\n+           app: [resolve(config.fsharpEntry), resolve(config.cssEntry)]\n+   } : {\n+           app: resolve(config.fsharpEntry),\n+           style: resolve(config.cssEntry)\n+   },\n</code></pre> </li> <li> <p>Remove the Bulma stylesheet link from <code>./src/Client/index.html</code>, as it is no longer needed:</p> index.html (diff)<pre><code>    &lt;link rel=\"icon\" type=\"image/png\" href=\"/favicon.png\"/&gt;\n-   &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css\"&gt;\n</code></pre> </li> </ol>"},{"location":"v4-recipes/client-server/fable.forms/#replace-the-existing-form-with-a-fableform","title":"Replace the existing form with a Fable.Form","text":"<p>With the above preparation done, you can use Fable.Form.Simple.Bulma in your <code>./src/Client/Index.fs</code> file.</p> <ol> <li> <p>Open the newly added namespaces:</p> CodeDiff Index.fs<pre><code>open Fable.Form.Simple\nopen Fable.Form.Simple.Bulma\n</code></pre> Index.fs<pre><code>+open Fable.Form.Simple\n+open Fable.Form.Simple.Bulma\n</code></pre> </li> <li> <p>Create type <code>Values</code> to represent each input field on the form (a single textbox), and create a type <code>Form</code> which is an alias for <code>Form.View.Model&lt;Values&gt;</code>:</p> CodeDiff Index.fs<pre><code>type Values = { Todo: string }\ntype Form = Form.View.Model&lt;Values&gt;\n</code></pre> Index.fs<pre><code>+type Values = { Todo: string }\n+type Form = Form.View.Model&lt;Values&gt;\n</code></pre> </li> <li> <p>In the <code>Model</code> type definition, replace <code>Input: string</code> with <code>Form: Form</code> </p> CodeDiff Index.fs<pre><code>type Model = { Todos: Todo list; Form: Form }\n</code></pre> Index.fs<pre><code>-type Model = { Todos: Todo list; Input: string }\n+type Model = { Todos: Todo list; Form: Form }\n</code></pre> </li> <li> <p>Update the <code>init</code> function to reflect the change in <code>Model</code>:</p> CodeDiff Index.fs<pre><code>let model = { Todos = []; Form = Form.View.idle { Todo = \"\" } }\n</code></pre> Index.fs<pre><code>-let model = { Todos = []; Input = \"\" }\n+let model = { Todos = []; Form = Form.View.idle { Todo = \"\" } }\n</code></pre> </li> <li> <p>Change <code>Msg</code> discriminated union - replace the <code>SetInput</code> case with <code>FormChanged of Form</code>, and add string data to the <code>AddTodo</code> case:</p> CodeDiff Index.fs<pre><code>type Msg =\n    | GotTodos of Todo list\n    | FormChanged of Form\n    | AddTodo of string\n    | AddedTodo of Todo\n</code></pre> Index.fs<pre><code>type Msg =\n    | GotTodos of Todo list\n-   | SetInput of string\n-   | AddTodo\n+   | FormChanged of Form\n+   | AddTodo of string\n    | AddedTodo of Todo\n</code></pre> </li> <li> <p>Modify the <code>update</code> function to handle the changed <code>Msg</code> cases:</p> CodeDiff Index.fs<pre><code>let update (msg: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n    match msg with\n    | GotTodos todos -&gt; { model with Todos = todos }, Cmd.none\n    | FormChanged form -&gt; { model with Form = form }, Cmd.none\n    | AddTodo todo -&gt;\n        let todo = Todo.create todo\n        let cmd = Cmd.OfAsync.perform todosApi.addTodo todo AddedTodo\n        model, cmd\n    | AddedTodo todo -&gt;\n        let newModel =\n            { model with\n                Todos = model.Todos @ [ todo ]\n                Form =\n                    { model.Form with\n                        State = Form.View.Success \"Todo added\"\n                        Values = { model.Form.Values with Todo = \"\" } } }\n        newModel, Cmd.none\n</code></pre> Index.fs<pre><code>let update (msg: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n    match msg with\n    | GotTodos todos -&gt; { model with Todos = todos }, Cmd.none\n-   | SetInput value -&gt; { model with Input = value }, Cmd.none\n+   | FormChanged form -&gt; { model with Form = form }, Cmd.none\n-   | AddTodo -&gt;\n-       let todo = Todo.create model.Input\n-       let cmd = Cmd.OfAsync.perform todosApi.addTodo todo AddedTodo\n-       { model with Input = \"\" }, cmd\n+   | AddTodo todo -&gt;\n+       let todo = Todo.create todo\n+       let cmd = Cmd.OfAsync.perform todosApi.addTodo todo AddedTodo\n+       model, cmd\n-   | AddedTodo todo -&gt; { model with Todos = model.Todos @ [ todo ] }, Cmd.none\n+   | AddedTodo todo -&gt;\n+       let newModel =\n+           { model with\n+               Todos = model.Todos @ [ todo ]\n+               Form =\n+                   { model.Form with\n+                       State = Form.View.Success \"Todo added\"\n+                       Values = { model.Form.Values with Todo = \"\" } } }\n+       newModel, Cmd.none\n</code></pre> </li> <li> <p>Create <code>form</code>. This defines the logic of the form, and how it responds to interaction:</p> CodeDiff Index.fs<pre><code>let form : Form.Form&lt;Values, Msg, _&gt; =\n    let todoField =\n        Form.textField\n            {\n                Parser = Ok\n                Value = fun values -&gt; values.Todo\n                Update = fun newValue values -&gt; { values with Todo = newValue }\n                Error = fun _ -&gt; None\n                Attributes =\n                    {\n                        Label = \"New todo\"\n                        Placeholder = \"What needs to be done?\"\n                        HtmlAttributes = []\n                    }\n            }\n\n    Form.succeed AddTodo\n    |&gt; Form.append todoField\n</code></pre> Index.fs<pre><code>+let form : Form.Form&lt;Values, Msg, _&gt; =\n+    let todoField =\n+        Form.textField\n+            {\n+                Parser = Ok\n+                Value = fun values -&gt; values.Todo\n+                Update = fun newValue values -&gt; { values with Todo = newValue }\n+                Error = fun _ -&gt; None\n+                Attributes =\n+                    {\n+                        Label = \"New todo\"\n+                        Placeholder = \"What needs to be done?\"\n+                        HtmlAttributes = []\n+                    }\n+            }\n+\n+    Form.succeed AddTodo\n+    |&gt; Form.append todoField\n</code></pre> </li> <li> <p>In the function <code>containerBox</code>, remove the existing form view. Then replace it using <code>Form.View.asHtml</code> to render the view:</p> CodeDiff Index.fs<pre><code>let containerBox (model: Model) (dispatch: Msg -&gt; unit) =\n    Bulma.box [\n        Bulma.content [\n            Html.ol [\n                for todo in model.Todos do\n                    Html.li [ prop.text todo.Description ]\n            ]\n        ]\n        Form.View.asHtml\n            {\n                Dispatch = dispatch\n                OnChange = FormChanged\n                Action = Form.View.Action.SubmitOnly \"Add\"\n                Validation = Form.View.Validation.ValidateOnBlur\n            }\n            form\n            model.Form\n    ]\n</code></pre> Index.fs<pre><code>let containerBox (model: Model) (dispatch: Msg -&gt; unit) =\n    Bulma.box [\n        Bulma.content [\n            Html.ol [\n                for todo in model.Todos do\n                    Html.li [ prop.text todo.Description ]\n            ]\n        ]\n-       Bulma.field.div [\n-           ... removed for brevity ...\n-       ]\n+       Form.View.asHtml\n+           {\n+               Dispatch = dispatch\n+               OnChange = FormChanged\n+               Action = Form.View.Action.SubmitOnly \"Add\"\n+               Validation = Form.View.Validation.ValidateOnBlur\n+           }\n+           form\n+           model.Form\n    ]\n</code></pre> </li> </ol>"},{"location":"v4-recipes/client-server/fable.forms/#adding-new-functionality","title":"Adding new functionality","text":"<p>With the basic structure in place, it's easy to add functionality to the form. For example, the changes necessary to add a high priority checkbox are pretty small.</p>"},{"location":"v4-recipes/client-server/messaging-post/","title":"How do I send and receive data using POST?","text":"<p>This recipe shows how to create an endpoint on the server and hook up it up to the client using HTTP POST. This recipe assumes that you have also followed this recipe and have an understanding of MVU messaging. This recipe only shows how to wire up the client and server.</p> <p>A POST endpoint is normally used to send data from the client to the server in the body, for example from a form. This is useful when we need to supply more data than can easily be provided in the URI.</p> <p>You may wish to use POST for \"write\" operations and use GETs for \"reads\", however this is a highly opinionated topic that is beyond the scope of this recipe.</p>"},{"location":"v4-recipes/client-server/messaging-post/#im-using-the-standard-template-fable-remoting","title":"I'm using the standard template (Fable Remoting)","text":"<p>Fable Remoting takes care of deciding whether to use POST or GET etc. - you don't have to worry about this. Refer to this recipe for more details.</p>"},{"location":"v4-recipes/client-server/messaging-post/#im-using-the-minimal-template-raw-http","title":"I'm using the minimal template (Raw HTTP)","text":""},{"location":"v4-recipes/client-server/messaging-post/#in-shared","title":"In Shared","text":""},{"location":"v4-recipes/client-server/messaging-post/#1-create-contract","title":"1. Create contract","text":"<p>Create the type that will store the payload sent from the client to the server.</p> <pre><code>type SaveCustomerRequest =\n    { Name : string\n      Age : int }\n</code></pre>"},{"location":"v4-recipes/client-server/messaging-post/#on-the-client","title":"On the Client","text":""},{"location":"v4-recipes/client-server/messaging-post/#1-call-the-endpoint","title":"1. Call the endpoint","text":"<p>Create a new function <code>saveCustomer</code> that will call the server. It supplies the customer to save, which is serialized and sent to the server in the body of the message.</p> <pre><code>let saveCustomer customer =\n    let save customer = Fetch.post&lt;SaveCustomerRequest, int&gt; (\"/api/customer\", customer)\n    Cmd.OfPromise.perform save customer CustomerSaved\n</code></pre> <p>The generic arguments of <code>Fetch.post</code> are the input and output types. The example above shows that the input is of type <code>SaveCustomerRequest</code> with the response will contain an integer value. This may be the ID generated by the server for the save operation.</p> <p>This can now be called from within your <code>update</code> function e.g.</p> <pre><code>| SaveCustomer request -&gt;\n    model, saveCustomer request\n| CustomerSaved generatedId -&gt;\n    { model with GeneratedCustomerId = Some generatedId; Message = \"Saved customer!\" }, Cmd.none\n</code></pre>"},{"location":"v4-recipes/client-server/messaging-post/#on-the-server","title":"On the Server","text":""},{"location":"v4-recipes/client-server/messaging-post/#1-write-implementation","title":"1. Write implementation","text":"<p>Create a function that can extract the payload from the body of the request using Giraffe's built-in model binding support:</p> <pre><code>open FSharp.Control.Tasks\nopen Giraffe\nopen Microsoft.AspNetCore.Http\nopen Shared\n\n/// Extracts the request from the body and saves to the database.\nlet saveCustomer next (ctx:HttpContext) = task {\n    let! customer = ctx.BindModelAsync&lt;SaveCustomerRequest&gt;()\n    do! Database.saveCustomer customer\n    return! Successful.OK \"Saved customer\" next ctx\n}\n</code></pre>"},{"location":"v4-recipes/client-server/messaging-post/#2-expose-your-function","title":"2. Expose your function","text":"<p>Tie your function into the router, using the <code>post</code> verb instead of <code>get</code>.</p> <pre><code>let webApp = router {\n    post \"/api/customer\" saveCustomer // Add this\n}\n</code></pre>"},{"location":"v4-recipes/client-server/messaging/","title":"How do I send and receive data?","text":"<p>This recipe shows how to create an endpoint on the server and hook up it up to the client. This recipe assumes that you have also followed this recipe and have an understanding of MVU messaging. This recipe only shows how to wire up the client and server.</p>"},{"location":"v4-recipes/client-server/messaging/#im-using-the-standard-template-fable-remoting","title":"I'm using the standard template (Fable Remoting)","text":"<p>Fable Remoting is a library which allows you to create client/server messaging without any need to think about HTTP verbs or serialization etc.</p>"},{"location":"v4-recipes/client-server/messaging/#in-shared","title":"In Shared","text":""},{"location":"v4-recipes/client-server/messaging/#1-update-contract","title":"1. Update contract","text":"<p>Add your new endpoint onto an existing API contract e.g. <code>ITodosApi</code>. Because Fable Remoting exposes your API through F# on client and server, you get type safety across both.</p> <pre><code>type ITodosApi =\n    { getCustomer : int -&gt; Async&lt;Customer option&gt; }\n</code></pre>"},{"location":"v4-recipes/client-server/messaging/#on-the-server","title":"On the server","text":""},{"location":"v4-recipes/client-server/messaging/#1-write-implementation","title":"1. Write implementation","text":"<p>Create a function that implements the back-end service that you require. Use standard functions to read from databases or other external sources as required. <pre><code>let loadCustomer customerId = async {\n    return Some { Name = \"My Customer\" }\n}\n</code></pre></p> <p>Note the use of <code>async</code> here. Fable Remoting uses async workflows, and not tasks. You can write functions that use task, but will have to at some point map to async using <code>Async.AwaitTask</code>.</p>"},{"location":"v4-recipes/client-server/messaging/#2-expose-your-function","title":"2. Expose your function","text":"<p>Tie the function you've just written into the API implementation. <pre><code>let todosApi =\n    { ///...\n      getCustomer = loadCustomer\n    }\n</code></pre></p>"},{"location":"v4-recipes/client-server/messaging/#3-test-the-endpoint-optional","title":"3. Test the endpoint (optional)","text":"<p>Test out your endpoint using e.g. web browser / Postman / REST Client for VS Code etc. See here for more details on the required format.</p>"},{"location":"v4-recipes/client-server/messaging/#on-the-client","title":"On the client","text":""},{"location":"v4-recipes/client-server/messaging/#1-call-the-endpoint","title":"1. Call the endpoint","text":"<p>Create a new function <code>loadCustomer</code> that will call the endpoint.</p> <pre><code>let loadCustomer customerId =\n    Cmd.OfAsync.perform todosApi.getCustomer customerId LoadedCustomer\n</code></pre> <p>Note the final value supplied, <code>CustomerLoaded</code>. This is the <code>Msg</code> case that will be sent into the Elmish loop once the call returns, with the returned data. It should take in a value that matches the type returned by the Server e.g. <code>CustomerLoaded of Customer option</code>. See here for more information.</p> <p>This can now be called from within your <code>update</code> function e.g.</p> <pre><code>| LoadCustomer customerId -&gt;\n    model, loadCustomer customerId\n</code></pre>"},{"location":"v4-recipes/client-server/messaging/#im-using-the-minimal-template-raw-http","title":"I'm using the minimal template (Raw HTTP)","text":"<p>This recipe shows how to create a GET endpoint on the server and consume it on the client using the Fetch API.</p>"},{"location":"v4-recipes/client-server/messaging/#on-the-server_1","title":"On the Server","text":""},{"location":"v4-recipes/client-server/messaging/#1-write-implementation_1","title":"1. Write implementation","text":"<p>Create a function that implements the back-end service that you require. Use standard functions to read from databases or other external sources as required. <pre><code>open Saturn\nopen FSharp.Control.Tasks\n\n/// Loads a customer from the DB and returns as a Customer in json.\nlet loadCustomer (customerId:int) next ctx = task {\n    let customer = { Name = \"My Customer\" }\n    return! json customer next ctx\n}\n</code></pre></p> <p>Note how we parameterise this function to take in the <code>customerId</code> as the first argument. Any parameters you need should be supplied in this manner. If you do not need any parameters, just omit them and leave the <code>next</code> and <code>ctx</code> ones.</p> <p>This example does not cover dealing with \"missing\" data e.g. invalid customer ID is found.</p>"},{"location":"v4-recipes/client-server/messaging/#2expose-your-function","title":"2.Expose your function","text":"<p>Tie the function into the router with a route.</p> <pre><code>let webApp = router {\n    getf \"/api/customer/%i\" loadCustomer // Add this\n}\n</code></pre> <p>Note the use of <code>getf</code> rather than <code>get</code>. If you do not need any parameters, just use <code>get</code>. See here for reference docs on the use of the Saturn router.</p>"},{"location":"v4-recipes/client-server/messaging/#3-test-the-endpoint-optional_1","title":"3. Test the endpoint (optional)","text":"<p>Test out your endpoint using e.g. web browser / Postman / REST Client for VS Code etc.</p>"},{"location":"v4-recipes/client-server/messaging/#on-the-client_1","title":"On the client","text":""},{"location":"v4-recipes/client-server/messaging/#1-call-the-endpoint_1","title":"1. Call the endpoint","text":"<p>Create a new function <code>loadCustomer</code> that will call the endpoint.</p> <p>This example uses Thoth.Fetch to download and deserialise the response.</p> <pre><code>let loadCustomer customerId =\n    let loadCustomer () = Fetch.get&lt;unit, Customer&gt; (sprintf \"/api/customer/%i\" customerId)\n    Cmd.OfPromise.perform loadCustomer () CustomerLoaded\n</code></pre> <p>Note the final value supplied, <code>CustomerLoaded</code>. This is the <code>Msg</code> case that will be sent into the Elmish loop once the call returns, with the returned data. It should take in a value that matches the type returned by the Server e.g. <code>CustomerLoaded of Customer</code>. See here for more information.</p> <p>An alternative (and slightly more succinct) way of writing this is:</p> <pre><code>let loadCustomer customerId =\n    let loadCustomer = sprintf \"/api/customer/%i\" &gt;&gt; Fetch.get&lt;unit, Customer&gt;\n    Cmd.OfPromise.perform loadCustomer customerId CustomerLoaded\n</code></pre> <p>This can now be called from within your <code>update</code> function e.g.</p> <pre><code>| LoadCustomer customerId -&gt;\n    model, loadCustomer customerId\n</code></pre>"},{"location":"v4-recipes/client-server/mvu-roundtrip/","title":"How do I load data from server to client using MVU?","text":"<p>This recipe demonstrates the steps you need to take to store new data on the client using the MVU pattern, which is typically read from the Server. You will learn the steps required to modify the model, update and view functions to handle a button click which requests data from the server and handles the response.</p>"},{"location":"v4-recipes/client-server/mvu-roundtrip/#in-shared","title":"In Shared","text":""},{"location":"v4-recipes/client-server/mvu-roundtrip/#1-create-shared-domain","title":"1. Create shared domain","text":"<p>Create a type in the Shared project which will act as the contract type between client and server. As SAFE compiles F# into JavaScript for you, you only need a single definition which will automatically be shared. <pre><code>type Customer = { Name : string }\n</code></pre></p>"},{"location":"v4-recipes/client-server/mvu-roundtrip/#on-the-client","title":"On the Client","text":""},{"location":"v4-recipes/client-server/mvu-roundtrip/#1-create-message-pairs","title":"1. Create message pairs","text":"<p>Modify the <code>Msg</code> type to have two new messages:</p> <pre><code>    type Msg =\n        // other messages ...\n        | LoadCustomer of customerId:int // Add this\n        | CustomerLoaded of Customer // Add this\n</code></pre> <p>You will see that this symmetrical pattern is often followed in MVU:</p> <ul> <li>A command to initiate a call to the server for some data (LoadCustomer)</li> <li>An event with the result of calling the command (CustomerLoaded)</li> </ul>"},{"location":"v4-recipes/client-server/mvu-roundtrip/#2-update-the-model","title":"2. Update the Model","text":"<p>Update the Model to store the Customer once it is loaded: <pre><code>type Model =\n    { // ...\n      TheCustomer : Customer option }\n</code></pre></p> <p>Make <code>TheCustomer</code> optional so that it can be initialised as <code>None</code> (see next step).</p>"},{"location":"v4-recipes/client-server/mvu-roundtrip/#3-update-the-init-function","title":"3. Update the Init function","text":"<p>Update the <code>init</code> function to provide default data <pre><code>let model =\n    { // ...\n      TheCustomer = None }\n</code></pre></p>"},{"location":"v4-recipes/client-server/mvu-roundtrip/#4-update-the-view","title":"4. Update the View","text":"<p>Update your view to initiate the <code>LoadCustomer</code> event. Here, we create a button that will start loading customer 42 on click: <pre><code>let view model dispatch =\n    Html.div [\n        // ...\n        Html.button [ \n            prop.onClick (fun _ -&gt; dispatch (LoadCustomer 42))  \n            prop.text \"Load Customer\"\n        ]\n    ]\n</code></pre></p>"},{"location":"v4-recipes/client-server/mvu-roundtrip/#5-handle-the-update","title":"5. Handle the Update","text":"<p>Modify the <code>update</code> function to handle the new messages: <pre><code>let update msg model =\n    match msg with\n    // ....\n    | LoadCustomer customerId -&gt;\n        // Implementation to connect to the server to be defined.\n    | CustomerLoaded c -&gt;\n        { model with TheCustomer = Some c }, Cmd.none\n</code></pre></p> <p>The code to fire off the message to the server differs depending on the client / server communication you are using and normally whether you are reading or writing data. See here for more information.</p>"},{"location":"v4-recipes/client-server/saturn-to-giraffe/","title":"How do I use Giraffe instead of Saturn?","text":"<p>Saturn is a functional alternative to MVC and Razor which sits on top of Giraffe. Giraffe itself is a functional wrapper around the ASP.NET Core web framework, making it easier to work with when using F#.</p> <p>Since Saturn is built on top of Giraffe, migrating to using \"raw\" Giraffe is relatively simple to do.</p>"},{"location":"v4-recipes/client-server/saturn-to-giraffe/#bootstrapping-the-application","title":"Bootstrapping the Application","text":""},{"location":"v4-recipes/client-server/saturn-to-giraffe/#1-open-libraries","title":"1. Open libraries","text":"<p>Navigate to the Server module in the Server project.</p> <p>Remove <pre><code>open Saturn\n</code></pre> and replace it with <pre><code>open Giraffe\nopen Microsoft.AspNetCore.Builder\nopen Microsoft.Extensions.DependencyInjection\nopen Microsoft.Extensions.Hosting\nopen Microsoft.AspNetCore.Hosting\n</code></pre></p>"},{"location":"v4-recipes/client-server/saturn-to-giraffe/#2-replace-application","title":"2. Replace application","text":"<p>In the same module, we need to replace the Server's <code>application</code> computation expression with some functions which set up the default host, configure the application and register services.</p> <p>Remove this</p> <pre><code>let app =\n    application {\n        // ...setup functions\n    }\n\nrun app\n</code></pre> <p>and replace it with this</p> <pre><code>let configureApp (app : IApplicationBuilder) =\n    app\n        .UseStaticFiles()\n        .UseGiraffe webApp\n\nlet configureServices (services : IServiceCollection) =\n    services\n        .AddGiraffe() |&gt; ignore\n\n\nHost.CreateDefaultBuilder()\n    .ConfigureWebHostDefaults(\n        fun webHostBuilder -&gt;\n            webHostBuilder\n                .Configure(configureApp)\n                .ConfigureServices(configureServices)\n                .UseWebRoot(\"public\")\n                |&gt; ignore)\n    .Build()\n    .Run()\n</code></pre>"},{"location":"v4-recipes/client-server/saturn-to-giraffe/#routing","title":"Routing","text":"<p>If you are using the standard SAFE template, there is nothing more you need to do, as routing is taken care of by Fable Remoting.</p> <p>If however you are using the minimal template, you will need to replace the Saturn router expression with the Giraffe equivalent.</p> <p>Replace this <pre><code>let webApp =\n    router {\n        get Route.hello (json \"Hello from SAFE!\")\n    }\n</code></pre></p> <p>with this <pre><code>let webApp = route Route.hello &gt;=&gt; json \"Hello from SAFE!\"\n</code></pre></p>"},{"location":"v4-recipes/client-server/saturn-to-giraffe/#other-setup","title":"Other setup","text":"<p>The steps shown here are the minimal necessary to get a SAFE app running using Giraffe.</p> <p>As with any Server setup however, there are many more optional parameters that you may wish to configure, such as caching, response compression and serialisation options as seen in the default SAFE templates amongst many others.</p> <p>See the Giraffe and ASP.NET Core host builder, application builder and service collection docs for more information on this.</p>"},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/","title":"Serve a file from the back-end","text":"<p>In SAFE apps, you can send a file from the server to the client as well as you can send any other type of data. However, there are a few details that make this case unique that varies on whether you use the standard or the minimal template.</p>"},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/#i-am-using-the-minimal-template","title":"I am using the minimal template","text":""},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/#1-add-the-route","title":"1. Add the route","text":"<p>To begin, find the <code>Route</code> module in Shared.fs and create the following route inside it.</p> <pre><code>let file = \"api/file\"\n</code></pre>"},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/#2-http-handler","title":"2. HTTP Handler","text":"<p>Find the <code>webApp</code> in Server.fs. Inside its <code>router</code> expression, add the following <code>get</code> expression.</p> <pre><code>open FSharp.Control.Tasks.V2\n\nlet webApp =\n    router {\n        //...other handlers\n        get Route.file (fun next ctx -&gt;\n            task {\n                let byteArray = System.IO.File.ReadAllBytes(\"~/files/file.xlsx\")\n                ctx.SetContentType \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n                ctx.SetHttpHeader \"Content-Disposition\" \"attachment;\"\n                return! ctx.WriteBytesAsync (byteArray)\n            })\n    }\n</code></pre> <p>What we're doing here is to read a file from the local drive, but where the file is retrieved from is irrelevant. Then, using <code>ctx</code>, which is of type <code>HttpContext</code>, we let the browser know about the type of data this handler is returning. The last line (again, using <code>ctx</code>) writes a byte array to the body of the HTTP response as well as handling some details that goes alongside this process.</p>"},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/#3-the-download-function","title":"3. The download function","text":"<p>Although not perfect, the best solution for handling the file download is creating an invisible download link, clicking it, and then removing it completely. The following block of code is all we need for this. Add it to the Index.fs file, somewhere above the <code>view</code> function.</p> <pre><code>open Fable.Core.JsInterop\nopen Shared\n\nlet downloadFile () =\n    let anchor = Browser.Dom.document.createElement \"a\"\n    anchor?style &lt;- \"display: none\"\n    anchor?href &lt;- Route.file\n    anchor?download &lt;- \"MyFile.xlsx\"\n    anchor.click()\n    anchor.remove()\n</code></pre> <p>You could also pass in the name of the file or the route to be hit as a parameter.</p> <p>Now, you can call the <code>downloadFile</code> function to initiate the file download.</p>"},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/#i-am-using-the-standard-template","title":"I am using the standard template","text":""},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/#1-define-the-route","title":"1. Define the route","text":"<p>Since the standard template uses Fable.Remoting, we need to edit our API definition first. Find your API type definition in <code>Shared.fs</code>. It's usually the last block of code. The one you see here is named IFileAPI, but the one you see in <code>Shared.fs</code> will be named differently. Edit this definition to have the <code>download</code> member you see below.</p> <pre><code>type IFileAPI =\n    { //...other routes \n      download : unit -&gt; Async&lt;byte[]&gt; }\n</code></pre>"},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/#2-add-the-route","title":"2. Add the route","text":"<p>Open the Server.fs file and find the API that implements the definition we've just edited. It should now have an error since we're not matching the definition at the moment. Add the following route to it</p> <pre><code>let download () = async {\n    let byteArray = System.IO.File.ReadAllBytes(\"/fileFolder/file.xlsx\")\n    return byteArray\n}\n</code></pre> <p>Make sure to replace \"/fileFolder/file.xlsx\" with the path to your file</p>"},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/#3-the-download-function_1","title":"3. The download function","text":"<p>Paste the following code into <code>Index.fs</code>, somewhere above the <code>view</code> function.</p> <pre><code>let downloadFile () =\n    async {\n        let! downloadedFile = todosApi.download ()\n        downloadedFile.SaveFileAs(\"downloaded-file.xlsx\")\n    }\n</code></pre> <p>The <code>SaveFileAs</code> funcion detects the mime-type/content-type automatically based on the file extension of the file input</p>"},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/#4-using-the-download-funciton","title":"4. Using the download funciton","text":"<p>Since the <code>downloadFile</code> function is asynchronous, we can't just call it anywhere in our view. The way we're going to deal with this is to create a <code>Msg</code> case and handle it in our <code>update</code> funciton.</p>"},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/#a-add-a-couple-of-new-cases-to-the-msg-type","title":"a. Add a couple of new cases to the Msg type","text":"<pre><code>type Msg =\n    //...other cases\n    | DownloadFile\n    | FileDownloaded of unit\n</code></pre>"},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/#b-handle-these-cases-in-the-update-function","title":"b. Handle these cases in the update function","text":"<pre><code>let update (msg: Msg) (model: Model): Model * Cmd&lt;Msg&gt; =\n        match msg with\n    //...other cases\n    | DownloadFile -&gt; model, Cmd.OfAsync.perform downloadFile () FileDownloaded\n    | FileDownloaded () -&gt; model, Cmd.none // You can do something else here\n</code></pre>"},{"location":"v4-recipes/client-server/serve-a-file-from-the-backend/#c-dispatch-this-message-using-a-ui-element","title":"c. Dispatch this message using a UI element","text":"<pre><code>Html.button [\n    prop.onClick (fun _ -&gt; dispatch DownloadFile)\n    prop.text \"Click to download\" \n]\n</code></pre> <p>Having added this last snippet of code into the <code>view</code> function, you will be able to download the file by clicking the button that will now be displayed in your UI. For more information visit the Fable.Remoting documentation</p>"},{"location":"v4-recipes/client-server/server-errors-on-client/","title":"How Do I Handle Server Exceptions on the Client?","text":"<p>SAFE Stack makes it easy to catch and handle exceptions raised by the server on the client. Though the way we make a call to the server from the client is different between the standard and the minimal template, the way we handle server errors on the client is the same in principle.</p>"},{"location":"v4-recipes/client-server/server-errors-on-client/#1-update-the-model","title":"1. Update the Model","text":"<p>Update the model to store the error details that we receive from the server. Find the <code>Model</code> type in <code>src/Client/Index.fs</code> and add it the following <code>Errors</code> field:</p> <pre><code>type Model =\n    { ... // the rest of the fields\n      Errors: string list }\n</code></pre> <p>Now, bind an empty list to the field record inside the <code>init</code> function:</p> <pre><code>let model =\n    { ... // the rest of the fields\n      Errors = [] }\n</code></pre>"},{"location":"v4-recipes/client-server/server-errors-on-client/#2-add-an-error-message-handler","title":"2. Add an Error Message Handler","text":"<p>We now add a new message to handle errors that we get back from the server after making a request. Add the following case to the <code>Msg</code> type:</p> <pre><code>type Msg =\n    | ... // other message cases\n    | GotError of exn\n</code></pre>"},{"location":"v4-recipes/client-server/server-errors-on-client/#3-handle-the-new-message","title":"3. Handle the new Message","text":"<p>In this simple example, we will simply capture the <code>Message</code> of the exception. Add the following line to the end of the pattern match inside the <code>update</code> function:</p> <pre><code>| GotError ex -&gt;\n    { model with Errors = ex.Message :: model.Errors }, Cmd.none\n</code></pre> <p>The following steps will vary depending on whether you\u2019re using the standard template or the minimal one.</p>"},{"location":"v4-recipes/client-server/server-errors-on-client/#4-connect-server-errors-to-elmish","title":"4. Connect Server Errors to Elmish","text":"<p>We now have to connect up the server response to the new message we created. Elmish has support for this through the <code>either</code> Cmd functions (instead of the <code>perform</code> functions). Make the following changes to your server call:</p>"},{"location":"v4-recipes/client-server/server-errors-on-client/#i-am-using-the-standard-template","title":"I Am Using the Standard Template","text":"<pre><code>let cmd = Cmd.OfAsync.perform todosApi.getTodos () GotTodos\n</code></pre> <p>\u2026and replace it with the following:</p> <pre><code>let cmd = Cmd.OfAsync.either todosApi.getTodos () GotTodos GotError\n</code></pre>"},{"location":"v4-recipes/client-server/server-errors-on-client/#i-am-using-the-minimal-template","title":"I Am Using the Minimal Template","text":"<pre><code>let cmd = Cmd.OfPromise.perform getHello () GotHello\n</code></pre> <p>\u2026and replace it with the following:</p> <pre><code>let cmd = Cmd.OfPromise.either getHello () GotHello GotError\n</code></pre>"},{"location":"v4-recipes/client-server/server-errors-on-client/#done","title":"Done!","text":"<p>Now, if you get an exception from the Server, its message will be added to the <code>Errors</code> field of the <code>Model</code> type. Instead of throwing the error, you can now display a meaningful text to the user like so:</p> <pre><code>[ for msg in errorMessages do\n    Html.p msg \n]\n</code></pre>"},{"location":"v4-recipes/client-server/share-code/","title":"How Do I Share Code Types Between the Client and the Server?","text":"<p>SAFE Stack makes it really simple and easy to share code between the client and the server, since both of them are written in F#. The client side is transpiled into JavaScript via webpack, whilst the server side is compiled down to .NET CIL. Serialization between both happens in the background, so you don't have to worry about it.</p>"},{"location":"v4-recipes/client-server/share-code/#types","title":"Types","text":"<p>Let\u2019s say the you have the following type in <code>src/Server/Server.fs</code>: <pre><code>type Customer =\n    { Id : Guid\n      Name : string\n      Email : string\n      PhoneNumber : string }\n</code></pre></p>"},{"location":"v4-recipes/client-server/share-code/#values-and-functions","title":"Values and Functions","text":"<p>And you have the following function that is used to validate this Customer type in <code>src/Client/Index.fs</code>: <pre><code>let customerIsValid customer =\n    (Guid.Empty = customer.Id\n    || String.IsNullOrEmpty customer.Name\n    || String.IsNullOrEmpty customer.Email\n    || String.IsNullOrEmpty customer.PhoneNumber)\n    |&gt; not\n</code></pre></p>"},{"location":"v4-recipes/client-server/share-code/#shared","title":"Shared","text":"<p>If at any point you realise you need to use both the <code>Customer</code> type and the <code>customerIsValid</code> function both in the Client and the Server, all you need to do is to move both of them to <code>Shared</code> project. You can either put them in the <code>Shared.fs</code> file, or create your own file in the Shared project (eg. <code>Customer.fs</code>). After this, you will be able to use both the <code>Customer</code> type and the <code>customerIsValid</code> function in both the Client and the Server.</p>"},{"location":"v4-recipes/client-server/share-code/#serialization","title":"Serialization","text":"<p>SAFE comes out of the box with [Fable.Remoting] or [Thoth] for serialization. These will handle transport of data seamlessly for you.</p>"},{"location":"v4-recipes/client-server/share-code/#considerations","title":"Considerations","text":"<p>Be careful not to place code in <code>Shared.fs</code> that depends on a Client or Server-specific dependency. If your code depends on <code>Fable</code> for example, in most cases it will not be suitable to place it in Shared, since it can only be used in Client. Similarly, if your types rely on .NET specific types in e.g. the framework class library (FCL), beware. Fable has built-in mappings for popular .NET types e.g. <code>System.DateTime</code> and <code>System.Math</code>, but you will have to write your own mappers otherwise.</p>"},{"location":"v4-recipes/client-server/upload-file-from-client/","title":"How do I upload a file from the client?","text":"<p>Fable makes it quick and easy to upload files from the client. Both the standard and the minimal template comes with Fable support by default.</p>"},{"location":"v4-recipes/client-server/upload-file-from-client/#1-create-a-file","title":"1. Create a File","text":"<p>Create a file in the client project named <code>FileUpload.fs</code> somewhere before the <code>Index.fs</code> file and insert the following:</p> <pre><code>module FileUpload\n\nopen Fable.React\nopen Fable.React.Props\nopen Fable.FontAwesome\nopen Fable.Core\nopen Fable.Core.JsInterop\n</code></pre>"},{"location":"v4-recipes/client-server/upload-file-from-client/#2-file-event-handler","title":"2. File Event Handler","text":"<p>Then, add the following. The <code>reader.onload</code> block will be executed once we select and confirm a file to be uploaded. Read the FileReader docs to find out more.</p> <pre><code>let handleFileEvent onLoad (fileEvent:Browser.Types.Event) =\n    let files:Browser.Types.FileList = !!fileEvent.target?files\n    if files.length &gt; 0 then\n        let reader = Browser.Dom.FileReader.Create()\n        reader.onload &lt;- (fun _ -&gt; reader.result |&gt; unbox |&gt; onLoad)\n        reader.readAsArrayBuffer(files.[0])\n</code></pre>"},{"location":"v4-recipes/client-server/upload-file-from-client/#3-create-the-ui-element","title":"3. Create the UI Element","text":"<p>This step varies depending on whether you're using the standard or the minimal template. Apply only the instructions under the appropriate heading.</p>"},{"location":"v4-recipes/client-server/upload-file-from-client/#im-using-the-standard-template","title":"I'm using the standard template","text":"<p>Insert the following block of code at the end of <code>FileUpload.fs</code>. This function will create a UI element to be used to upload files. Click here to find out more about Bulma's file input component.</p> <pre><code>open Feliz.Bulma\n\nlet createFileUpload onLoad =\n    Bulma.file [\n        Bulma.fileLabel.label [\n            Bulma.fileInput [\n                prop.onChange (handleFileEvent onLoad)\n            ]\n            Bulma.fileCta [\n                Bulma.fileLabel.label \"Choose a file...\"\n            ]\n        ]\n    ]\n</code></pre>"},{"location":"v4-recipes/client-server/upload-file-from-client/#im-using-the-minimal-template","title":"I'm using the minimal template","text":"<p>Insert the following block of code at the end of <code>FileUpload.fs</code>. This function will create a UI element to be used to upload files.</p> <pre><code>let createFileUpload onLoad =\n    let input = document.createElement \"INPUT\"\n    input.onchange &lt;- (handleFileEvent onLoad)\n</code></pre>"},{"location":"v4-recipes/client-server/upload-file-from-client/#4-use-the-ui-element","title":"4. Use the UI Element","text":"<p>Having followed all these steps, you can now use the <code>createFileUpload</code> function in <code>Index.fs</code> to create the UI element for uploading files. One thing to note is that <code>HandleFile</code> is a case of the discriminated union type <code>Msg</code> that's in <code>Index.fs</code>. You can use this message case to send the file from the client to the server.</p> <pre><code>FileUpload.createFileUpload (HandleFile &gt;&gt; dispatch)\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/","title":"How do I debug a SAFE app?","text":""},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#im-using-visual-studio","title":"I'm using Visual Studio","text":"<p>In order to debug Server code from Visual Studio, we need set the correct URLs in the project's debug properties.</p>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#debugging-the-server","title":"Debugging the Server","text":""},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#1-configure-launch-settings","title":"1. Configure launch settings","text":"<p>You can do this through the Server project's Properties/Debug editor or by editing the <code>launchSettings.json</code> file which is in the properties folder.</p> <p>After selecting the debug profile that you wish to edit (IIS Express or Server), you will need to set the App URL field to <code>http://localhost:5000</code> and Launch browser field to <code>http://localhost:8080</code>. The process is very similar for VS Mac.</p> <p>Once this is done, you can expect your <code>launchSettings.json</code> file to look something like this: <pre><code>{\n  \"iisSettings\": {\n    \"windowsAuthentication\": false,\n    \"anonymousAuthentication\": true,\n    \"iisExpress\": {\n      \"applicationUrl\": \"http://localhost:5000/\",\n      \"sslPort\": 44330\n    }\n  },\n  \"profiles\": {\n    \"IIS Express\": {\n      \"commandName\": \"IISExpress\",\n      \"launchBrowser\": true,\n      \"launchUrl\": \"http://localhost:8080/\",\n      \"environmentVariables\": {\n        \"ASPNETCORE_ENVIRONMENT\": \"Development\"\n      }\n    },\n    \"Server\": {\n      \"commandName\": \"Project\",\n      \"launchBrowser\": true,\n      \"launchUrl\": \"http://localhost:8080\",\n      \"environmentVariables\": {\n        \"ASPNETCORE_ENVIRONMENT\": \"Development\"\n      },\n      \"applicationUrl\": \"http://localhost:5000\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#2-start-the-client","title":"2. Start the Client","text":"<p>Since you will be running the server directly through Visual Studio, you cannot use a FAKE script to start the application, so launch the client directly using e.g. <code>npm run start</code>.</p>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#3-debug-the-server","title":"3. Debug the Server","text":"<p>Set the server as your Startup project, either using the drop-down menu at the top of the IDE or by right clicking on the project itself and selecting Set as Startup Project. Select the profile that you set up earlier and wish to launch from the drop-down at the top of the IDE. Either press the Play button at the top of the IDE or hit F5 on your keyboard to start the Server debugging and launch a browser pointing at the website.</p>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#debugging-the-client","title":"Debugging the Client","text":"<p>Although we write our client-side code using F#, it is being converted into JavaScript at runtime by Fable and executed in the browser. However, we can still debug it via the magic of source mapping. If you are using Visual Studio, you cannot directly connect to the browser debugger. You can, however, debug your client F# code using the browser's development tools.</p>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#1-set-breakpoints-in-client-code","title":"1. Set breakpoints in Client code","text":"<p>The exact instructions will depend on your browser, but essentially it simply involves:</p> <ul> <li>Opening the Developer tools panel (usually by hitting F12).</li> <li>Finding the F# file you want to add breakpoints to in the source of the website (look inside the webpack folder).</li> <li>Add breakpoints to it in your browser inspector.</li> </ul>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#im-using-vs-code","title":"I'm using VS Code","text":"<p>VS Code allows \"full stack\" debugging i.e. both the client and server. Prerequisites that you should install:</p>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#0-install-prerequisites","title":"0. Install Prerequisites","text":"<ul> <li>Install either Google Chrome or Microsoft Edge: Enables client-side debugging.</li> <li>Configure your browser with the following extensions:<ul> <li>Redux Dev Tools: Provides improved debugging support in Chrome with Elmish and access to Redux debugging.</li> <li>React Developer Tools: Provides access to React debugging in Chrome.</li> </ul> </li> <li>Configure VS Code with the following extensions:<ul> <li>Ionide: Provides F# support to Code.</li> <li>C#: Provides .NET Core debugging support.</li> </ul> </li> </ul>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#1-create-a-launchjson-file","title":"1. Create a launch.json file","text":"<p>Open the Command Palette using <code>Ctrl+Shift+P</code> and run <code>Debug: Add Configuration...</code>. This will ask you to choose a debugger; select <code>Ionide LaunchSettings</code>.</p> <p>This will create a <code>launch.json</code> file in the root of your solution and also open it in the editor.</p>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#2-update-the-configuration","title":"2. Update the Configuration","text":"<p>The only change required is to point it at the Server application, by replacing the <code>program</code> line with this:</p> <pre><code>\"program\": \"${workspaceFolder}/src/Server/bin/Debug/net6.0/Server.dll\",\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#3-configure-a-build-task","title":"3. Configure a build task","text":"<ul> <li>From the Command Palette, choose <code>Tasks: Configure Task</code>.</li> <li>Select <code>Create tasks.json file from template</code>. This will show you a list of pre-configured templates.</li> <li>Select <code>.NET Core</code>.</li> <li>Update the build directory using <code>\"options\": {\"cwd\": \"src/Server\"},</code> as shown below:</li> </ul> <pre><code>{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    // for the documentation about the tasks.json format\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"build\",\n            \"command\": \"dotnet\",\n            \"type\": \"shell\",\n            \"options\": {\"cwd\": \"src/Server\"}, \n            \"args\": [\n                \"build\",\n                \"debug-pt3.sln\",\n                // Ask dotnet build to generate full paths for file names.\n                \"/property:GenerateFullPaths=true\",\n                // Do not generate summary otherwise it leads to duplicate errors in Problems panel\n                \"/consoleloggerparameters:NoSummary\"\n            ],\n            \"group\": \"build\",\n            \"presentation\": {\n                \"reveal\": \"silent\"\n            },\n            \"problemMatcher\": \"$msCompile\"\n        }\n    ]\n}\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#4-debug-the-server","title":"4. Debug the Server","text":"<p>Either hit F5 or open the Debugging pane and press the Play button to build and launch the Server with the debugger attached. Observe that the Debug Console panel will show output from the server. The server is now running and you can set breakpoints and view the callstack etc.</p>"},{"location":"v4-recipes/developing-and-testing/debug-safe-app/#5-debug-the-client","title":"5. Debug the Client","text":"<ul> <li>Start the Client by running <code>dotnet fable watch -o output -s --run npm run start</code> from <code>&lt;repo root&gt;/src/Client/</code>.</li> <li>Open the Command Palette and run <code>Debug: Open Link</code>.</li> <li>When prompted for a url, type <code>http://localhost:8080/</code>. This will launch a browser which is pointed at the URL and connect the debugger to it.</li> <li>You can now set breakpoints in the generated <code>.fs.js</code> files within VS Code.</li> <li>Select the appropriate Debug Console you wish to view.</li> </ul> <p>If you find that your breakpoints aren't being hit, try stopping the Client, disconnecting the debugger and re-launching them both.</p> <p>To find out more about the VS Code debugger, see here.</p>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/","title":"How do I test the client?","text":"<p>Testing on the client is a little different than on the server.</p> <p>This is because the code which is ultimately being executed in the browser is JavaScript, translated from F# by Fable, and so it must be tested in a JavaScript environment.</p> <p>Furthermore, code that is shared between the Client and Server must be tested in both a dotnet environment and a JavaScript environment.</p> <p>The SAFE template uses a library called Fable.Mocha which allows us to run the same tests in both environments. It mirrors the Expecto API and works in much the same way.</p>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#im-using-the-standard-template","title":"I'm using the standard template","text":"<p>If you are using the standard template then there is nothing more you need to do in order to start testing your Client.</p> <p>In the tests/Client folder, there is a project named Client.Tests with a single script demonstrating how to use Mocha to test the TODO sample.</p> <p>Note the compiler directive here which makes sure that the Shared tests are only included when executing in a JavaScript (Fable) context. They are covered by Expecto under dotnet as you can see in Server.Tests.fs.</p>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#1-launch-the-test-server","title":"1. Launch the test server","text":"<p>In order to run the tests, instead of starting your application using <pre><code>dotnet run\n</code></pre> you should instead use <pre><code>dotnet run Runtests\n</code></pre></p>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#2-view-the-results","title":"2. View the results","text":"<p>Once the build is complete and the website is running, navigate to <code>http://localhost:8081/</code> in a web browser. You should see a test results page that looks like this:</p> <p></p> <p>This command builds and runs the Server test project too. If you want to run the Client tests alone, you can simply launch the test server using <code>npm run test:live</code>, which executes a command stored in <code>package.json</code>.</p>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#im-using-the-minimal-template","title":"I'm using the minimal template","text":"<p>If you are using the minimal template, you will need to first configure a test project as none are included.</p>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#1-add-a-test-project","title":"1. Add a test project","text":"<p>Create a .Net library called Client.Tests in the tests/Client subdirectory using the following commands:</p> <pre><code>dotnet new ClassLib -lang F# -n Client.Tests -o tests/Client\ndotnet sln add tests/Client\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#2-reference-the-client-project","title":"2. Reference the Client project","text":"<p>Reference the Client project from the Client.Tests project:</p> <pre><code>dotnet add tests/Client reference src/Client\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#3-add-the-fablemocha-package-to-test-project","title":"3. Add the Fable.Mocha package to Test project","text":"<p>Run the following command:</p> <pre><code>dotnet add tests/Client package Fable.Mocha\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#4-add-something-to-test","title":"4. Add something to test","text":"<p>Add this function to Client.fs in the Client project</p> <pre><code>let sayHello name = $\"Hello {name}\"\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#5-add-a-test","title":"5. Add a test","text":"<p>Replace the contents of <code>tests/Client/Library.fs</code> with the following code:</p> <pre><code>module Tests\n\nopen Fable.Mocha\n\nlet client = testList \"Client\" [\n    testCase \"Hello received\" &lt;| fun _ -&gt;\n        let hello = Client.sayHello \"SAFE V3\"\n\n        Expect.equal hello \"Hello SAFE V3\" \"Unexpected greeting\"\n]\n\nlet all =\n    testList \"All\"\n        [\n            client\n        ]\n\n[&lt;EntryPoint&gt;]\nlet main _ = Mocha.runTests all\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#6-add-test-web-page","title":"6. Add Test web page","text":"<p>Add a file called index.html to the tests/Client folder with following contents: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;SAFE Client Tests&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#7-add-test-webpack-config","title":"7. Add test webpack config","text":"<p>Add a file called webpack.tests.config.js to the root directory with the following contents:****</p> <pre><code>// Template for webpack.config.js in Fable projects\n// Find latest version in https://github.com/fable-compiler/webpack-config-template\n\n// In most cases, you'll only need to edit the CONFIG object (after dependencies)\n// See below if you need better fine-tuning of Webpack options\n\n// Dependencies. Also required: core-js, @babel/core,\n// @babel/preset-env, babel-loader, sass, sass-loader, css-loader, style-loader, file-loader, resolve-url-loader\nvar path = require('path');\nvar webpack = require('webpack');\nvar HtmlWebpackPlugin = require('html-webpack-plugin');\nvar CopyWebpackPlugin = require('copy-webpack-plugin');\n\nvar CONFIG = {\n    // The tags to include the generated JS and CSS will be automatically injected in the HTML template\n    // See https://github.com/jantimon/html-webpack-plugin\n    indexHtmlTemplate: 'tests/Client/index.html',\n    fsharpEntry: 'tests/Client/Library.fs.js',\n    outputDir: 'tests/Client',\n    assetsDir: 'tests/Client',\n    devServerPort: 8081,\n    // When using webpack-dev-server, you may need to redirect some calls\n    // to a external API server. See https://webpack.js.org/configuration/dev-server/#devserver-proxy\n    devServerProxy: undefined,\n    babel: undefined\n}\n\n// If we're running the webpack-dev-server, assume we're in development mode\nvar isProduction = !process.argv.find(v =&gt; v.indexOf('webpack-dev-server') !== -1);\nvar environment = isProduction ? 'production' : 'development';\nprocess.env.NODE_ENV = environment;\nconsole.log('Bundling for ' + environment + '...');\n\n// The HtmlWebpackPlugin allows us to use a template for the index.html page\n// and automatically injects &lt;script&gt; or &lt;link&gt; tags for generated bundles.\nvar commonPlugins = [\n    new HtmlWebpackPlugin({\n        filename: 'index.html',\n        template: resolve(CONFIG.indexHtmlTemplate)\n    })\n];\n\nmodule.exports = {\n    // In development, split the JavaScript and CSS files in order to\n    // have a faster HMR support. In production bundle styles together\n    // with the code because the MiniCssExtractPlugin will extract the\n    // CSS in a separate files.\n    entry: {\n        app: resolve(CONFIG.fsharpEntry)\n    },\n    // Add a hash to the output file name in production\n    // to prevent browser caching if code changes\n    output: {\n        path: resolve(CONFIG.outputDir),\n        filename: isProduction ? '[name].[hash].js' : '[name].js'\n    },\n    mode: isProduction ? 'production' : 'development',\n    devtool: isProduction ? 'source-map' : 'eval-source-map',\n    optimization: {\n        splitChunks: {\n            chunks: 'all'\n        },\n    },\n    // Besides the HtmlPlugin, we use the following plugins:\n    // PRODUCTION\n    //      - MiniCssExtractPlugin: Extracts CSS from bundle to a different file\n    //          To minify CSS, see https://github.com/webpack-contrib/mini-css-extract-plugin#minimizing-for-production\n    //      - CopyWebpackPlugin: Copies static assets to output directory\n    // DEVELOPMENT\n    //      - HotModuleReplacementPlugin: Enables hot reloading when code changes without refreshing\n    plugins: isProduction ?\n        commonPlugins.concat([\n            new CopyWebpackPlugin({ patterns: [{ from: resolve(CONFIG.assetsDir) }] }),\n        ])\n        : commonPlugins.concat([\n            new webpack.HotModuleReplacementPlugin(),\n        ]),\n    resolve: {\n        // See https://github.com/fable-compiler/Fable/issues/1490\n        symlinks: false\n    },\n    // Configuration for webpack-dev-server\n    devServer: {\n        publicPath: '/',\n        contentBase: resolve(CONFIG.assetsDir),\n        host: '0.0.0.0',\n        port: CONFIG.devServerPort,\n        proxy: CONFIG.devServerProxy,\n        hot: true,\n        inline: true\n    },\n    module: {\n        rules: [\n\n        ]\n    }\n};\n\nfunction resolve(filePath) {\n    return path.isAbsolute(filePath) ? filePath : path.join(__dirname, filePath);\n}\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#8-install-the-clients-dependencies","title":"8. Install the client's dependencies","text":"<pre><code>npm install\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/testing-the-client/#9-launch-the-test-website","title":"9. Launch the test website","text":"<pre><code>dotnet fable watch src/Client --run webpack-dev-server --config webpack.tests.config\n</code></pre> <p>Once the build is complete and the website is running, navigate to <code>http://localhost:8081/</code> in a web browser. You should see a test results page that looks like this:</p> <p></p>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/","title":"How do I test the Server?","text":"<p>Testing your Server code in a SAFE app is just the same as in any other dotnet app, and you can use the same tools and frameworks that you are familiar with. These include all of the usual suspects such as NUnit, XUnit, FSUnit, Expecto, FSCheck, AutoFixture etc.</p> <p>In this guide we will look at using Expecto, as this is included with the standard SAFE template.</p>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#im-using-the-standard-template","title":"I'm using the standard template","text":""},{"location":"v4-recipes/developing-and-testing/testing-the-server/#using-the-expecto-runner","title":"Using the Expecto runner","text":"<p>If you are using the standard template, then there is nothing more you need to do in order to start testing your Server code.</p> <p>In the tests/Server folder, there is a project named Server.Tests with a single script demonstrating how to use Expecto to test the TODO sample.</p> <p>In order to run the tests, instead of starting your application using <pre><code>dotnet run\n</code></pre></p> <p>you should instead use <pre><code>dotnet run RunTests\n</code></pre> This will execute the tests and print the results into the console window.</p> <p></p> <p>This method builds and runs the Client test project too, which can be slow. If you want to run the Server tests alone, you can simply navigate to the tests/Server directory and run the project using <code>dotnet run</code>.</p>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#using-dotnet-test-or-the-visual-studio-test-runner","title":"Using dotnet test or the Visual Studio Test runner","text":"<p>If you would like to use dotnet tests from the command line or the test runner that comes with Visual Studio, there are a couple of extra steps to follow.</p>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#1-install-the-test-adapters","title":"1. Install the Test Adapters","text":"<p>Run the following commands at the root of your solution: <pre><code>dotnet paket add Microsoft.NET.Test.Sdk -p Server.Tests\n</code></pre> <pre><code>dotnet paket add YoloDev.Expecto.TestSdk -p Server.Tests\n</code></pre></p>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#2-disable-entrypoint-generation","title":"2. Disable EntryPoint generation","text":"<p>Open your ServerTests.fsproj file and add the following element:</p> <pre><code>&lt;PropertyGroup&gt;\n    &lt;GenerateProgramFile&gt;false&lt;/GenerateProgramFile&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#3-discover-tests","title":"3. Discover tests","text":"<p>To allow your tests to be discovered, you will need to decorate them with a <code>[&lt;Tests&gt;]</code> attribute.</p> <p>The provided test would look like this: <pre><code>[&lt;Tests&gt;]\nlet server = testList \"Server\" [\n    testCase \"Adding valid Todo\" &lt;| fun _ -&gt;\n        let storage = Storage()\n        let validTodo = Todo.create \"TODO\"\n        let expectedResult = Ok ()\n\n        let result = storage.AddTodo validTodo\n\n        Expect.equal result expectedResult \"Result should be ok\"\n        Expect.contains (storage.GetTodos()) validTodo \"Storage should contain new todo\"\n]\n</code></pre></p>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#4-run-tests","title":"4. Run tests","text":"<p>There are now two ways to run these tests.</p> <p>From the command line, you can just run <pre><code>dotnet test tests/Server\n</code></pre> from the root of your solution.</p> <p>Alternatively, if you are using Visual Studio or VS Mac you can make use of the built-in test explorers.</p> <p></p>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#im-using-the-minimal-template","title":"I'm using the minimal template","text":"<p>If you are using the minimal template, you will need to first configure a test project as none are included.</p>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#1-add-a-test-project","title":"1. Add a test project","text":"<p>Create a .Net 5 console project called Server.Tests in the tests/Server folder.</p> <pre><code>dotnet new console -lang F# -n Server.Tests -o tests/Server\ndotnet sln add tests/Server\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#2-reference-the-server-project","title":"2. Reference the Server project","text":"<p>Reference the Server project from the Server.Tests project:</p> <pre><code>dotnet add tests/Server reference src/Server\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#3-add-expecto-to-the-test-project","title":"3. Add Expecto to the Test project","text":"<p>Run the following command:</p> <pre><code>dotnet add tests/Server package Expecto\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#4-add-something-to-test","title":"4. Add something to test","text":"<p>Update the Server.fs file in the Server project to extract the message logic from the router like so: <pre><code>let getMessage () = \"Hello from SAFE!\"\n\nlet webApp =\n    router {\n        get Route.hello (getMessage () |&gt; json )\n    }\n</code></pre></p>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#5-add-a-test","title":"5. Add a test","text":"<p>Replace the contents of <code>tests/Server/Program.fs</code> with the following:</p> <pre><code>open Expecto\n\nlet server = testList \"Server\" [\n    testCase \"Message returned correctly\" &lt;| fun _ -&gt;\n        let expectedResult = \"Hello from SAFE!\"        \n        let result = Server.getMessage()\n        Expect.equal result expectedResult \"Result should be ok\"\n]\n\n[&lt;EntryPoint&gt;]\nlet main _ = runTests defaultConfig server\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#6-run-the-test","title":"6. Run the test","text":"<pre><code>dotnet run -p tests/Server\n</code></pre> <p>This will print out the results in the console window</p> <p></p>"},{"location":"v4-recipes/developing-and-testing/testing-the-server/#7-using-dotnet-test-or-the-visual-studio-test-explorer","title":"7. Using dotnet test or the Visual Studio Test Explorer","text":"<p>Add the libraries <code>Microsoft.NET.Test.Sdk</code> and <code>YoloDev.Expecto.TestSdk</code> to your Test project, using NuGet.</p> <p>The way you do this will depend on whether you are using NuGet directly or via Paket. See this recipe for more details.</p> <p>You can now add <code>[&lt;Test&gt;]</code> attributes to your tests so that they can be discovered, and then run them using the dotnet tooling in the same way as explained earlier for the standard template.</p>"},{"location":"v4-recipes/developing-and-testing/using-hot-reload/","title":"How do I use hot reload?","text":"<p>Hot reload is a great time-saving technology and something that every developer will find useful. Whenever changes are made to code, they are immediately reflected in the running application without needing to manually redeploy. The specific way that this is achieved depends on the nature of the application.</p> <p>In a SAFE app we have two distinct components, the Client and the Server. Whether you are using the minimal or standard SAFE template, there is nothing more you need to do in order to get started with hot reload.</p>"},{"location":"v4-recipes/developing-and-testing/using-hot-reload/#client-reloading","title":"Client reloading","text":"<p>If you deploy your application and then make a change in the Client, after a moment it will be reflected in the browser without a full re-deployment. Importantly, the state of your application will be retained across the deployment, so you can continue where you left off. This is achieved using the hot module replacement functionality provided by webpack.</p>"},{"location":"v4-recipes/developing-and-testing/using-hot-reload/#to-add-hot-module-replacement-manually","title":"To Add Hot Module Replacement manually","text":"<p>If your client project has been hand-rolled, or you simply wish to see how to add it from scratch:</p>"},{"location":"v4-recipes/developing-and-testing/using-hot-reload/#1-configure-the-webpack-dev-server","title":"1. Configure the Webpack Dev Server","text":"<p>Add the following to the <code>devServer</code> object of your webpack config:</p> <pre><code>var devServer = {\n    // other fields elided...\n    hot: true,\n    proxy : {\n        // Redirect websocket requests that start with /socket/ to the server on the port 5000\n        // This is used by Hot Module Replacement\n        '/socket/**': {\n            target: 'http://localhost:5000',\n            ws: true\n        }\n    }\n}\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/using-hot-reload/#2-configure-webpack-module-exports","title":"2. Configure webpack module exports","text":"<p>Import and create an instance <code>HotModuleReplacementPlugin</code> at the top of the webpack configuration file, and ensure that the plugin is added to <code>module.exports</code>:</p> <pre><code>// Import and create the HMR plugin\nvar { HotModuleReplacementPlugin } = require('webpack');\nvar hmrPlugin = new HotModuleReplacementPlugin();\n\n// other configuration...\n\nmodule.exports = {\n    // Add the HMR plugin to the module\n    plugins : [ /* other plugins... */, hmrPlugin ]\n}\n</code></pre>"},{"location":"v4-recipes/developing-and-testing/using-hot-reload/#3-update-your-f-client-app","title":"3. Update your F# client app","text":"<p>First, add the Fable.Elmish.Hmr package to the client:</p> <pre><code>dotnet add package Fable.Elmish.Hmr\n</code></pre> <p>Then, open the Elmish.HMR namespace in your app:</p> <pre><code>#if DEBUG\nopen Elmish.Debug\nopen Elmish.HMR\n#endif\n</code></pre> <p>Best practice is to include hot module reloading in debug (not production) mode only, since production applications will not benefit from HMR and will only result in an increased bundle size.</p>"},{"location":"v4-recipes/developing-and-testing/using-hot-reload/#server-reloading","title":"Server reloading","text":"<p>Server reloading isn't quite as fully automated.</p> <p>If you make a change in the Server code and save your work, the project will automatically rebuild and launch itself. Once this is complete however you will need to refresh your browser to see any visual changes.</p> <p>If you are using the minimal template, you need to make sure you launch the Server using <code>dotnet watch run</code> rather than just <code>dotnet run</code>. The standard template takes care of this step for you using its FAKE build script. If you have already restored your NuGet dependencies, you can get a little boost in restart speed by using <code>dotnet watch run --no-restore</code> as well.</p>"},{"location":"v4-recipes/javascript/import-js-module/","title":"How do I import a JavaScript module?","text":"<p>Sometimes you need to use a JS library directly, instead of using it through a wrapper library that makes it easy to use from F# code. In this case you need to import a module from the library. Here are the most common import patterns used in JS.</p>"},{"location":"v4-recipes/javascript/import-js-module/#default-export","title":"Default export","text":""},{"location":"v4-recipes/javascript/import-js-module/#setup","title":"Setup","text":"<p>In most cases components use the default export syntax which is when the the component being exported from the module becomes available. For example, if the module being imported below looked something like: <pre><code>// module-name\nconst foo = () =&gt; \"hello\"\n\nexport default foo\n</code></pre> We can use the below syntax to have access to the function <code>foo</code>. <pre><code>import foo from 'module-name' // JS\n</code></pre> <pre><code>let foo = importDefault \"module-name\" // F#\n</code></pre></p>"},{"location":"v4-recipes/javascript/import-js-module/#testing-the-import","title":"Testing the import","text":"<p>To ensure that the import was successful you can console log the value and you should see the value in the browsers console window which you can get to by right-clicking and selecting the Inspect Element. <pre><code>Browser.Dom.console.log(\"imported value\", foo)\n</code></pre></p>"},{"location":"v4-recipes/javascript/import-js-module/#example","title":"Example","text":"<p>An example of this in use is how React is imported <pre><code>import React from \"react\"\n\n// Although in the newer versions of React this is uneeded\n</code></pre></p>"},{"location":"v4-recipes/javascript/import-js-module/#named-export","title":"Named export","text":""},{"location":"v4-recipes/javascript/import-js-module/#setup_1","title":"Setup","text":"<p>In some cases components can use the named export syntax. In the below case \"module-name\" has an object/function/class that is called <code>bar</code>. By referncing it below it is brought into the current scope.  For example, if the module below contained something like: <pre><code>export const bar (x,y) =&gt; x + y \n</code></pre> We can directly access the function with the below syntax  <pre><code>import { bar } from \"module-name\" // JS\n</code></pre> <pre><code>let bar = import \"bar\" \"module-name\" // F#\n</code></pre></p>"},{"location":"v4-recipes/javascript/import-js-module/#testing-the-import_1","title":"Testing the import","text":"<p>To ensure that the import was successful you can console log the value and you should see the value in the browsers console window which you can get to by right-clicking and selecting the Inspect Element. <pre><code>Browser.Dom.console.log(\"imported value\", bar)\n</code></pre></p>"},{"location":"v4-recipes/javascript/import-js-module/#example_1","title":"Example","text":"<p>An example of this is how React hooks are imported <pre><code>import { useState } from \"react\"\n</code></pre></p>"},{"location":"v4-recipes/javascript/import-js-module/#entire-module-contents","title":"Entire module contents","text":"<p>In rare cases you may have to import an entire module's contents and provide an alias in the below case we named it myModule. You can now use dot notation to access anything that is exported from module-name. For example, if the module being imported below includes an export to a function <code>doAllTheAmazingThings()</code> you could access it like: <pre><code>myModule.doAllTheAmazingThings()\n</code></pre> <pre><code>import * as myModule from 'module-name' // JS\n</code></pre> <pre><code>let myModule = importAll \"module-name\" // F#\n</code></pre></p>"},{"location":"v4-recipes/javascript/import-js-module/#testing-the-import_2","title":"Testing the import","text":"<p>To ensure that the import was successful you can console log the value and you should see the value in the browsers console window which you can get to by right-clicking and selecting the Inspect Element. <pre><code>Browser.Dom.console.log(\"imported value\", myModule)\n</code></pre></p>"},{"location":"v4-recipes/javascript/import-js-module/#example_2","title":"Example","text":"<p>An example of this is another way to import React  <pre><code>import * as React from \"react\"\n\n// Uncommon since importDefault is the standard\n</code></pre></p>"},{"location":"v4-recipes/javascript/import-js-module/#more-information","title":"More information","text":"<p>See the Fable docs for more ways to import modules and use JavaScript from Fable.</p>"},{"location":"v4-recipes/javascript/third-party-react-package/","title":"Add Support for a Third Party React Library","text":"<p>To use a third-party React library in a SAFE application, you need to write an F# wrapper around it. There are two ways for doing this - using Fable.React or using Feliz.</p>"},{"location":"v4-recipes/javascript/third-party-react-package/#prerequisites","title":"Prerequisites","text":"<p>This recipe uses the react-d3-speedometer NPM package for demonstration purposes. Add it to your Client before continuing.</p>"},{"location":"v4-recipes/javascript/third-party-react-package/#fablereact-setup","title":"Fable.React - Setup","text":""},{"location":"v4-recipes/javascript/third-party-react-package/#1-create-a-new-file","title":"1. Create a new file","text":"<p>Create an empty file named <code>ReactSpeedometer.fs</code> in the Client project above <code>Index.fs</code> and insert the following statements at the beginning of the file.</p> <pre><code>module ReactSpeedometer\n\nopen Fable.Core\nopen Fable.Core.JsInterop\nopen Fable.React\n</code></pre>"},{"location":"v4-recipes/javascript/third-party-react-package/#2-define-the-props","title":"2. Define the Props","text":"<p>Prop represents the props of the React component. In this recipe, we're using the props listed here for <code>react-d3-speedometer</code>. We model them in Fable.React using a discriminated union.</p> <pre><code>type Prop =\n    | Value of int\n    | MinValue of int\n    | MaxValue of int \n    | StartColor of string\n</code></pre> <p>One difference to note is that we use PascalCase rather than camelCase.</p> <p>Note that we can model any props here, both simple values and \"event handler\"-style ones.</p>"},{"location":"v4-recipes/javascript/third-party-react-package/#3-write-the-component","title":"3. Write the Component","text":"<p>Add the following function to the file. Note that the last argument passed into the <code>ofImport</code> function is a list of <code>ReactElements</code> to be used as children of the react component. In this case, we are passing an empty list since the component doesn't have children.</p> <pre><code>let reactSpeedometer (props : Prop list) : ReactElement =\n    let propsObject = keyValueList CaseRules.LowerFirst props // converts Props to JS object\n    ofImport \"default\" \"react-d3-speedometer\" propsObject [] // import the default function/object from react-d3-speedometer\n</code></pre>"},{"location":"v4-recipes/javascript/third-party-react-package/#4-use-the-component","title":"4. Use the Component","text":"<p>With all these in place, you can use the React element in your client like so:</p> <pre><code>open ReactSpeedometer\n\nreactSpeedometer [\n    Prop.Value 10 // Since Value is already decalred in HTMLAttr you can use Prop.Value to tell the F# compiler its of type Prop and not HTMLAttr\n    MaxValue 100\n    MinValue 0 \n    StartColor \"red\"\n    ]\n</code></pre>"},{"location":"v4-recipes/javascript/third-party-react-package/#feliz-setup","title":"Feliz - Setup","text":"<p>If you don't already have Feliz installed, add it to your client. In the Client projects <code>Index.fs</code> add the following snippets</p> <pre><code>open Fable.Core.JsInterop\n</code></pre> <p>Within the view function  <pre><code>Feliz.Interop.reactApi.createElement (importDefault \"react-d3-speedometer\", createObj [\n    \"minValue\" ==&gt; 0\n    \"maxValue\" ==&gt; 100\n    \"value\" ==&gt; 10\n])\n</code></pre></p> <ul> <li><code>createElement</code> from <code>Feliz.ReactApi.IReactApi</code> takes the component you're wrapping react-d3-speedometer, the props that component takes and creates a ReactComponent we can use in F#.</li> <li><code>importDefault</code> from <code>Fable.Core.JsInterop</code> is giving us access to the component and is equivalent to  <pre><code>import ReactSpeedometer from \"react-d3-speedometer\"\n</code></pre> The reason for using <code>importDefault</code> is the documentation for the component uses a default export \"ReactSpeedometer\". Please find a list of common import statetments at the end of this recipe</li> </ul> <p>As a quick check to ensure that the library is being imported and we have no typos you can <code>console.log</code> the following at the top within the view function  <pre><code>Browser.Dom.console.log(\"REACT-D3-IMPORT\", importDefault \"react-d3-speedometer\")\n</code></pre> In the console window (which can be reached by right-clicking and selecting Insepct Element) you should see some output from the above log.  If nothing is being seen you may need a slightly different import statement, please refer to this recipe.</p> <ul> <li><code>createObj</code> from <code>Fable.Core.JsInterop</code> takes a sequence of <code>string * obj</code> which is a prop name and value for the component, you can find the full prop list for react-d3-speedometer here.</li> <li>Using <code>==&gt;</code> (short hand for <code>prop.custom</code>) to transform the sequence into a JavaScript object </li> </ul> <p><pre><code>createObj [\n    \"minValue\" ==&gt; 0\n    \"maxValue\" ==&gt; 10\n]\n</code></pre> Is equivalent to  <pre><code>{ minValue: 0, maxValue: 10 }\n</code></pre></p> <p>That's the bare minimum needed to get going!</p>"},{"location":"v4-recipes/javascript/third-party-react-package/#next-steps-for-feliz","title":"Next steps for Feliz","text":"<p>Once your component is working you may want to extract out the logic so that it can be used in multiple pages of your app. For a full detailed tutorial head over to this blog post!</p>"},{"location":"v4-recipes/package-management/add-npm-package-to-client/","title":"How do I add an NPM package to the Client?","text":"<p>When you want to call a JavaScript library from your Client, it is easy to import and reference it using NPM.</p> <p>Run the following command: <pre><code>npm install name-of-package\n</code></pre></p> <p>This will download the package into the solution's node_modules folder. </p> <p>You will also see a reference to the package in the Client's package.json file:  <pre><code>\"dependencies\": {\n    \"name-of-package\": \"^1.0.0\"\n}\n</code></pre></p>"},{"location":"v4-recipes/package-management/add-nuget-package-to-client/","title":"How do I add a NuGet package to the Client?","text":"<p>Adding packages to the Client project is a very similar process to the Server, with a few key differences:</p> <ul> <li> <p>Any references to the <code>Server</code> directory should be <code>Client</code></p> </li> <li> <p>Client code written in F# is converted into JavaScript using Fable. Because of this, we must be careful to only reference libraries which are Fable compatible.</p> </li> <li> <p>If the NuGet package uses any JS libraries you must install them.   For simplicity, use Femto to sync - if the NuGet package is compatible - or install via NPM manually, if not.</p> </li> </ul> <p>There are lots of great libraries available to choose from.</p>"},{"location":"v4-recipes/package-management/add-nuget-package-to-server/","title":"How do I add a NuGet package to the Server?","text":"<p>You can add NuGet packages to the server to give it more capabilities. You can download a wide variety of packages from the official NuGet site.</p> <p>In this example we will add the FsToolkit ErrorHandling package package.</p>"},{"location":"v4-recipes/package-management/add-nuget-package-to-server/#im-using-the-standard-template-paket","title":"I'm using the standard template (Paket)","text":""},{"location":"v4-recipes/package-management/add-nuget-package-to-server/#1-add-the-package","title":"1. Add the package","text":"<p>Navigate to the root directory of your solution and run:</p> <pre><code>dotnet paket add FsToolkit.ErrorHandling -p Server\n</code></pre> <p>This will add an entry to both the solution paket.dependencies file and the Server project's paket.reference file, as well as update the lock file with the updated dependency graph.</p> <p>Find information on how you can convert your project from NuGet to Paket here.</p> <p>For a detailed explanation of package management using Paket, visit the official docs.</p>"},{"location":"v4-recipes/package-management/add-nuget-package-to-server/#im-using-the-minimal-template-nuget","title":"I'm using the minimal template (NuGet)","text":""},{"location":"v4-recipes/package-management/add-nuget-package-to-server/#1-navigate-to-the-server-project-directory","title":"1. Navigate to the Server project directory","text":""},{"location":"v4-recipes/package-management/add-nuget-package-to-server/#2-add-the-package","title":"2. Add the package","text":"<p>Run the following command:</p> <pre><code>dotnet add package FsToolkit.ErrorHandling\n</code></pre> <p>Once you have done this, you will find an element in your fsproj file which looks like this: <pre><code>&lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"FsToolkit.ErrorHandling\" Version=\"1.4.3\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre></p> <p>You can also achieve the same thing using the Visual Studio Package Manager, the VS Mac Package Manager or the Package Manager Console.</p> <p>For a detailed explanation of package management using NuGet, visit the official docs.</p>"},{"location":"v4-recipes/package-management/migrate-to-nuget/","title":"How do I migrate to NuGet from Paket?","text":"<p>Note that the minimal template uses NuGet by default. This recipe only applies to the full template.</p> <p>Paket is a fully featured package manager that acts as an alternative to the NuGet package manager commonly used in .NET.</p> <p>It can help you reference libraries from NuGet, Git repositories or Http resources. It also provides precise control over your dependencies, separating direct and transitive references and capturing the exact configuration with each commit. You can find out more at the Paket website.</p> <p>For most use cases, we would recommend sticking with Paket. If, however, you are in a position where you wish to remove it and revert back to the NuGet package manager, you can easily do so with the following steps.</p>"},{"location":"v4-recipes/package-management/migrate-to-nuget/#1-remove-paket-targets-import-from-fsproj-files","title":"1. Remove Paket targets import from .fsproj files","text":"<p>In every project's <code>.fsproj</code> file you will find the following line. Remove it and save.</p> <pre><code>&lt;Import Project=\"..\\..\\.paket\\Paket.Restore.targets\" /&gt;\n</code></pre>"},{"location":"v4-recipes/package-management/migrate-to-nuget/#2-remove-paketdependencies","title":"2. Remove paket.dependencies","text":"<p>You will find this file at the root of your solution. Remove it from your solution if included and then delete it.</p>"},{"location":"v4-recipes/package-management/migrate-to-nuget/#3-add-project-dependencies-via-nuget","title":"3. Add project dependencies via NuGet","text":"<p>Each project directory will contain a <code>paket.references</code> file. This lists all the NuGet packages that the project requires.</p> <p>Inside a new <code>ItemGroup</code> in the project's <code>.fsproj</code> file you will need to add an entry for each of these packages.</p> <pre><code>&lt;ItemGroup&gt;\n  &lt;PackageReference Include=\"Azure.Core\" Version=\"1.24\" /&gt;\n  &lt;PackageReference Include=\"AnotherPackage\" Version=\"2.0.1\" /&gt;\n  &lt;!--...add entry for each package in the references file...--&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <p>You can find the version of each package in the <code>paket.lock</code> file at the root of the solution. The version number is contained in brackets next to the name of the package at the first level of indentation. For example, in this case Azure.Core is version 1.24: </p> <pre><code>Azure.Core (1.24)\n    Microsoft.Bcl.AsyncInterfaces (&gt;= 1.1.1)\n    System.Diagnostics.DiagnosticSource (&gt;= 4.6)\n    System.Memory.Data (&gt;= 1.0.2)\n    System.Numerics.Vectors (&gt;= 4.5)\n    System.Text.Encodings.Web (&gt;= 4.7.2)\n    System.Text.Json (&gt;= 4.7.2)\n    System.Threading.Tasks.Extensions (&gt;= 4.5.4)\n</code></pre>"},{"location":"v4-recipes/package-management/migrate-to-nuget/#4-remove-remaining-paket-files","title":"4. Remove remaining paket files","text":"<p>Once you have added all of your dependencies to the relevant <code>.fsproj</code> files, you can remove the folowing files and folders from your solution.</p> <p>Files: * <code>paket.lock</code> * <code>paket.dependencies</code>  * all of the <code>paket.references</code> files</p> <p>Folders: * <code>.paket</code>  * <code>paket-files</code> </p>"},{"location":"v4-recipes/package-management/migrate-to-nuget/#5-remove-paket-tool","title":"5. Remove paket tool","text":"<p>If you open <code>.config/dotnet-tools.json</code> you will find an entry for paket. Remove it.</p> <p>Alternatively, run </p> <p><pre><code>dotnet tool uninstall paket\n</code></pre> at the root of your solution.</p>"},{"location":"v4-recipes/package-management/migrate-to-paket/","title":"How do I migrate to Paket from NuGet?","text":"<p>Paket is a fully featured package manager that acts as an alternative to the NuGet package manager.</p> <p>It can help you reference libraries from NuGet, Git repositories or Http resources. It also provides precise control over your dependencies, separating direct and transitive references and capturing the exact configuration with each commit. You can find out more at the Paket website.</p> <p>Note that the standard template uses Paket by default. This recipe only applies to the minimal template.</p>"},{"location":"v4-recipes/package-management/migrate-to-paket/#1-install-and-restore-paket","title":"1. Install and restore Paket","text":"<pre><code>dotnet tool install paket\ndotnet tool restore\n</code></pre>"},{"location":"v4-recipes/package-management/migrate-to-paket/#2-run-the-migration","title":"2. Run the Migration","text":"<p>Run this command to move existing NuGet references to Paket from your packages.config or .fsproj file: <pre><code>dotnet paket convert-from-nuget\n</code></pre></p> <p>This will add three files to your solution, all of which should be committed to source control:</p> <ul> <li>paket.dependencies: This will be at the solution root and contains the top level list of dependencies for your project. It is also used to specify any rules such as where they should be downloaded from and which versions etc.</li> <li>paket.lock: This will also be at the solution root and contains the concrete resolution of all direct and transitive dependencies.</li> <li>paket.references: There will be one of these in each project directory. It simply specifies which packages the project requires.</li> </ul> <p>For a more detailed explanation of this process see the official migration guide.</p> <p>In the case where you have added a NuGet project to a solution which is already using paket, run this command with the option <code>--force</code>.</p> <p>If you are working in Visual Studio and wish to see your Paket files in the Solution Explorer, you will need to add both the paket.lock and any paket.references files created in your project directories during the last step to your solution.</p>"},{"location":"v4-recipes/package-management/sync-nuget-and-npm-packages/","title":"How do I ensure NPM and NuGet packages stay in sync?","text":"<p>SAFE Stack uses Fable bindings, which are NuGet packages that provide idiomatic and type-safe wrappers around native JavaScript APIs. These bindings often rely on third-party JavaScript libraries distributed via the NPM registry. This leads to the problem of keeping both the NPM package in sync with its corresponding NuGet F# wrapper. Femto is a dotnet CLI tool that solves this issue.</p> <p>For in-depth information about Femto, see Introducing Femto.</p>"},{"location":"v4-recipes/package-management/sync-nuget-and-npm-packages/#1-install-femto","title":"1. Install Femto","text":"<p>Navigate to the root folder of the solution and execute the following command: <pre><code>dotnet tool install femto\n</code></pre></p>"},{"location":"v4-recipes/package-management/sync-nuget-and-npm-packages/#2-analyse-dependencies","title":"2. Analyse Dependencies","text":"<p>In the root directory, run the following: <pre><code>dotnet femto ./src/Client\n</code></pre></p> <p>alternatively, you can call femto directly from <code>./src/Client</code>:</p> <pre><code>cd ./src/Client\ndotnet femto\n</code></pre> <p>This will give you a report of discrepancies between the NuGet packages and the NPM packages for the project, as well as steps to take in order to resolve them.</p>"},{"location":"v4-recipes/package-management/sync-nuget-and-npm-packages/#3-resolve-dependencies","title":"3. Resolve Dependencies","text":"<p>To sync your NPM dependencies with your NuGet dependencies, you can either manually follow the steps returned by step 2, or resolve them automatically using the following command: <pre><code>dotnet femto ./src/Client --resolve\n</code></pre></p>"},{"location":"v4-recipes/package-management/sync-nuget-and-npm-packages/#done","title":"Done!","text":"<p>Keeping your NPM dependencies in sync with your NuGet packages is now as easy as repeating step 3. Of course, you can instead repeat the step 2 and resolve packages manually, too.</p>"},{"location":"v4-recipes/storage/use-litedb/","title":"How Do I Use LiteDB?","text":"<p>The default template uses in-memory storage. This recipe will show you how to replace the in-memory storage with LiteDB in the form of LiteDB.FSharp.</p> <p>If you're using the minimal template, the first steps will show you how to add a LiteDB database; the remaining section of this recipe are designed to work off the default template's starter app.</p>"},{"location":"v4-recipes/storage/use-litedb/#1-add-litedbfsharp","title":"1. Add LiteDB.FSharp","text":"<p>Add the LiteDB.FSharp NuGet package to the server project.</p>"},{"location":"v4-recipes/storage/use-litedb/#2-create-the-database","title":"2. Create the database","text":"<p>Replace the use of the <code>ResizeArray</code> in the <code>Storage</code> type with a database and collection:</p> <pre><code>open LiteDB.FSharp\nopen LiteDB\n\ntype Storage () =\n    let database =\n        let mapper = FSharpBsonMapper()\n        let connStr = \"Filename=Todo.db;mode=Exclusive\"\n        new LiteDatabase (connStr, mapper)\n    let todos = database.GetCollection&lt;Todo&gt; \"todos\"\n</code></pre> <p>LiteDb is a file-based database, and will create the file if it does not exist automatically.</p> <p>This will create a database file <code>Todo.db</code> in the <code>Server</code> folder. The option <code>mode=Exclusive</code> is added for MacOS support (see this issue).</p> <p>See here for more information on connection string arguments.</p> <p>See the official docs for details on constructor arguments.</p>"},{"location":"v4-recipes/storage/use-litedb/#3-implement-the-rest-of-the-repository","title":"3. Implement the rest of the repository","text":"<p>Replace the implementations of <code>GetTodos</code> and <code>AddTodo</code> as follows:</p> <pre><code>    /// Retrieves all todo items.\n    member _.GetTodos () =\n        todos.FindAll () |&gt; List.ofSeq\n\n    /// Tries to add a todo item to the collection.\n    member _.AddTodo (todo:Todo) =\n        if Todo.isValid todo.Description then\n            todos.Insert todo |&gt; ignore\n            Ok ()\n        else\n            Error \"Invalid todo\"\n</code></pre>"},{"location":"v4-recipes/storage/use-litedb/#4-initialise-the-database","title":"4. Initialise the database","text":"<p>Modify the existing \"priming\" so that it first checks if there are any records in the database before inserting data:</p> <pre><code>if storage.GetTodos() |&gt; Seq.isEmpty then\n    storage.AddTodo(Todo.create \"Create new SAFE project\") |&gt; ignore\n    storage.AddTodo(Todo.create \"Write your app\") |&gt; ignore\n    storage.AddTodo(Todo.create \"Ship it !!!\") |&gt; ignore\n</code></pre>"},{"location":"v4-recipes/storage/use-litedb/#5-make-todo-compatible-with-litedb","title":"5. Make Todo compatible with LiteDb","text":"<p>Add the CLIMutable attribute to the <code>Todo</code> record in <code>Shared.fs</code></p> <pre><code>[&lt;CLIMutable&gt;]\ntype Todo =\n    { Id : Guid\n      Description : string }\n</code></pre> <p>This is required to allow LiteDB to hydrate (read) data into F# records.</p>"},{"location":"v4-recipes/storage/use-litedb/#all-done","title":"All Done!","text":"<ul> <li>Run the application.</li> <li>You will see that a database has been created in the Server folder and that you are presented with the standard TODO list.</li> <li>Add an item and restart the application; observe that your data is still there.</li> </ul>"},{"location":"v4-recipes/storage/use-sqlprovider-ssdt/","title":"Using SQLProvider SQL Server SSDT","text":""},{"location":"v4-recipes/storage/use-sqlprovider-ssdt/#creating-a-safetodo-database-with-azure-data-studio","title":"Creating a \"SafeTodo\" Database with Azure Data Studio","text":""},{"location":"v4-recipes/storage/use-sqlprovider-ssdt/#connecting-to-a-sql-server-instance","title":"Connecting to a SQL Server Instance","text":"<p>1) In the \"Connections\" tab, click the \"New Connection\" button</p> <p></p> <p>2) Enter your connection details, leaving the \"Database\" dropdown set to <code>&lt;Default&gt;</code>.</p> <p></p>"},{"location":"v4-recipes/storage/use-sqlprovider-ssdt/#creating-a-new-safetodo-database","title":"Creating a new \"SafeTodo\" Database","text":"<ul> <li>Right click your server and choose \"New Query\"</li> <li>Execute this script:</li> </ul> <pre><code>USE master\nGO\nIF NOT EXISTS (\n SELECT name\n FROM sys.databases\n WHERE name = N'SafeTodo'\n)\n CREATE DATABASE [SafeTodo];\nGO\nIF SERVERPROPERTY('ProductVersion') &gt; '12'\n ALTER DATABASE [SafeTodo] SET QUERY_STORE=ON;\nGO\n</code></pre> <ul> <li>Right click the \"Databases\" folder and choose \"Refresh\" to see the new database.</li> </ul> <p>NOTE: Alternatively, if you don't want to manually create the new database, you can install the \"New Database\" extension in Azure Data Studio which gives you a \"New Database\" option when right clicking the \"Databases\" folder.</p>"},{"location":"v4-recipes/storage/use-sqlprovider-ssdt/#create-a-todos-table","title":"Create a \"Todos\" Table","text":"<pre><code>CREATE TABLE [dbo].[Todos]\n(\n  [Id] UNIQUEIDENTIFIER NOT NULL PRIMARY KEY,\n  [Description] NVARCHAR(500) NOT NULL,\n  [IsDone] BIT NOT NULL\n)\n</code></pre>"},{"location":"v4-recipes/storage/use-sqlprovider-ssdt/#creating-an-ssdt-project-sqlproj","title":"Creating an SSDT Project (.sqlproj)","text":"<p>At this point, you should have a SAFE Stack solution and a minimal \"SafeTodo\" SQL Server database with a \"Todos\" table. Next, we will use Azure Data Studio with the \"SQL Database Projects\" extension to create a new SSDT (SQL Server Data Tools) .sqlproj that will live in our SAFE Stack .sln. </p> <p>1) Install the \"SQL Database Projects\" extension.</p> <p>2) Right click the SafeTodo database and choose \"Create Project From Database\" (this option is added by the \"SQL Database Projects\" extension)</p> <p></p> <p>3) Configure a path within your SAFE Stack solution folder and a project name and then click \"Create\". NOTE: If you choose to create an \"ssdt\" subfolder as I did, you will need to manually create this subfolder first.</p> <p></p> <p>4) You should now be able to view your SQL Project by clicking the \"Projects\" tab in Azure Data Studio.</p> <p></p> <p>5) Finally, right click the SafeTodoDB project and select \"Build\". This will create a .dacpac file which we will use in the next step.</p>"},{"location":"v4-recipes/storage/use-sqlprovider-ssdt/#create-a-todorepository-using-the-new-ssdt-provider-in-sqlprovider","title":"Create a TodoRepository Using the new SSDT provider in SQLProvider","text":""},{"location":"v4-recipes/storage/use-sqlprovider-ssdt/#installing-sqlprovider-from-nuget","title":"Installing SQLProvider from NuGet","text":"<ul> <li>Install the <code>SQLProvider</code> NuGet package to the Server project</li> <li>Install the <code>System.Data.SqlClient</code> NuGet package to the Server project</li> </ul>"},{"location":"v4-recipes/storage/use-sqlprovider-ssdt/#initialize-type-provider","title":"Initialize Type Provider","text":"<p>Next, we will wire up our type provider to generate database types based on the compiled .dacpac file.</p> <p>1) In the Server project, create a new file, <code>Database.fs</code>. (this should be above <code>Server.fs</code>).</p> <pre><code>module Database\nopen FSharp.Data.Sql\n\n[&lt;Literal&gt;]\nlet SsdtPath = __SOURCE_DIRECTORY__ + @\"/../../ssdt/SafeTodoDB/bin/Debug/SafeTodoDB.dacpac\"\n\n// TO RELOAD SCHEMA: 1) uncomment the line below; 2) save; 3) recomment; 4) save again and wait.\n//DB.GetDataContext().``Design Time Commands``.ClearDatabaseSchemaCache\n\ntype DB = \n    SqlDataProvider&lt;\n        Common.DatabaseProviderTypes.MSSQLSERVER_SSDT, \n        SsdtPath = SsdtPath,\n        UseOptionTypes = true\n    &gt;\n\nlet createContext (connectionString: string) =\n    DB.GetDataContext(connectionString)\n</code></pre> <p>2) Create <code>TodoRepository.fs</code> below <code>Database.fs</code>.</p> <pre><code>module TodoRepository\nopen FSharp.Data.Sql\nopen Database\nopen Shared\n\n/// Get all todos that have not been marked as \"done\". \nlet getTodos (db: DB.dataContext) = \n    query {\n        for todo in db.Dbo.Todos do\n        where (not todo.IsDone)\n        select \n            { Shared.Todo.Id = todo.Id\n              Shared.Todo.Description = todo.Description }\n    }\n    |&gt; List.executeQueryAsync\n\nlet addTodo (db: DB.dataContext) (todo: Shared.Todo) =\n    async {\n        let t = db.Dbo.Todos.Create()\n        t.Id &lt;- todo.Id\n        t.Description &lt;- todo.Description\n        t.IsDone &lt;- false\n\n        do! db.SubmitUpdatesAsync()\n    }\n</code></pre> <p>3) Create <code>TodoController.fs</code> below <code>TodoRepository.fs</code>.</p> <pre><code>module TodoController\nopen Database\nopen Shared\n\nlet getTodos (db: DB.dataContext) = \n    TodoRepository.getTodos db\n\nlet addTodo (db: DB.dataContext) (todo: Todo) = \n    async {\n        if Todo.isValid todo.Description then\n            do! TodoRepository.addTodo db todo\n            return todo\n        else \n            return failwith \"Invalid todo\"\n    }\n</code></pre> <p>4) Finally, replace the stubbed todosApi implementation in <code>Server.fs</code> with our type provided implementation.</p> <pre><code>module Server\n\nopen Fable.Remoting.Server\nopen Fable.Remoting.Giraffe\nopen Saturn\nopen System\nopen Shared\nopen Microsoft.AspNetCore.Http\n\nlet todosApi =\n    let db = Database.createContext @\"Data Source=.\\SQLEXPRESS;Initial Catalog=SafeTodo;Integrated Security=SSPI;\"\n    { getTodos = fun () -&gt; TodoController.getTodos db\n      addTodo = TodoController.addTodo db }\n\nlet fableRemotingErrorHandler (ex: Exception) (ri: RouteInfo&lt;HttpContext&gt;) = \n    printfn \"ERROR: %s\" ex.Message\n    Propagate ex.Message\n\nlet webApp =\n    Remoting.createApi()\n    |&gt; Remoting.withRouteBuilder Route.builder\n    |&gt; Remoting.fromValue todosApi\n    |&gt; Remoting.withErrorHandler fableRemotingErrorHandler\n    |&gt; Remoting.buildHttpHandler\n\nlet app =\n    application {\n        use_router webApp\n        memory_cache\n        use_static \"public\"\n        use_gzip\n    }\n\nrun app\n</code></pre>"},{"location":"v4-recipes/storage/use-sqlprovider-ssdt/#run-the-app","title":"Run the App!","text":"<p>From the VS Code terminal in the SafeTodo folder, launch the app (server and client):</p> <p><code>dotnet run</code></p> <p>You should now be able to add todos.</p> <p></p>"},{"location":"v4-recipes/storage/use-sqlprovider-ssdt/#deployment","title":"Deployment","text":"<p>When creating a Release build for deployment, it is important to note that SQLProvider SSDT expects that the .dacpac file will be copied to the deployed Server project bin folder. </p> <p>Here are the steps to accomplish this:</p> <p>1) Modify your Server.fsproj to include the .dacpac file with \"CopyToOutputDirectory\" to ensure that the .dacpac file will always exist in the Server project bin folder.</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;None Include=\"..\\{relative path to SSDT project}\\ssdt\\SafeTodo\\bin\\$(Configuration)\\SafeTodoDB.dacpac\" Link=\"SafeTodoDB.dacpac\"&gt;\n        &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;\n    &lt;/None&gt;\n\n    { other files... }\n&lt;/ItemGroup&gt;\n</code></pre> <p>2) In your Server.Database.fs file, you should also modify the SsdtPath binding so that it can build the project in either Debug or Release mode:</p> <pre><code>[&lt;Literal&gt;]\n#if DEBUG\n      let SsdtPath = __SOURCE_DIRECTORY__ + @\"/../../ssdt/SafeTodoDB/bin/Debug/SafeTodoDB.dacpac\"\n#else\n      let SsdtPath = __SOURCE_DIRECTORY__ + @\"/../../ssdt/SafeTodoDB/bin/Release/SafeTodoDB.dacpac\"\n#endif\n</code></pre> <p>NOTE: This assumes that your SSDT .sqlproj will be built in Release mode. (You can build it manually, or use a FAKE build script to handle this.)</p>"},{"location":"v4-recipes/ui/add-bulma/","title":"How do I add Bulma to a SAFE project?","text":"<p>Bulma is a free open-source UI framework based on flex-box that helps you create modern and responsive layouts. When it comes to using Bulma as your front-end library on a SAFE Stack web application, you have two options.</p> <ol> <li>Feliz.Bulma: Feliz.Bulma is a Bulma wrapper for Feliz.</li> <li>Fulma: Fulma provides a wrapper around Bulma for fable-react.</li> </ol> <p>By adding either of these to your SAFE project alongside the Bulma stylesheet or the Bulma NPM package, you can take full advantage of Bulma.</p>"},{"location":"v4-recipes/ui/add-bulma/#using-felizbulma","title":"Using Feliz.Bulma","text":"<ol> <li>Add the Feliz.Bulma NuGet package to the solution.</li> <li>Start using Feliz.Bulma components in your F# files. <pre><code>open Feliz.Bulma\n\nBulma.button.button [\n   str \"Click me!\"\n]\n</code></pre></li> </ol>"},{"location":"v4-recipes/ui/add-bulma/#using-fulma","title":"Using Fulma","text":"<ol> <li>Add the Fulma NuGet package to the solution.</li> <li>Start using Fulma components in your F# files. <pre><code>open Fulma\n\nButton.button [] [\n   str \"Click me!\"\n]\n</code></pre></li> </ol>"},{"location":"v4-recipes/ui/add-daisyui/","title":"Add daisyUI support","text":"<p>DaisyUI is a component library for Tailwind CSS. To use the library from within F# we will use Feliz.DaisyUI (Github).</p> <ol> <li> <p>Follow the instructions for how to add Tailwind CSS to your project</p> </li> <li> <p>Add daisyUI JS dependencies using NPM: <code>npm i -D daisyui@latest</code></p> </li> <li> <p>Add Feliz.DaisyUI .NET dependency...</p> <ul> <li>via Paket:  <code>dotnet paket add Feliz.DaisyUI</code></li> <li>via NuGet: <code>dotnet add package Feliz.DaisyUI</code></li> </ul> </li> <li> <p>Update the <code>tailwind.config.js</code> file's <code>module.exports.plugins</code> array; add <code>require(\"daisyui\")</code></p> tailwind.config.js<pre><code>module.exports = {\n    content: [\n        './src/Client/**/*.html',\n        './src/Client/**/*.fs',\n    ],\n    theme: {\n        extend: {},\n    },\n    plugins: [\n        require(\"daisyui\"),\n    ],\n}\n</code></pre> </li> <li> <p>Open the daisyUI namespace wherever you want to use it.     YourFileHere.fs<pre><code>open Feliz.DaisyUI\n</code></pre></p> </li> <li> <p>Congratulations, now you can use daisyUI components!     Documentation can be found at https://dzoukr.github.io/Feliz.DaisyUI/</p> </li> </ol>"},{"location":"v4-recipes/ui/add-fontawesome/","title":"How Do I Use FontAwesome?","text":"<p>FontAwesome is the most popular icon set out there and will provide you with a handful of free icons as well as a multitude of premium icons. The standard SAFE template has out-of-the-box support for FontAwesome. You can just start using it in your Client code like so:</p> <p><pre><code>open Feliz\n\nHtml.i [ prop.className \"fas fa-star\" ]\n</code></pre> This will display a solid star icon.</p>"},{"location":"v4-recipes/ui/add-fontawesome/#i-am-using-the-minimal-template","title":"I am Using the Minimal Template","text":"<p>If you\u2019re using the minimal template, there are a couple of things to do before you can start using FontAwesome. If you don't need the full features of Feliz we suggest using <code>Fable.FontAwesome.Free</code>.</p>"},{"location":"v4-recipes/ui/add-fontawesome/#1-the-nuget-package","title":"1. The NuGet Package","text":"<p>Add Fable.FontAwesome.Free NuGet Package to the Client project.</p> <p>See How do I add a NuGet package to the Client?.</p>"},{"location":"v4-recipes/ui/add-fontawesome/#2-the-cdn-link","title":"2. The CDN Link","text":"<p>Open the <code>index.html</code> file and add the following line to the <code>head</code> element: <pre><code>&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css\"&gt;\n</code></pre></p>"},{"location":"v4-recipes/ui/add-fontawesome/#3-code-snippet","title":"3. Code snippet","text":"<pre><code>open Fable.FontAwesome\n\nIcon.icon [\n    Fa.i [ Fa.Solid.Star ] [ ]\n]\n</code></pre>"},{"location":"v4-recipes/ui/add-fontawesome/#all-done","title":"All Done!","text":"<p>Now you can use FontAwesome in your code</p>"},{"location":"v4-recipes/ui/add-routing-with-separate-models/","title":"How do I add routing to a SAFE app with separate model for every page?","text":"<p>Written for SAFE template version 4.2.0</p> <p>If your application has multiple separate components, there is no need to have one big, complex model that manages all the state for all components. In this recipe we separate the information of the todo list out of the main <code>Model</code>, and give the todo list application its own route. We also add a \"Page not found\" page.</p>"},{"location":"v4-recipes/ui/add-routing-with-separate-models/#1-adding-the-feliz-router","title":"1. Adding the Feliz router","text":"<p>Install Feliz.Router in the client project</p> <pre><code>dotnet paket add Feliz.Router -p Client -V 3.8\n</code></pre> <p>Feliz.Router versions</p> <p>At the time of writing, the current version of the SAFE template (4.2.0) does not work well with the latest version of Feliz.Router (4.0). To work around this, we install Feliz.Router 3.8, the latest version that works with SAFE template version 4.2.0.</p> <p>If you are working with a newer version of the SAFE template, it might be worth trying to install the newest version of Feliz.Router. To see the installed version of the SAFE template, run in the command line:</p> <pre><code>dotnet new --list\n</code></pre> <p>To include the router in the Client, open <code>Feliz.Router</code> at the top of Index.fs</p> Index.fs<pre><code>open Feliz.Router\n</code></pre>"},{"location":"v4-recipes/ui/add-routing-with-separate-models/#2-creating-a-module-for-the-todo-list","title":"2. Creating a module for the Todo list","text":"<p>Move the following functions and types to a new <code>TodoList</code> Module in a file <code>TodoList.fs</code>:</p> <ul> <li>Model</li> <li>Msg</li> <li>todosApi</li> <li>init</li> <li>update</li> <li>containerBox; rename this to view</li> </ul> <p>also open <code>Shared</code>, <code>Fable.Remoting.Client</code>, <code>Elmish</code> <code>Feliz</code> and <code>Feliz.Bulma</code></p> TodoList.fs<pre><code>module TodoList\n\nopen Shared\nopen Fable.Remoting.Client\nopen Elmish\nopen Feliz\nopen Feliz.Bulma\n\n\ntype Model = { Todos: Todo list; Input: string }\n\ntype Msg =\n    | GotTodos of Todo list\n    | SetInput of string\n    | AddTodo\n    | AddedTodo of Todo\n\nlet todosApi =\n    Remoting.createApi ()\n    |&gt; Remoting.withRouteBuilder Route.builder\n    |&gt; Remoting.buildProxy&lt;ITodosApi&gt;\n\nlet init () : Model * Cmd&lt;Msg&gt; =\n    let model = { Todos = []; Input = \"\" }\n    let cmd = Cmd.OfAsync.perform todosApi.getTodos () GotTodos\n\n    model, cmd\n\nlet update (msg: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n    match msg with\n    | GotTodos todos -&gt; { model with Todos = todos }, Cmd.none\n    | SetInput value -&gt; { model with Input = value }, Cmd.none\n    | AddTodo -&gt;\n        let todo = Todo.create model.Input\n\n        let cmd = Cmd.OfAsync.perform todosApi.addTodo todo AddedTodo\n\n        { model with Input = \"\" }, cmd\n    | AddedTodo todo -&gt; { model with Todos = model.Todos @ [ todo ] }, Cmd.none\n\nlet view (model: Model) (dispatch: Msg -&gt; unit) =\n    Bulma.box [\n        Bulma.content [\n            Html.ol [\n                for todo in model.Todos do\n                    Html.li [ prop.text todo.Description ]\n            ]\n        ]\n        Bulma.field.div [\n            field.isGrouped\n            prop.children [\n                Bulma.control.p [\n                    control.isExpanded\n                    prop.children [\n                        Bulma.input.text [\n                            prop.value model.Input\n                            prop.placeholder \"What needs to be done?\"\n                            prop.onChange (fun x -&gt; SetInput x |&gt; dispatch)\n                        ]\n                    ]\n                ]\n                Bulma.control.p [\n                    Bulma.button.a [\n                        color.isPrimary\n                        prop.disabled (Todo.isValid model.Input |&gt; not)\n                        prop.onClick (fun _ -&gt; dispatch AddTodo)\n                        prop.text \"Add\"\n                    ]\n                ]\n            ]\n        ]\n    ]\n</code></pre>"},{"location":"v4-recipes/ui/add-routing-with-separate-models/#3-adding-a-new-model-to-the-index-page","title":"3. Adding a new Model to the Index page","text":"<p>Create a new Model in the <code>Index</code> module, to keep track of the open page</p> Index.fs<pre><code>type Page =\n    | TodoList of TodoList.Model\n    | NotFound \n\ntype Model = { CurrentPage: Page }\n</code></pre>"},{"location":"v4-recipes/ui/add-routing-with-separate-models/#4-updating-the-todolist-model","title":"4. Updating the TodoList model","text":"<p>Add a <code>Msg</code> type with a case of <code>TodoList.Msg</code></p> Index.fs<pre><code>type Msg =\n    | TodoListMsg of TodoList.Msg\n</code></pre> <p>Create an <code>update</code> function (we moved the original one to <code>TodoList</code>). Handle the <code>TodoListMsg</code> by updating the <code>TodoList</code> Model. Wrap the command returned by the <code>update</code> of the todo list in a <code>TodoListMsg</code> before returning it. We expand this function later with other cases that deal with navigation.</p> Index.fs<pre><code>let update (message: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n    match model.CurrentPage, message with\n    | TodoList todoList, TodoListMsg todoListMessage -&gt;\n        let newTodoListModel, newCommand = TodoList.update todoListMessage todoList\n        let model = { model with CurrentPage = TodoList newTodoListModel }\n\n        model, newCommand |&gt; Cmd.map TodoListMsg\n</code></pre>"},{"location":"v4-recipes/ui/add-routing-with-separate-models/#5-initializing-from-url","title":"5. Initializing from URL","text":"<p>Create a function <code>initFromUrl</code>; initialize the <code>TodoList</code> app when given the URL of the todo list app. Also return the command that TodoList's <code>init</code> may return, wrapped in a <code>TodoListMsg</code></p> Index.fs<pre><code>let initFromUrl url =\n    match url with\n    | [ \"todo\" ] -&gt;\n        let todoListModel, todoListMsg = TodoList.init ()\n        let model = { CurrentPage = TodoList todoListModel }\n\n        model, todoListMsg |&gt; Cmd.map TodoListMsg\n</code></pre> <p>Add a wildcard, so any URLs that are not registered display the \"not found\" page</p> CodeDiff Index.fs<pre><code>let initFromUrl url =\n    match url with\n    ...\n    | _ -&gt; { CurrentPage = NotFound }, Cmd.none\n</code></pre> Index.fs<pre><code> let initFromUrl url =\n     match url with\n     ...\n+    | _ -&gt; { CurrentPage = NotFound }, Cmd.none\n</code></pre>"},{"location":"v4-recipes/ui/add-routing-with-separate-models/#6-elmish-initialization","title":"6. Elmish initialization","text":"<p>Add an <code>init</code> function to <code>Index</code>; return the current page based on <code>Router.currentUrl</code></p> Index.fs<pre><code>let init () : Model * Cmd&lt;Msg&gt; =\n    Router.currentUrl ()\n    |&gt; initFromUrl\n</code></pre>"},{"location":"v4-recipes/ui/add-routing-with-separate-models/#7-handling-url-changes","title":"7. Handling URL Changes","text":"<p>Add an <code>UrlChanged</code> case of <code>string list</code> to the <code>Msg</code> type</p> CodeDiff Index.fs<pre><code>type Msg =\n    ...\n    | UrlChanged of string list\n</code></pre> Index.fs<pre><code> type Msg =\n     ...\n+    | UrlChanged of string list\n</code></pre> <p>Handle the case in the <code>update</code> function by calling <code>initFromUrl</code></p> CodeDiff Index.fs<pre><code>let update (message: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n    ...\n    match model.CurrentPage, message with\n    | _, UrlChanged url -&gt; initFromUrl url\n</code></pre> Index.fs<pre><code> let update (message: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n     ...\n+    match model.CurrentPage, message with\n+    | _, UrlChanged url -&gt; initFromUrl url\n</code></pre>"},{"location":"v4-recipes/ui/add-routing-with-separate-models/#8-catching-all-cases-in-the-update-function","title":"8. Catching all cases in the update function","text":"<p>Complete the pattern match in the <code>update</code> function, adding a case with a wildcard for both <code>message</code> and <code>model</code>. Return the model, and no command</p> CodeDiff Index.fs<pre><code>let update (message: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n    ...\n    | _, _ -&gt; model, Cmd.none\n</code></pre> Index.fs<pre><code> let update (message: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n     ...\n+    | _, _ -&gt; model, Cmd.none\n</code></pre>"},{"location":"v4-recipes/ui/add-routing-with-separate-models/#9-rendering-pages","title":"9. Rendering pages","text":"<p>Add a function containerBox to the <code>Index</code> module. If the CurrentPage is of <code>TodoList</code>, render the todo list using <code>TodoList.view</code>; in order to dispatch a <code>TodoList.Msg</code>, it needs to be wrapped in a <code>TodoListMsg</code>.</p> <p>For the <code>NotFound</code> page, return a \"Page not found\" box</p> Index.fs<pre><code>let containerBox model dispatch =\n    match model.CurrentPage with\n    | TodoList todoModel -&gt; TodoList.view todoModel (TodoListMsg &gt;&gt; dispatch)\n    | NotFound -&gt; Bulma.box \"Page not found\"\n</code></pre>"},{"location":"v4-recipes/ui/add-routing-with-separate-models/#10-adding-the-react-router-to-the-view","title":"10. Adding the React router to the view","text":"<p>Wrap the content of the view function in a <code>router.children</code> property of a <code>React.router</code>. Also add an <code>onUrlChanged</code> property, that dispatches the 'UrlChanged' message.</p> CodeDiff Index.fs<pre><code>let view (model: Model) (dispatch: Msg -&gt; unit) =\n    React.router [\n        router.onUrlChanged (UrlChanged &gt;&gt; dispatch)\n        router.children [\n            Bulma.hero [\n            ...\n            ]\n        ]\n    ]\n</code></pre> Index.fs<pre><code> let view (model: Model) (dispatch: Msg -&gt; unit) =\n+    React.router [\n+        router.onUrlChanged (UrlChanged &gt;&gt; dispatch)\n+        router.children [\n             Bulma.hero [\n             ...\n             ]\n+        ]\n+    ]\n</code></pre>"},{"location":"v4-recipes/ui/add-routing-with-separate-models/#11-running-the-app","title":"11. Running the app","text":"<p>The routing should work now. Try navigating to localhost:8080; you should see a page with \"Page not Found\". If you go to localhost:8080/#/todo, you should see the todo app.</p> <p># sign</p> <p>You might be surprised to see the hash sign as part of the URL. It enables React to react to URL changes without a full page refresh. There are ways to omit this, but getting this to work properly is outside of the scope of this recipe.</p>"},{"location":"v4-recipes/ui/add-routing/","title":"How do I add routing to a SAFE app with a shared model for all pages?","text":"<p>Written for SAFE template version 4.2.0</p> <p>When building larger apps, you probably want different pages to be accessible through different URLs. In this recipe, we show you how to add routes to different pages to an application, including adding a \"page not found\" page that is displayed when an unknown URL is entered.</p> <p>In this recipe we use the simplest approach to storing states for multiple pages, by creating a single state for the full app. A potential benefit of this approach is that the state of a page is not lost when navigating away from it. You will see how that works at the end of the recipe.</p>"},{"location":"v4-recipes/ui/add-routing/#1-adding-the-feliz-router","title":"1. Adding the Feliz router","text":"<p>Install Feliz.Router in the client project</p> <pre><code>dotnet paket add Feliz.Router -p Client -V 3.8\n</code></pre> <p>Feliz.Router versions</p> <p>At the time of writing, the current version of the SAFE template (4.2.0) does not work well with the latest version of Feliz.Router (4.0). To work around this, we install Feliz.Router 3.8, the latest version that works with SAFE template version 4.2.0.</p> <p>If you are working with a newer version of the SAFE template, it might be worth trying to install the newest version of Feliz.Router. To see the installed version of the SAFE template, run in the command line:</p> <pre><code>dotnet new --list\n</code></pre> <p>To include the router in the Client, open <code>Feliz.Router</code> at the top of Index.fs</p> <pre><code>open Feliz.Router\n</code></pre>"},{"location":"v4-recipes/ui/add-routing/#2-adding-the-url-object","title":"2. Adding the URL object","text":"<p>Add the current page to the model of the client, using a new <code>Page</code> type</p> CodeDiff <pre><code>type Page =\n    | TodoList\n    | NotFound\n\ntype Model =\n    { CurrentPage: Page\n      Todos: Todo list\n      Input: string }\n</code></pre> <pre><code>+ type Page =\n+     | TodoList\n+     | NotFound\n+\n- type Model = { Todos: Todo list; Input: string }\n+ type Model =\n+    { CurrentPage: Page\n+      Todos: Todo list\n+      Input: string }\n</code></pre>"},{"location":"v4-recipes/ui/add-routing/#3-parsing-urls","title":"3.  Parsing URLs","text":"<p>Create a function to parse a URL to a page, including a wildcard for unmapped pages</p> <pre><code>let parseUrl url = \n    match url with\n    | [\"todo\"] -&gt; Page.TodoList\n    | _ -&gt; Page.NotFound\n</code></pre>"},{"location":"v4-recipes/ui/add-routing/#4-initialization-when-using-a-url","title":"4. Initialization when using a URL","text":"<p>On initialization, set the current page</p> CodeDiff <pre><code>let init () : Model * Cmd&lt;Msg&gt; =\n    let page = Router.currentUrl () |&gt; parseUrl\n\n    let model =\n        { CurrentPage = page\n          Todos = []\n          Input = \"\" }\n    ...\n    model, cmd\n</code></pre> <pre><code>  let init () : Model * Cmd&lt;Msg&gt; =\n+     let page = Router.currentUrl () |&gt; parseUrl\n+\n-      let model = { Todos = []; Input = \"\" }\n+      let model =\n+        { CurrentPage = page\n+         Todos = []\n+         Input = \"\" }\n      ...\n      model, cmd\n</code></pre>"},{"location":"v4-recipes/ui/add-routing/#5-updating-the-url","title":"5. Updating the URL","text":"<p>Add an action to handle navigation.</p> <p>To the <code>Msg</code> type, add a <code>PageChanged</code> case of <code>Page</code></p> CodeDiff <pre><code>type Msg =\n    ...\n    | PageChanged of Page\n</code></pre> <pre><code> type Msg =\n     ...\n+    | PageChanged of Page\n</code></pre> <p>Add the <code>PageChanged</code> update action</p> CodeDiff <pre><code>let update (msg: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n    match msg with\n    ...\n    | PageChanged page -&gt; { model with CurrentPage = page }, Cmd.none\n</code></pre> <pre><code>  let update (msg: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n      match msg with\n      ...\n+     | PageChanged page -&gt; { model with CurrentPage = page }, Cmd.none\n</code></pre>"},{"location":"v4-recipes/ui/add-routing/#6-displaying-the-correct-content","title":"6. Displaying the correct content","text":"<p>Rename the <code>view</code> function to <code>todoView</code></p> CodeDiff <pre><code>let todoView (model: Model) (dispatch: Msg -&gt; unit) =\n    Bulma.hero [\n    ...\n    ]\n</code></pre> <pre><code>- let view (model: Model) (dispatch: Msg -&gt; unit) =\n+ let todoView (model: Model) (dispatch: Msg -&gt; unit) =\n      Bulma.hero [\n      ...\n      ]\n</code></pre> <p>Add a new view function, that returns the appropriate page</p> <pre><code>let view (model: Model) (dispatch: Msg -&gt; unit) =\n    match model.CurrentPage with\n    | TodoList -&gt; todoView model dispatch\n    | NotFound -&gt; Bulma.box \"Page not found\"\n</code></pre> <p>Adding UI elements to every page of the website</p> <p>In this recipe, we moved all the page content to the <code>todoView</code>, but you don't have to. You can add UI you want to display on every page of the application to the <code>view</code> function.</p>"},{"location":"v4-recipes/ui/add-routing/#7-adding-the-react-router-to-the-view","title":"7. Adding the React router to the view","text":"<p>Add the <code>React.Router</code> element as the outermost element of the view. Dispatch the PageChanged event on <code>onUrlChanged</code></p> CodeDiff <pre><code>let view (model: Model) (dispatch: Msg -&gt; unit) =\n    React.router [\n        router.onUrlChanged (parseUrl &gt;&gt; PageChanged &gt;&gt; dispatch)\n        router.children [\n            match model.CurrentPage with\n            ...\n        ]\n    ]\n</code></pre> <pre><code>  let view (model: Model) (dispatch: Msg -&gt; unit) =\n+     React.router [\n+         router.onUrlChanged (parseUrl &gt;&gt; PageChanged &gt;&gt; dispatch)\n          router.children [\n              match model.CurrentPage with\n              ...\n          ]\n      ]\n</code></pre>"},{"location":"v4-recipes/ui/add-routing/#9-try-it-out","title":"9.  Try it out","text":"<p>The routing should work now. Try navigating to localhost:8080; you should see a page with \"Page not Found\". If you go to localhost:8080/#/todo, you should see the todo app.</p> <p>To see how the state is maintained even when navigating away from the page, type something in the text box and move away from the page by entering another path in the address bar. Then go back to the todo page. The entered text is still there.</p> <p># sign</p> <p>You might be surprised to see the hash sign as part of the URL. It enables React to react to URL changes without a full page refresh. There are ways to omit this, but getting this to work properly is outside of the scope of this recipe.</p>"},{"location":"v4-recipes/ui/add-routing/#10-adding-more-pages","title":"10. Adding more pages","text":"<p>Now that you have set up the routing, adding more pages is simple: add a new case to the <code>Page</code> type; add a route for this page in the <code>parseUrl</code> function; add a function that takes a model and dispatcher to generate your new page, and add a new case to the pattern match inside the <code>view</code> function to display the new case.</p>"},{"location":"v4-recipes/ui/add-style/","title":"How Do I Use stylesheets with SAFE?","text":"<p>If you wish to use your own CSS or SASS stylesheets with SAFE apps, you can embed either through webpack. The template already includes all required NPM packages you may need, so you will only need to configure webpack to reference your stylesheet and include in the outputs.</p>"},{"location":"v4-recipes/ui/add-style/#adding-the-stylesheet","title":"Adding the Stylesheet","text":"<p>First, create a CSS file in the <code>src/Client</code> folder of your solution e.g <code>style.css</code>.</p> <p>The same approach can be taken for <code>.scss</code> files.</p>"},{"location":"v4-recipes/ui/add-style/#configuring-webpack","title":"Configuring WebPack","text":""},{"location":"v4-recipes/ui/add-style/#im-using-the-standard-template","title":"I'm using the Standard Template","text":""},{"location":"v4-recipes/ui/add-style/#1-link-to-the-stylesheet","title":"1. Link to the stylesheet","text":"<p>Inside the <code>webpack.config.js</code> file, add the following variable to the <code>CONFIG</code> object, which points to the style file you created previously. <pre><code>cssEntry: './src/Client/style.css',\n</code></pre></p>"},{"location":"v4-recipes/ui/add-style/#2-embed-css-into-outputs","title":"2. Embed CSS into outputs","text":"<p>Find the <code>entry</code> field in the <code>module.exports</code> object at the bottom of the file, and replace it with the following: <pre><code>entry: isProduction ? {\n    app: [resolve(CONFIG.fsharpEntry), resolve(CONFIG.cssEntry)]\n} : {\n    app: resolve(CONFIG.fsharpEntry),\n    style: resolve(CONFIG.cssEntry)\n},\n</code></pre></p> <p>This combines the css and F# outputs into a single bundle for production, and separately for dev.</p>"},{"location":"v4-recipes/ui/add-style/#im-using-the-minimal-template","title":"I'm using the Minimal Template","text":""},{"location":"v4-recipes/ui/add-style/#1-embed-css-into-outputs","title":"1. Embed CSS into outputs","text":"<p>Find the <code>entry</code> field in the <code>module.exports</code> object at the bottom of the file, and replace it with the following: <pre><code>entry: {\n    app: [\n        resolve('./src/Client/Client.fsproj'),\n        resolve('./src/Client/style.css')\n    ]\n},\n</code></pre></p>"},{"location":"v4-recipes/ui/add-style/#there-you-have-it","title":"There you have it!","text":"<p>You can now style your app by writing to the <code>style.css</code> file.</p>"},{"location":"v4-recipes/ui/add-tailwind/","title":"How do I add Tailwind to a SAFE project?","text":"<p>Tailwind is a utility-first CSS framework packed that can be composed to build any design, directly in your markup.</p> <ol> <li> <p>Add a stylesheet to the project</p> </li> <li> <p>Install the required npm packages     <pre><code>npm install -D tailwindcss postcss autoprefixer postcss-loader\n</code></pre></p> </li> <li>Initialise a <code>tailwind.config.js</code> <pre><code>npx tailwindcss init\n</code></pre></li> <li> <p>Amend the content array in the <code>tailwind.config.js</code> as follows     <pre><code>module.exports = {\n  content: [\n      './src/Client/**/*.html',\n      './src/Client/**/*.fs',\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n</code></pre></p> </li> <li> <p>Create a <code>postcss.config.js</code> with the following     <pre><code>module.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  }\n}\n</code></pre></p> </li> <li> <p>Add the Tailwind layers to your <code>style.css</code> <pre><code>@tailwind base;\n@tailwind components;\n@tailwind utilities;\n</code></pre></p> </li> <li> <p>Find the <code>module.rules</code> field in the <code>webpack.config.js</code> and in the css files rule\u2019s <code>use</code> field add <code>postcss-loader</code> <pre><code>{\n    test: /\\.(sass|scss|css)$/,\n    use: [\n        isProduction\n            ? MiniCssExtractPlugin.loader\n            : 'style-loader',\n        'css-loader',\n        {\n            loader: 'sass-loader',\n            options: { implementation: require('sass') }\n        },\n        'postcss-loader'\n    ],\n},\n</code></pre></p> </li> <li> <p>In the <code>src/Client</code> folder find the code in <code>Index.fs</code> to show the list of todos and add a Tailwind text colour class(text-red-200)     <pre><code>for todo in model.Todos do\n    Html.li [\n        prop.classes [ \"text-red-200\" ]\n        prop.text todo.Description\n    ]\n</code></pre></p> </li> </ol> <p>You should see some nice red todos proving that Tailwind is now in your project</p>"},{"location":"v4-recipes/ui/cdn-to-npm/","title":"How do I migrate from a CDN stylesheet to an NPM package?","text":"<p>Though the SAFE template default for referencing a stylesheet is to use a CDN, it\u2019s quite reasonable to want to use an NPM package instead. One common case is that it enables you to further customise Bulma themes by overriding Sass variables.</p>"},{"location":"v4-recipes/ui/cdn-to-npm/#1-remove-the-cdn-reference","title":"1. Remove the CDN Reference","text":"<p>Find the following line in <code>src/Client/index.html</code> and delete it before moving on: <pre><code>&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\"&gt;\n</code></pre></p>"},{"location":"v4-recipes/ui/cdn-to-npm/#2-add-the-npm-package","title":"2. Add the NPM Package","text":"<p>Go ahead and add the Bulma NPM package to your project.</p> <p>See: How do I add an NPM package to the client?</p>"},{"location":"v4-recipes/ui/cdn-to-npm/#3-load-the-stylesheets","title":"3. Load the Stylesheets","text":"<p>There are two ways for loading the stylesheets:</p>"},{"location":"v4-recipes/ui/cdn-to-npm/#fable-interop","title":"Fable Interop","text":"<p>A quick and easy way to reference this NPM package in an F# file is to insert the following couple of lines:</p> <pre><code>open Fable.Core.JsInterop\nimportAll \"bulma/bulma.sass\"\n</code></pre> <p>You can use this approach for any NPM package.</p>"},{"location":"v4-recipes/ui/cdn-to-npm/#b-using-sass","title":"b. Using Sass","text":"<ol> <li>Add a Sass stylesheet to your project using this recipe.</li> <li>Add the following line to your Sass file to bring in Bulma <pre><code>@import \"~bulma/bulma.sass\"\n</code></pre></li> </ol>"},{"location":"v4-recipes/ui/remove-bulma/","title":"How do I remove Bulma from a SAFE project?","text":"<ol> <li> <p>Remove / replace all the references to Bulma in fsharp code</p> </li> <li> <p>Remove any stylesheet links to Bulma which may exist in the <code>index.html</code> page, or in other html pages.</p> </li> <li> <p>Optional: If using Paket ensure <code>Fable.Core</code> is set to a specified version.</p> <p>In <code>paket.dependencies</code>, make sure there is a line like so: <code>Fable.Core ~&gt; 3</code></p> <p>Warning</p> <p>SAFE is not yet compatible with newer versions of <code>Fable.Core</code>. In the past, the version was not pinned so it was possible to accidentally upgrade to an incompatible version.</p> <p>Info</p> <p>To avoid specifying a version when adding a dependency - if it is not already pinned to a specific version - you can use the  <code>--keep-major</code> flag to make the upgrade more conservative.</p> </li> <li> <p>Remove <code>Fulma</code> and <code>Feliz.Bulma</code></p> <ul> <li> <p>Paket: <pre><code>dotnet paket remove Fulma\ndotnet paket remove Feliz.Bulma\n</code></pre></p> </li> <li> <p>NuGet: <pre><code>cd src/Client\ndotnet remove package Fulma\ndotnet remove package Feliz.Bulma\n</code></pre></p> </li> </ul> </li> </ol>"},{"location":"v4-recipes/ui/routing-with-elmish/","title":"How do I create multi-page applications with routing and the useElmish hook?","text":"<p>Written for SAFE template version 4.2.0</p> <p>UseElmish is a powerful package that allows you to write standalone components using Elmish. A component built around the <code>UseElmish</code> hook has its own view, state and update function.</p> <p>In this recipe we add routing to a safe app, and implement the todo list page using the <code>UseElmish</code> hook.</p>"},{"location":"v4-recipes/ui/routing-with-elmish/#1-installing-dependencies","title":"1. Installing dependencies","text":"<p>Pin Fable.Core to V3</p> <p>At the time of writing, the published version of the SAFE template does not have the version of <code>Fable.Core</code> pinned; this can create problems when installing dependencies.</p> <p>If you are using version v.4.2.0 of the template, pin <code>Fable.Core</code> to version 3 in <code>paket.depedencies</code> at the root of the project</p> paket.dependencies<pre><code>...\n-nuget Fable.Core\n+nuget Fable.Core ~&gt; 3\n...\n</code></pre> <p>Install Feliz.Router in the Client project</p> <pre><code>dotnet paket add Feliz.Router -p Client -V 3.8\n</code></pre> <p>Feliz.Router versions</p> <p>At the time of writing, the current version of the SAFE template (4.2.0) does not work well with the latest version of Feliz.Router (4.0). To work around this, we install Feliz.Router 3.8, the latest version that works with SAFE template version 4.2.0.</p> <p>If you are working with a newer version of the SAFE template, it might be worth trying to install the newest version of Feliz.Router. To see the installed version of the SAFE template, run in the command line:</p> <pre><code>dotnet new --list\n</code></pre> <p>Install Feliz.UseElmish in the Client project</p> <pre><code>dotnet paket add Feliz.UseElmish -p client\n</code></pre> <p>Open the router in the client project</p> Index.fs<pre><code>open Feliz.Router\n</code></pre>"},{"location":"v4-recipes/ui/routing-with-elmish/#2-extracting-the-todo-list-module","title":"2. Extracting the todo list module","text":"<p>Create a new Module <code>TodoList</code> in the client project. Move the following functions and types to the TodoList Module:</p> <ul> <li>Model</li> <li>Msg</li> <li>todosApi</li> <li>init</li> <li>update</li> <li>containerBox</li> </ul> <p>Also open <code>Shared</code>, <code>Fable.Remoting.Client</code>, <code>Elmish</code>, <code>Feliz.Bulma</code> and <code>Feliz</code>. </p> TodoList.fs<pre><code>module TodoList\n\nopen Shared\nopen Fable.Remoting.Client\nopen Elmish\n\nopen Feliz.Bulma\nopen Feliz\n\ntype Model = { Todos: Todo list; Input: string }\n\ntype Msg =\n    | GotTodos of Todo list\n    | SetInput of string\n    | AddTodo\n    | AddedTodo of Todo\n\nlet todosApi =\n    Remoting.createApi ()\n    |&gt; Remoting.withRouteBuilder Route.builder\n    |&gt; Remoting.buildProxy&lt;ITodosApi&gt;\n\nlet init () : Model * Cmd&lt;Msg&gt; =\n    let model = { Todos = []; Input = \"\" }\n    let cmd = Cmd.OfAsync.perform todosApi.getTodos () GotTodos\n\n    model, cmd\n\nlet update (msg: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n    match msg with\n    | GotTodos todos -&gt; { model with Todos = todos }, Cmd.none\n    | SetInput value -&gt; { model with Input = value }, Cmd.none\n    | AddTodo -&gt;\n        let todo = Todo.create model.Input\n\n        let cmd = Cmd.OfAsync.perform todosApi.addTodo todo AddedTodo\n\n        { model with Input = \"\" }, cmd\n    | AddedTodo todo -&gt; { model with Todos = model.Todos @ [ todo ] }, Cmd.none\n\nlet containerBox (model: Model) (dispatch: Msg -&gt; unit) =\n    Bulma.box [\n        Bulma.content [\n            Html.ol [\n                for todo in model.Todos do\n                    Html.li [ prop.text todo.Description ]\n            ]\n        ]\n        Bulma.field.div [\n            field.isGrouped\n            prop.children [\n                Bulma.control.p [\n                    control.isExpanded\n                    prop.children [\n                        Bulma.input.text [\n                            prop.value model.Input\n                            prop.placeholder \"What needs to be done?\"\n                            prop.onChange (fun x -&gt; SetInput x |&gt; dispatch)\n                        ]\n                    ]\n                ]\n                Bulma.control.p [\n                    Bulma.button.a [\n                        color.isPrimary\n                        prop.disabled (Todo.isValid model.Input |&gt; not)\n                        prop.onClick (fun _ -&gt; dispatch AddTodo)\n                        prop.text \"Add\"\n                    ]\n                ]\n            ]\n        ]\n    ]\n</code></pre>"},{"location":"v4-recipes/ui/routing-with-elmish/#4-add-the-useelmish-hook-to-the-todolist-module","title":"4. Add the UseElmish hook to the TodoList Module","text":"<p>open Feliz.UseElmish in the TodoList Module</p> TodoList.fs<pre><code>open Feliz.UseElmish\n...\n</code></pre> <p>In the todoList module, rename <code>containerBox</code> to <code>view</code>. On the first line, call <code>React.useElmish</code> passing it the <code>init</code> and <code>update</code> functions. Bind the output to <code>model</code> and <code>dispatch</code></p> CodeDiff TodoList.fs<pre><code>let view (model: Model) (dispatch: Msg -&gt; unit) =\n    let model, dispatch = React.useElmish(init, update, [||])\n    ...\n</code></pre> TodoList.fs<pre><code>-let containerBox (model: Model) (dispatch: Msg -&gt; unit) =\n+let view (model: Model) (dispatch: Msg -&gt; unit) =\n+    let model, dispatch = React.useElmish(init, update, [||])\n    ...\n</code></pre> <p>Replace the arguments of the function with unit, and add the <code>ReactComponent</code> attribute to it</p> CodeDiff Index.fs<pre><code>[&lt;ReactComponent&gt;]\nlet view () =\n    ...\n</code></pre> Index.fs<pre><code>+ [&lt;ReactComponent&gt;]\n- let view (model: Model) (dispatch: Msg -&gt; unit) =\n+ let view () =\n      ...\n</code></pre>"},{"location":"v4-recipes/ui/routing-with-elmish/#5-add-a-new-model-to-the-index-module","title":"5. Add a new model to the Index module","text":"<p>In the <code>Index module</code>, create a model that holds the current page</p> Index.fs<pre><code>type Page =\n    | TodoList\n    | NotFound\n\ntype Model =\n    { CurrentPage: Page }\n</code></pre>"},{"location":"v4-recipes/ui/routing-with-elmish/#6-initializing-the-application","title":"6. Initializing the application","text":"<p>Create a function that initializes the app based on an url</p> Index.fs<pre><code>let initFromUrl url =\n    match url with\n    | [ \"todo\" ] -&gt;\n        let model = { CurrentPage = TodoList }\n\n        model, Cmd.none\n    | _ -&gt;\n        let model = { CurrentPage = NotFound }\n\n        model, Cmd.none\n</code></pre> <p>Create a new <code>init</code> function, that fetches the current url, and calls initFromUrl. </p> Index.fs<pre><code>let init () =\n    Router.currentUrl ()\n    |&gt; initFromUrl\n</code></pre>"},{"location":"v4-recipes/ui/routing-with-elmish/#7-updating-the-page","title":"7. Updating the Page","text":"<p>Add a <code>Msg</code> type, with an PageChanged case</p> <p>Index.fs<pre><code>type Msg = \n    | PageChanged of string list\n</code></pre> Add an <code>update</code> function, that reinitializes the app based on an URL</p> Index.fs<pre><code>let update (msg: Msg) (model: Model) : Model * Cmd&lt;Msg&gt; =\n    match msg with\n    | PageChanged url -&gt;\n        initFromUrl url\n</code></pre>"},{"location":"v4-recipes/ui/routing-with-elmish/#8-displaying-pages","title":"8. Displaying pages","text":"<p>Add a containerBox function to the <code>Index</code> module, that returns the appropriate page content</p> Index.fs<pre><code>let containerBox (model: Model) (dispatch: Msg -&gt; unit) =\n    match model.CurrentPage with\n    | NotFound -&gt; Bulma.box \"Page not found\"\n    | TodoList -&gt; TodoList.view ()\n</code></pre>"},{"location":"v4-recipes/ui/routing-with-elmish/#9-add-the-router-to-the-view","title":"9. Add the router to the view","text":"<p>Wrap the content of the view method in a <code>React.Router</code> element's router.children property, and add a <code>router.onUrlChanged</code> property to dispatch the urlChanged message</p> CodeDiff Index.fs<pre><code>let view (model: Model) (dispatch: Msg -&gt; unit) =\n    React.router [\n        router.onUrlChanged ( PageChanged&gt;&gt;dispatch )\n        router.children [\n            Bulma.hero [\n            ...\n            ]\n        ]\n    ]\n</code></pre> Index.fs<pre><code>let view (model: Model) (dispatch: Msg -&gt; unit) =\n+   React.router [\n+       router.onUrlChanged ( PageChanged&gt;&gt;dispatch )\n+       router.children [\n            Bulma.hero [\n            ...\n            ]\n+       ]\n+   ]\n</code></pre>"},{"location":"v4-recipes/ui/routing-with-elmish/#10-try-it-out","title":"10.  Try it out","text":"<p>The routing should work now. Try navigating to localhost:8080; you should see a page with \"Page not Found\". If you go to localhost:8080/#/todo, you should see the todo app.</p> <p># sign</p> <p>You might be surprised to see the hash sign as part of the URL. It enables React to react to URL changes without a full page refresh. There are ways to omit this, but getting this to work properly is outside of the scope of this recipe.</p>"},{"location":"v4-recipes/ui/use-different-bulma-themes/","title":"How Do I Use Different Bulma Themes?","text":""},{"location":"v4-recipes/ui/use-different-bulma-themes/#bulmaswatch","title":"Bulmaswatch","text":"<p>Bulmaswatch is a great website for finding free Bulma themes. However, once you decide on what theme to use, visit this website to get a CDN link to its CSS file. For this recipe, I will use the Nuclear theme.</p>"},{"location":"v4-recipes/ui/use-different-bulma-themes/#i-am-using-the-standard-template","title":"I am Using the Standard Template","text":"<p>The standard template uses a CDN (Content Delivery Network) link to reference the Bulma theme that it uses. Changing the theme then, is as simple as changing this link. Since the class names Bulma uses to style HTML elements remain the same, we don\u2019t need to change anything else.</p>"},{"location":"v4-recipes/ui/use-different-bulma-themes/#1-find-the-link","title":"1. Find the Link","text":"<p>In your <code>index.html</code>, find the line that references the Bulma stylesheet that\u2019s used in the template through a CDN link. It will look like the following: <pre><code>&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css\"&gt;\n</code></pre></p>"},{"location":"v4-recipes/ui/use-different-bulma-themes/#2-change-the-link","title":"2. Change the Link","text":"<p>Go ahead and replace this link with the link to the theme that you want to use, which in my case is Nuclear: <pre><code>&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/bulmaswatch/0.8.1/nuclear/bulmaswatch.min.css\"&gt;\n</code></pre></p>"},{"location":"v4-recipes/ui/use-different-bulma-themes/#i-am-using-the-minimal-template","title":"I am Using the Minimal Template","text":""},{"location":"v4-recipes/ui/use-different-bulma-themes/#1-add-link-to-cdn","title":"1. Add Link to CDN","text":"<p>In your <code>index.html</code>, add the following line anywhere between the opening and closing <code>head</code> tags: <pre><code>&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css\"&gt;\n</code></pre></p>"},{"location":"v4-recipes/ui/use-different-bulma-themes/#2-add-fulma-or-felizbulma-to-the-solution","title":"2. Add Fulma or Feliz.Bulma to the Solution","text":"<p>Read this recipe for the rest of the instructions.</p> <p>And that\u2019s it. You should now see your app styled in accordance with the Bulma theme you\u2019ve just switched to.</p>"}]}